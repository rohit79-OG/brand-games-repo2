<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>KS Endless Embrace - Embrace Up 3X</title>
    
    <style>
  /* =================================
   BASE STYLES
   ================================= */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

body {
    font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    color: #fff;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    position: relative;
}

/* =================================
   GLASS MORPHISM COMPONENTS
   ================================= */

.glass {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
}

/* =================================
   SCREEN MANAGEMENT
   ================================= */

.screen {
    position: fixed;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    z-index: 10;
    top: 0;
    left: 0;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
}

.screen.active {
    display: flex;
    z-index: 100;
}

/* Desktop Screen Rules */
@media (min-width: 769px) {
    .screen {
        position: fixed !important;
        padding: 20px !important;
    }
    
    .screen:not(.active) {
        display: none !important;
    }
    
    .screen.active {
        display: flex !important;
        z-index: 100 !important;
    }
}

/* Mobile Screen Rules */
@media (max-width: 768px) {
    .screen:not(.active) {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
    }
    
    .screen.active {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        z-index: 1000 !important;
    }
}

/* =================================
   START SCREEN
   ================================= */

.start-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px auto;
    justify-content: center;
    min-height: auto;
}

/* Desktop Start Screen */
@media (min-width: 769px) {
    #startScreen {
        padding: 30px 20px !important;
        box-sizing: border-box;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
    }

    .start-panel {
        padding: 30px;
        max-width: 400px;
        width: 85%;
        margin: 20px auto;
    }

    .start-panel .btn {
        min-width: 200px;
        width: auto;
        padding: 12px 30px !important;
        margin: 8px 0;
    }

    .start-panel h1 {
        font-size: clamp(2rem, 8vw, 3rem);
    }

    .start-panel .brand-logo {
        margin-bottom: 20px;
    }

    .start-panel .game-logo {
        margin-bottom: 8px;
    }
}

/* Mobile Start Screen */
@media (max-width: 768px) {
    .start-panel {
        padding: 30px 20px 35px 20px;
        max-width: 92vw;
        width: 90%;
        margin: 0 auto;
    }

    #startScreen {
        padding: 0 !important;
        margin: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 100vh !important;
    }

    .start-panel h1 {
        font-size: 2rem !important;
    }

    .start-panel .brand-logo {
        margin-bottom: 15px !important;
    }

    .start-panel .game-logo {
        margin-bottom: 10px !important;
    }

    .start-panel .btn {
        min-width: 150px;
        padding: 12px 25px !important;
        margin: 6px 0;
    }
}

/* =================================
   RESULTS SCREEN
   ================================= */

.results-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-height: 90vh;
    overflow-y: auto;
}

.results-panel h1 {
    margin-top: 20px !important;
    margin-bottom: 10px !important;
}

.results-panel .btn {
    padding: 12px 30px !important;
    font-size: clamp(0.9rem, 3.5vw, 1.1rem) !important;
    min-height: 48px !important;
    max-height: 55px !important;
}

.results-panel .btn-promo {
    padding: 12px 25px !important;
    font-size: clamp(0.85rem, 3vw, 1rem) !important;
    min-height: 48px !important;
    max-height: 55px !important;
}

#performanceMessage {
    font-size: clamp(1rem, 3.5vw, 1.1rem) !important;
    color:  #FFFFFF !important;
    background: rgba(255, 215, 0, 0.1) !important;
    padding: 12px 16px !important;
    border-radius: 10px !important;
    margin: 15px 0 !important;
    border: 1px solid rgba(255, 215, 0, 0.3) !important;
    text-align: center !important;
    line-height: 1.4 !important;
    font-weight: 600 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
}

/* Desktop Results */
@media (min-width: 769px) {
    .results-panel {
        padding: 25px 30px !important;
        max-height: 85vh !important;
    }

    .results-panel h1 {
        margin-top: 10px !important;
        margin-bottom: 8px !important;
    }

    .results-panel p {
        margin-bottom: 15px !important;
    }

    .challenge-section {
        margin: 10px 0 !important;
        padding: 12px !important;
    }
}

/* Mobile Results */
@media (max-width: 768px) {
    .results-panel {
        padding: 30px 15px 35px 15px;
        max-width: 98%;
    }

    #resultsScreen {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 20px 5px !important;
    }

    .results-panel h1 {
        margin-top: 25px !important;
        font-size: 2rem !important;
    }

    .button-row {
        gap: 10px !important;
        margin: 20px 0 !important;
    }

    .image-row {
        gap: 20px !important;
        margin: 20px 0 !important;
    }

    .promo-section {
        margin: 25px 0 !important;
    }

    .results-panel > p {
        margin-bottom: 20px !important;
    }
}

/* =================================
   TYPOGRAPHY
   ================================= */

h1 {
    font-size: clamp(2rem, 8vw, 3rem);
    text-align: center;
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

h2 {
    font-size: clamp(1.5rem, 6vw, 2rem);
    text-align: center;
    margin-bottom: 15px;
    color: #FFD700;
}

p {
    font-size: clamp(1rem, 4vw, 1.2rem);
    text-align: center;
    margin-bottom: 20px;
    line-height: 1.5;
}

/* =================================
   LOGOS
   ================================= */

.brand-logo {
    width: 150px;
    height: auto;
    margin-bottom: 20px;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.game-logo {
    width: 80px;
    height: auto;
    margin-bottom: 10px;
    animation: pulse 2s ease-in-out infinite;
}

/* =================================
   BUTTONS
   ================================= */

.btn {
    background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%);
    color: #fff;
    padding: 12px 30px !important;
    border: none;
    border-radius: 30px;
    font-size: clamp(1rem, 4vw, 1.2rem);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(213, 54, 90, 0.4);
    position: relative;
    overflow: hidden;
    margin: 10px auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    min-width: 140px !important;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

.btn:before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

.btn:active:before {
    width: 300px;
    height: 300px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(213, 54, 90, 0.5);
}

.btn-secondary {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.btn-gold {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 12px 25px;
    font-size: 0.9rem;
}

.btn-small {
    padding: 10px 20px;
    font-size: 0.9rem;
}

.btn-promo {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    font-weight: bold;
    padding: 10px 25px;
    font-size: 0.95rem;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 215, 0, 0.3);
    box-shadow: 0 8px 32px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    animation: promoGlow 2s ease-in-out infinite;
}

/* =================================
   GAME CANVAS & SCREEN
   ================================= */

#gameCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#gameScreen {
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    position: relative;
}

/* Desktop Game Screen */
@media (min-width: 769px) {
    #gameScreen {
        position: relative !important;
        z-index: 10 !important;
    }
}

/* Mobile Game Screen */
@media (max-width: 768px) {
    #gameScreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 1000 !important;
        padding: 0 !important;
        margin: 0 !important;
    }
}

/* =================================
   GAME HUD
   ================================= */

.game-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 20px;
    z-index: 1100;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-direction: column;
    pointer-events: none;
}

.hud-top {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: auto;
}

/* Desktop HUD */
@media (min-width: 769px) {
    .game-hud {
        position: absolute !important;
        padding: 20px !important;
    }

    .score-display, .intimacy-meter {
        font-size: 1.2rem !important;
        padding: 10px 20px !important;
    }
}

/* Mobile HUD */
@media (max-width: 768px) {
    .game-hud {
        position: fixed !important;
        padding: 15px 10px !important;
    }
    
    .score-display, .intimacy-meter {
        font-size: 1rem !important;
        padding: 8px 15px !important;
    }
}

/* =================================
   SCORE & INTIMACY METER
   ================================= */

.score-display, .intimacy-meter {
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1.2rem;
    font-weight: 600;
}

.score-display {
    color: #FFD700;
}

.intimacy-meter {
    display: flex;
    gap: 5px;
    align-items: center;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* =================================
   HEARTS SYSTEM
   ================================= */

.heart {
    font-size: 1.5rem;
    transition: all 0.3s ease;
    position: relative;
    display: inline-block;
    cursor: default;
    color: #d5365a;
    text-shadow: 0 0 10px rgba(213, 54, 90, 0.5);
    margin: 0 2px;
}

.heart.active {
    color: #d5365a !important;
    text-shadow: 0 0 15px rgba(213, 54, 90, 0.8) !important;
    animation: heartBeat 1.5s ease-in-out infinite;
    transform-origin: center;
    opacity: 1 !important;
    filter: none !important;
}

.heart.active::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 30px;
    height: 30px;
    background: radial-gradient(circle, rgba(213, 54, 90, 0.4) 0%, transparent 70%);
    border-radius: 50%;
    z-index: -1;
    animation: heartGlow 1.5s ease-in-out infinite;
}

.heart.inactive {
    color: #444 !important;
    opacity: 0.3 !important;
    animation: none !important;
    text-shadow: none !important;
    filter: grayscale(100%) !important;
}

.heart.inactive::before {
    display: none !important;
}

.heart.breaking {
    animation: heartBreak 0.8s ease-out forwards !important;
    color: #d5365a !important;
}

.heart.gaining {
    animation: heartGain 0.6s ease-out !important;
    filter: drop-shadow(0 0 10px #d5365a) !important;
    color: #d5365a !important;
}

/* Game HUD Heart Meter Specific */
.game-hud .intimacy-meter .heart {
    font-size: 1.5rem !important;
    color: #d5365a !important;
    text-shadow: 0 0 10px rgba(213, 54, 90, 0.5) !important;
    margin: 0 2px !important;
    transition: all 0.3s ease !important;
    position: relative !important;
    display: inline-block !important;
}

.game-hud .intimacy-meter .heart.active {
    color: #d5365a !important;
    text-shadow: 0 0 15px rgba(213, 54, 90, 0.8) !important;
    animation: heartBeat 1.5s ease-in-out infinite !important;
    opacity: 1 !important;
    filter: none !important;
}

.game-hud .intimacy-meter .heart.inactive {
    color: #444 !important;
    opacity: 0.3 !important;
    filter: grayscale(100%) !important;
    animation: none !important;
    text-shadow: none !important;
}

/* =================================
   DISTRACTIONS
   ================================= */

.distraction {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 1000 !important;
    animation: appearPop 0.3s ease-out;
    pointer-events: auto;
}

.distraction-icon {
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 3px solid #FFD700;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    position: relative;
    overflow: visible;
}

.distraction-icon.booster {
    background: rgba(255, 215, 0, 0.3);
    border: 2px solid #FFD700;
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
    animation: glowPulse 1s ease-in-out infinite;
}

/* Mobile Distractions */
@media (max-width: 768px) {
    .distraction {
        z-index: 1000 !important;
    }
    
    .distraction-icon {
        width: 70px !important;
        height: 70px !important;
        font-size: 2rem !important;
    }
    
    .distraction.behind-message {
        z-index: 900 !important;
        opacity: 0.7 !important;
    }
}

/* =================================
   PRIORITY RING SYSTEM
   ================================= */

.priority-ring {
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    border-radius: 50%;
    border: 4px solid transparent;
    pointer-events: none;
    z-index: 5;
}

.priority-ring.critical {
    border: 6px solid #FF4444;
    animation: criticalRingIntense 0.4s ease-in-out infinite;
    box-shadow: 0 0 25px rgba(255, 68, 68, 1);
}

.priority-ring.warning {
    border: 4px solid #FFA500;
    animation: warningRingMedium 0.8s ease-in-out infinite;
    box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
}

.priority-ring.safe {
    border: 3px solid #32CD32;
    animation: safeRingGentle 1.5s ease-in-out infinite;
    box-shadow: 0 0 15px rgba(50, 205, 50, 0.6);
}

/* =================================
   TROPHY DISTRACTION
   ================================= */

.distraction-icon.trophy {
    background: linear-gradient(45deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%) !important;
    border: 3px solid #FFFF00 !important;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
    animation: trophyPulse 1.5s ease-in-out infinite !important;
    position: relative;
}

.trophy-bonus {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    background: #FFD700;
    color: #000;
    font-size: 0.7rem;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid #FFA500;
    white-space: nowrap;
    z-index: 15;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* =================================
   STICKY NOTES
   ================================= */

.sticky-note {
    width: 100px;
    height: 80px;
    background: #ffeb3b;
    position: relative;
    transform: rotate(-5deg);
    box-shadow: 2px 2px 10px rgba(0,0,0,0.3);
    padding: 10px;
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 14px;
    color: #333;
    cursor: pointer;
}

.sticky-note div {
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 12px !important;
    line-height: 1.2 !important;
}

.sticky-note:before {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 20px;
    background: rgba(0,0,0,0.1);
    clip-path: polygon(0 0, 100% 0, 50% 100%);
}

/* Mobile Sticky Notes */
@media (max-width: 768px) {
    .sticky-note {
        font-family: 'Comic Sans MS', 'Chalkduster', 'Marker Felt', cursive !important;
        font-size: 12px !important;
    }
    
    .sticky-note div {
        font-family: 'Comic Sans MS', 'Chalkduster', 'Marker Felt', cursive !important;
        font-size: 10px !important;
    }
}

/* =================================
   ACHIEVEMENT POPUPS
   ================================= */

.achievement-popup {
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 15px 20px;
    border-radius: 15px;
    text-align: center;
    z-index: 2000;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
    max-width: 70vw;
    font-size: 0.9rem;
    display: block;
}

.mobile-achievement-notification {
    position: fixed;
    top: 80px !important;
    left: 20px;
    right: 20px;
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 8px 12px;
    border-radius: 15px;
    font-size: 0.75rem;
    font-weight: bold;
    z-index: 2500 !important;
    animation: slideInFromTop 0.5s ease-out;
    max-width: none;
    text-align: center;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    display: none;
    border: 2px solid #fff;
}

.combo-message,
[class*="combo"] {
    z-index: 3500 !important;
    position: fixed !important;
}

.achievement-popup.show {
    animation: achievementPop 0.6s ease-out forwards;
}

.achievement-icon {
    font-size: 2rem !important;
    margin-bottom: 8px !important;
}

.achievement-title {
    font-size: 1.1rem !important;
    margin-bottom: 4px !important;
}

.achievement-desc {
    font-size: 0.8rem !important;
}

/* Round Complete Popup */
.round-complete-popup {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) scale(0) !important;
    background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%) !important;
    color: #fff !important;
    padding: 15px 25px !important;
    border-radius: 15px !important;
    text-align: center !important;
    z-index: 2000 !important;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5) !important;
    max-width: 250px !important;
    font-size: 0.9rem !important;
    border: 2px solid #FFD700 !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
}

.round-complete-popup.show {
    animation: achievementPop 0.6s ease-out forwards !important;
}

/* Mobile Achievement Rules */
@media (max-width: 768px) {
    .achievement-popup {
        display: none !important;
        z-index: 2000 !important;
    }
    
    .mobile-achievement-notification {
        display: block !important;
        z-index: 2500 !important;
    }
    
    .round-complete-popup {
        display: none !important;
    }
    
    .mobile-round-notification {
        position: fixed;
        top: 20px;
        left: 20px;
        background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%);
        color: #fff;
        padding: 8px 12px;
        border-radius: 15px;
        font-size: 0.75rem;
        font-weight: bold;
        z-index: 2500 !important;
        animation: slideInLeft 0.5s ease-out;
        max-width: 180px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(213, 54, 90, 0.4);
        border: 1px solid #FFD700;
    }
}

@media (min-width: 769px) {
    .mobile-achievement-notification {
        display: none !important;
    }
    
    .mobile-round-notification {
        display: none !important;
    }
    
    .achievement-popup {
        display: block !important;
    }
}

/* =================================
   ACHIEVEMENT BOARD
   ================================= */

.achievement-board {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    padding: 10px;
    z-index: 50;
    max-width: 200px;
    font-size: 0.7rem;
    transition: opacity 0.3s ease;
    opacity: 0.8;
    margin-top: 10px;
    position: absolute;
    top: 80px;
    left: 20px;
}

.achievement-board:hover {
    opacity: 1;
}

.achievement-board h4 {
    color: #FFD700;
    font-size: 0.8rem;
    margin-bottom: 5px;
    text-align: center;
}

.achievement-board ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.achievement-board li {
    color: #fff;
    margin: 3px 0;
    font-size: 0.65rem;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.5s ease;
    opacity: 0.4;
    transform: scale(1);
    position: relative;
    overflow: hidden;
}

.achievement-board li.unlocked {
    opacity: 1 !important;
    color: #FFD700 !important;
    font-weight: bold;
    text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    animation: achievementPulse 3s ease-in-out infinite;
}

.achievement-board li.just-unlocked {
    animation: achievementUnlock 1.5s ease-out forwards !important;
}

.achievement-board .icon {
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.achievement-board li.unlocked .icon {
    filter: drop-shadow(0 0 5px #FFD700);
}

/* Desktop Achievement Board */
@media (min-width: 769px) {
    .achievement-board {
        position: absolute !important;
        top: 80px !important;
        left: 20px !important;
        max-width: 200px !important;
        font-size: 0.7rem !important;
        opacity: 0.8 !important;
    }
}

/* Mobile Achievement Board */
@media (max-width: 768px) {
    .achievement-board {
        font-size: 0.6rem !important;
        max-width: 160px !important;
        padding: 8px !important;
        opacity: 0.9 !important;
        position: absolute !important;
        top: 80px !important;
        left: 10px !important;
    }
    
    .achievement-board h4 {
        font-size: 0.7rem !important;
        margin-bottom: 4px !important;
    }
    
    .achievement-board li {
        font-size: 0.55rem !important;
        margin: 2px 0 !important;
    }
    
    .achievement-board .icon {
        font-size: 0.8rem !important;
    }
    
    .achievement-board.gameplay-hidden {
        display: none !important;
    }
}

/* =================================
   LOADING SCREEN
   ================================= */

.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.loading-bar {
    width: 80%;
    max-width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 20px;
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, #d5365a 0%, #FFD700 100%);
    border-radius: 2px;
    transition: width 0.3s ease;
}

.loading-screen .glass {
    padding: 40px 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    margin: 0 auto;
}

@media (max-width: 768px) {
    .loading-screen .glass {
        padding: 30px 25px;
        max-width: 85vw;
        width: 90%;
    }
}

/* =================================
   LOADING TIPS
   ================================= */

.loading-tip {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    padding: 8px 20px;
    max-width: 80vw;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    z-index: 1;
}

.loading-tip.loading-tip-custom {
    padding: 8px 15px !important;
    line-height: 1.3 !important;
    background: rgba(0, 0, 0, 0.4) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 10px !important;
    position: absolute !important;
    bottom: 40px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    text-align: center !important;
    max-width: 85vw !important;
    width: auto !important;
    white-space: nowrap !important;
    z-index: 1 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-height: 35px !important;
    font-size: 0.85rem !important;
}

.loading-tip.loading-tip-custom p {
    margin: 0 !important;
    padding: 0 !important;
    text-align: center !important;
    line-height: 1.2 !important;
}

@media (max-width: 768px) {
    .loading-tip {
        padding: 6px 15px;
        max-width: 90vw;
        font-size: 0.9rem;
        bottom: 30px;
    }
    
    .loading-tip.loading-tip-custom {
        padding: 6px 12px !important;
        max-width: 90vw !important;
        font-size: 0.75rem !important;
        bottom: 30px !important;
        min-height: 30px !important;
        white-space: normal !important;
    }
}

/* =================================
   AUDIO TOGGLE
   ================================= */

.audio-toggle {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1200;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    touch-action: manipulation !important; 
    -webkit-touch-callout: none !important; 
    -webkit-user-select: none !important; 
    user-select: none !important;
}

.audio-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.audio-toggle.muted {
    opacity: 0.6;
    background: rgba(255, 0, 0, 0.2) !important;
}

/* Mobile Audio Toggle */
@media (max-width: 768px) {
    .audio-toggle {
        position: fixed !important;
        bottom: 15px !important;
        left: 15px !important;
        width: 45px !important;
        height: 45px !important;
        z-index: 2000 !important;
        background: rgba(0, 0, 0, 0.7) !important;
        border: 2px solid rgba(255, 255, 255, 0.8) !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5) !important;
        pointer-events: auto !important; 
        z-index: 3000 !important;
    }

    .audio-toggle span {
        font-size: 1.2rem !important;
    }
}

/* =================================
   COUPLE SILHOUETTE
   ================================= */

.couple-silhouette {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) !important; 
    width: 300px;
    height: 300px;
    z-index: 2;
    opacity: 0.8;
    filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    transition: opacity 0.4s ease-in-out;
}

.couple-silhouette img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transition: all 0.3s ease;
}

/* Silhouette Scaling States */
.silhouette-intro-scale {
    transform: translate(-50%, -50%) scale(0.8) !important;
    transition: all 0.3s ease !important;
}

.silhouette-grow-scale {
    transform: translate(-50%, -50%) scale(1.05) !important;
    transition: all 0.8s ease !important;
}

.silhouette-normal-scale {
    transform: translate(-50%, -50%) scale(1) !important;
    transition: all 0.3s ease !important;
}

/* Mobile Silhouette */
@media (max-width: 768px) {
    .couple-silhouette {
        position: absolute !important;
        top: 50% !important;
        left: 50% !important;
        width: 280px !important;
        height: 280px !important;
        transform-origin: center center !important;
        will-change: transform !important;
    }
    
    /* Mobile-safe animation overrides */
    .couple-silhouette.silhouette-gentle-sway {
        animation: mobileGentleSway 6s ease-in-out infinite !important;
    }
    
    .couple-silhouette.silhouette-intimate-pulse,
    .couple-silhouette.silhouette-passionate-breathe,
    .couple-silhouette.silhouette-tender-rock,
    .couple-silhouette.silhouette-loving-embrace,
    .couple-silhouette.silhouette-romantic-glow,
    .couple-silhouette.silhouette-intense-connection,
    .couple-silhouette.silhouette-ultimate-unity {
        animation: mobileIntimateLevel 4s ease-in-out infinite !important;
    }
    
    .couple-silhouette.silhouette-intro-scale {
        transform: translate(-50%, -50%) scale(0.8) !important;
    }
    
    .couple-silhouette.silhouette-grow-scale {
        transform: translate(-50%, -50%) scale(1.05) !important;
    }
    
    .couple-silhouette.silhouette-normal-scale {
        transform: translate(-50%, -50%) scale(1) !important;
    }
}

/* Silhouette Effects */
.couple-silhouette.critical-miss {
    filter: drop-shadow(0 0 30px rgba(255, 0, 0, 1)) brightness(0.7) !important;
    animation: shake-centered 0.8s ease-out !important;
}

.couple-silhouette.warning-miss {
    filter: drop-shadow(0 0 25px rgba(255, 165, 0, 0.8)) brightness(0.85) !important;
    animation: shake-centered 0.6s ease-out !important;
}

.couple-silhouette.safe-miss {
    filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.4)) !important;
    animation: shake-centered 0.4s ease-out !important;
}

/* =================================
   SILHOUETTE REACTION ANIMATIONS 
   ================================= */

/* Desktop Reactions */
@media (min-width: 769px) {
    .couple-silhouette.reaction-safe {
        animation: desktopGentleSeparation 0.8s ease-out !important;
    }

    .couple-silhouette.reaction-warning {
        animation: desktopStrongSeparation 1.0s ease-out !important;
    }

    .couple-silhouette.reaction-critical {
        animation: desktopDramaticSeparation 1.2s ease-out !important;
    }
}

/* Mobile Reactions - Performance Optimized */
@media (max-width: 768px) {
    .couple-silhouette.reaction-safe {
        animation: mobileGentleSeparation 0.6s ease-out !important;
    }

    .couple-silhouette.reaction-warning {
        animation: mobileStrongSeparation 0.8s ease-out !important;
    }

    .couple-silhouette.reaction-critical {
        animation: mobileDramaticSeparation 1.0s ease-out !important;
    }
}

/* Desktop Keyframes - Full Effect */
@keyframes desktopGentleSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    30% { transform: translate(-50%, -50%) scale(0.95) skewX(2deg); }
    70% { transform: translate(-50%, -50%) scale(1.02) skewX(-1deg); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes desktopStrongSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    20% { transform: translate(-50%, -50%) scale(0.9) skewX(-3deg); }
    40% { transform: translate(-50%, -50%) scale(1.05) skewX(3deg); }
    70% { transform: translate(-50%, -50%) scale(0.98) skewX(-1deg); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes desktopDramaticSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    15% { transform: translate(-50%, -50%) scale(0.85) skewX(-5deg) translateX(-10px); }
    35% { transform: translate(-50%, -50%) scale(1.1) skewX(5deg) translateX(10px); }
    60% { transform: translate(-50%, -50%) scale(0.95) skewX(-2deg) translateX(-5px); }
    80% { transform: translate(-50%, -50%) scale(1.02) skewX(1deg); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

/* Mobile Keyframes - Simplified for Performance */
@keyframes mobileGentleSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(0.97); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes mobileStrongSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    25% { transform: translate(-50%, -50%) scale(0.94); }
    75% { transform: translate(-50%, -50%) scale(1.03); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes mobileDramaticSeparation {
    0% { transform: translate(-50%, -50%) scale(1); }
    20% { transform: translate(-50%, -50%) scale(0.9); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
    80% { transform: translate(-50%, -50%) scale(0.98); }
    100% { transform: translate(-50%, -50%) scale(1); }
}


/* =================================
   OTHER UI ELEMENTS
   ================================= */

.hint-popup {
    position: fixed !important;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: #fff;
    padding: 15px 20px;
    border-radius: 15px;
    font-size: 0.85rem;
    z-index: 2000 !important;
    animation: fadeInBounce 0.5s ease-out;
    max-width: 200px;
    text-align: center;
    border: 2px solid #FFD700;
}

.couple-results {
    width: 100%;
    margin-top: 15px;
}

.performance-comparison {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin: 15px 0;
}

.player-stats {
    text-align: center;
}

.player-stats h4 {
    color: #FFD700;
    margin-bottom: 5px;
}

.vs-indicator {
    font-size: 1.2rem;
    color: #FFD700;
    font-weight: bold;
}

.combined-metrics {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 10px;
    margin: 10px 0;
}

.metric {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    font-size: 0.9rem;
}

.metric .label {
    color: #ccc;
}

.metric .value {
    color: #FFD700;
    font-weight: bold;
}

.product-display {
    width: 150px;
    height: auto;
    margin: 10px;
    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.3));
}

.qr-code {
    width: 150px;
    height: 150px;
    background: #fff;
    padding: 1px;
    border-radius: 8px;
    margin: 10px;
}

.image-row {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin: 25px 0;
}

.button-row {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin: 25px 0;
}

.share-buttons {
    display: flex;
    gap: 15px;
    margin-top: 30px;
    flex-wrap: wrap;
    justify-content: center;
}

.share-btn {
    background: rgba(255, 255, 255, 0.2);
    padding: 10px 20px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.share-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}

.challenge-section {
    background: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 15px;
    margin: 10px 0;
    width: 100%;
}

.challenge-code {
    font-size: 1.5rem;
    font-weight: bold;
    color: #FFD700;
    letter-spacing: 2px;
    margin: 10px 0;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.show {
    display: flex;
}

.modal-content {
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 100%);
    padding: 30px;
    border-radius: 20px;
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    text-align: center;
}

.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #FFD700;
    border-radius: 50%;
    pointer-events: none;
    animation: particleFly 1s ease-out forwards;
}

/* Urgency Particles */
.urgency-particle {
    transform-origin: center;
    will-change: transform, opacity;
}

.urgency-particle.critical {
    animation-duration: 0.8s !important;
    box-shadow: 0 0 8px rgba(255, 68, 68, 0.8) !important;
}

.urgency-particle.warning {
    animation-duration: 0.9s !important;
    box-shadow: 0 0 6px rgba(255, 165, 0, 0.7) !important;
}

.urgency-particle.safe {
    animation-duration: 1.0s !important;
    box-shadow: 0 0 4px rgba(50, 205, 50, 0.6) !important;
}

/* Mobile Urgency Particles */
@media (max-width: 768px) {
    .urgency-particle {
        width: 3px !important;
        height: 3px !important;
    }
}

/* Hidden problematic elements */
.round-intro {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
}

/* =================================
   ANIMATIONS
   ================================= */

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes promoGlow {
    0%, 100% { 
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2); 
    }
    50% { 
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.3); 
    }
}

@keyframes appearPop {
    0% { transform: scale(0); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes achievementPop {
    0% { transform: translate(-50%, -50%) scale(0); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes slideInFromTop {
    0% {
        transform: translateY(-100%);
        opacity: 0;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes slideInLeft {
    0% {
        transform: translateX(-100%);
        opacity: 0;
    }
    100% {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutLeft {
    0% {
        transform: translateX(0);
        opacity: 1;
    }
    100% {
        transform: translateX(-100%);
        opacity: 0;
    }
}

@keyframes topMessageSlideIn {
    0% { opacity: 0; transform: translate(-50%, -30px) scale(0.8); }
    100% { opacity: 1; transform: translate(-50%, 0) scale(1); }
}

@keyframes topMessageSlideOut {
    0% { opacity: 1; transform: translate(-50%, 0) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -30px) scale(0.9); }
}

@keyframes particleFly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

@keyframes urgencyParticleFly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    70% {
        transform: translate(calc(var(--tx) * 0.8), calc(var(--ty) * 0.8)) scale(1.2);
        opacity: 0.8;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

@keyframes fadeInBounce {
    0% { opacity: 0; transform: translateY(-20px); }
    100% { opacity: 1; transform: translateY(0); }
}

@keyframes heartBeat {
    0%, 100% { 
        transform: scale(1);
    }
    14% { 
        transform: scale(1.1);
    }
    28% { 
        transform: scale(1);
    }
    42% { 
        transform: scale(1.1);
    }
    70% { 
        transform: scale(1);
    }
}

@keyframes heartBreak {
    0% { 
        transform: scale(1); 
        opacity: 1; 
        filter: hue-rotate(0deg);
        color: #d5365a;
    }
    25% { 
        transform: scale(1.2) rotate(5deg); 
        filter: hue-rotate(90deg);
        color: #ff6b6b;
    }
    50% { 
        transform: scale(1.3) rotate(-5deg); 
        filter: hue-rotate(180deg);
        color: #666;
    }
    75% { 
        transform: scale(0.9) rotate(3deg); 
        filter: hue-rotate(270deg);
        color: #333;
    }
    100% { 
        transform: scale(0.8); 
        opacity: 0.3; 
        filter: grayscale(100%);
        color: #444;
    }
}

@keyframes heartGain {
    0% { 
        transform: scale(0.8); 
        opacity: 0.5;
        filter: brightness(0.5);
    }
    25% { 
        transform: scale(1.2); 
        opacity: 0.8;
        filter: brightness(1.2);
    }
    50% { 
        transform: scale(1.4); 
        opacity: 1;
        filter: brightness(1.5) drop-shadow(0 0 15px #d5365a);
    }
    75% { 
        transform: scale(1.1); 
        opacity: 1;
        filter: brightness(1.2);
    }
    100% { 
        transform: scale(1); 
        opacity: 1;
        filter: brightness(1);
    }
}

@keyframes heartGlow {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.6;
        background: radial-gradient(circle, rgba(213, 54, 90, 0.4) 0%, transparent 70%);
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0.9;
        background: radial-gradient(circle, rgba(213, 54, 90, 0.8) 0%, transparent 70%);
    }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10% { transform: translateX(-2px) translateY(-1px); }
    20% { transform: translateX(2px) translateY(1px); }
    30% { transform: translateX(-3px) translateY(-2px); }
    40% { transform: translateX(3px) translateY(2px); }
    50% { transform: translateX(-2px) translateY(-1px); }
    60% { transform: translateX(2px) translateY(1px); }
    70% { transform: translateX(-1px) translateY(-1px); }
    80% { transform: translateX(1px) translateY(1px); }
    90% { transform: translateX(-1px) translateY(0); }
}

/* Mobile Shake Animation */
@media (max-width: 768px) {
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10% { transform: translateX(-1px) translateY(-0.5px); }
        20% { transform: translateX(1px) translateY(0.5px); }
        30% { transform: translateX(-1.5px) translateY(-1px); }
        40% { transform: translateX(1.5px) translateY(1px); }
        50% { transform: translateX(-1px) translateY(-0.5px); }
        60% { transform: translateX(1px) translateY(0.5px); }
        70% { transform: translateX(-0.5px) translateY(-0.5px); }
        80% { transform: translateX(0.5px) translateY(0.5px); }
        90% { transform: translateX(-0.5px) translateY(0); }
    }
}

/* Shake animation that preserves silhouette centering */
@keyframes shake-centered {
    0%, 100% { 
        transform: translate(-50%, -50%) translateX(0px) translateY(0px); 
    }
    10% { 
        transform: translate(-50%, -50%) translateX(-2px) translateY(-1px); 
    }
    20% { 
        transform: translate(-50%, -50%) translateX(2px) translateY(1px); 
    }
    30% { 
        transform: translate(-50%, -50%) translateX(-3px) translateY(-2px); 
    }
    40% { 
        transform: translate(-50%, -50%) translateX(3px) translateY(2px); 
    }
    50% { 
        transform: translate(-50%, -50%) translateX(-2px) translateY(-1px); 
    }
    60% { 
        transform: translate(-50%, -50%) translateX(2px) translateY(1px); 
    }
    70% { 
        transform: translate(-50%, -50%) translateX(-1px) translateY(-1px); 
    }
    80% { 
        transform: translate(-50%, -50%) translateX(1px) translateY(1px); 
    }
    90% { 
        transform: translate(-50%, -50%) translateX(-1px) translateY(0px); 
    }
}

/* Mobile version that preserves centering */
@media (max-width: 768px) {
    @keyframes shake-centered {
        0%, 100% { 
            transform: translate(-50%, -50%) translateX(0px) translateY(0px); 
        }
        10% { 
            transform: translate(-50%, -50%) translateX(-1px) translateY(-0.5px); 
        }
        20% { 
            transform: translate(-50%, -50%) translateX(1px) translateY(0.5px); 
        }
        30% { 
            transform: translate(-50%, -50%) translateX(-1.5px) translateY(-1px); 
        }
        40% { 
            transform: translate(-50%, -50%) translateX(1.5px) translateY(1px); 
        }
        50% { 
            transform: translate(-50%, -50%) translateX(-1px) translateY(-0.5px); 
        }
        60% { 
            transform: translate(-50%, -50%) translateX(1px) translateY(0.5px); 
        }
        70% { 
            transform: translate(-50%, -50%) translateX(-0.5px) translateY(-0.5px); 
        }
        80% { 
            transform: translate(-50%, -50%) translateX(0.5px) translateY(0.5px); 
        }
        90% { 
            transform: translate(-50%, -50%) translateX(-0.5px) translateY(0px); 
        }
    }
}

@keyframes achievementUnlock {
    0% { 
        transform: scale(0.9); 
        opacity: 0.4; 
        color: #fff;
        background: transparent;
    }
    25% { 
        transform: scale(1.1); 
        opacity: 0.8; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.1);
        text-shadow: 0 0 10px #FFD700;
    }
    50% { 
        transform: scale(1.15); 
        opacity: 1; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.2);
        text-shadow: 0 0 15px #FFD700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    75% { 
        transform: scale(1.05); 
        opacity: 1; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.1);
        text-shadow: 0 0 12px #FFD700;
    }
    100% { 
        transform: scale(1); 
        opacity: 1; 
        color: #FFD700;
        background: transparent;
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    }
}

@keyframes achievementPulse {
    0%, 100% { 
        transform: scale(1); 
        text-shadow: 0 0 5px #FFD700;
    }
    50% { 
        transform: scale(1.03); 
        text-shadow: 0 0 12px #FFD700;
    }
}

@keyframes criticalRingIntense {
    0%, 100% { 
        transform: scale(1);
        border-width: 6px;
        opacity: 1;
        box-shadow: 0 0 25px rgba(255, 68, 68, 1);
    }
    25% { 
        transform: scale(1.15);
        border-width: 8px;
        opacity: 0.9;
        box-shadow: 0 0 35px rgba(255, 68, 68, 1);
    }
    50% { 
        transform: scale(1.25);
        border-width: 10px;
        opacity: 0.8;
        box-shadow: 0 0 45px rgba(255, 68, 68, 1);
    }
    75% { 
        transform: scale(1.15);
        border-width: 8px;
        opacity: 0.9;
        box-shadow: 0 0 35px rgba(255, 68, 68, 1);
    }
}

@keyframes warningRingMedium {
    0%, 100% { 
        transform: scale(1);
        border-width: 4px;
        opacity: 0.9;
        box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
    }
    33% { 
        transform: scale(1.08);
        border-width: 5px;
        opacity: 1;
        box-shadow: 0 0 25px rgba(255, 165, 0, 1);
    }
    66% { 
        transform: scale(1.12);
        border-width: 6px;
        opacity: 0.95;
        box-shadow: 0 0 30px rgba(255, 165, 0, 0.9);
    }
}

@keyframes safeRingGentle {
    0%, 100% { 
        transform: scale(1);
        border-width: 3px;
        opacity: 0.7;
        box-shadow: 0 0 15px rgba(50, 205, 50, 0.6);
    }
    50% { 
        transform: scale(1.04);
        border-width: 4px;
        opacity: 0.9;
        box-shadow: 0 0 20px rgba(50, 205, 50, 0.8);
    }
}

@keyframes trophyPulse {
    0%, 100% { 
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        transform: scale(1);
    }
    25% { 
        box-shadow: 0 0 35px rgba(255, 215, 0, 0.9);
        transform: scale(1.02);
    }
    50% { 
        box-shadow: 0 0 45px rgba(255, 215, 0, 1);
        transform: scale(1.05);
    }
    75% { 
        box-shadow: 0 0 40px rgba(255, 215, 0, 0.95);
        transform: scale(1.03);
    }
}

@keyframes trophySparkle {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
    }
    20% {
        transform: scale(1.2) rotate(180deg);
        opacity: 1;
    }
    80% {
        transform: scale(1) rotate(360deg);
        opacity: 1;
    }
    100% {
        transform: scale(0) rotate(540deg);
        opacity: 0;
    }
}

@keyframes boosterRingExpand {
    0% {
        transform: scale(0.5);
        opacity: 1;
        border-width: 3px;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.8;
        border-width: 2px;
    }
    100% {
        transform: scale(2);
        opacity: 0;
        border-width: 1px;
    }
}

@keyframes screenFlash {
    0% {
        opacity: var(--flash-opacity, 0.3);
    }
    50% {
        opacity: calc(var(--flash-opacity, 0.3) * 0.6);
    }
    100% {
        opacity: 0;
    }
}

@keyframes sparkleFloat {
    0% {
        transform: translateY(0) scale(0);
        opacity: 1;
    }
    50% {
        transform: translateY(-15px) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-25px) scale(0);
        opacity: 0;
    }
}

@keyframes comboFloat {
    0% {
        transform: scale(0.5) translateY(0);
        opacity: 1;
    }
    50% {
        transform: scale(1.2) translateY(-20px);
        opacity: 1;
    }
    100% {
        transform: scale(1) translateY(-40px);
        opacity: 0;
    }
}

/* =================================
   SILHOUETTE ANIMATIONS
   ================================= */

@keyframes gentleSway {
    0%, 100% { 
        transform: translate(-50%, -50%) rotate(-1deg) scale(1);
    }
    50% { 
        transform: translate(-50%, -50%) rotate(1deg) scale(1.02);
    }
}

@keyframes intimatePulse {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.05);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.8));
    }
}

@keyframes passionateBreathe {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.8;
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.03);
        opacity: 0.9;
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.06);
        opacity: 1;
    }
}

@keyframes tenderRock {
    0%, 100% { 
        transform: translate(-50%, -50%) rotate(-0.5deg);
    }
    25% { 
        transform: translate(-50%, -50%) rotate(0.5deg) scale(1.01);
    }
    50% { 
        transform: translate(-50%, -50%) rotate(-0.3deg);
    }
    75% { 
        transform: translate(-50%, -50%) rotate(0.3deg) scale(1.01);
    }
}

@keyframes lovingEmbrace {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) hue-rotate(0deg);
    }
    33% { 
        transform: translate(-50%, -50%) scale(1.02);
        filter: drop-shadow(0 0 25px rgba(213, 54, 90, 0.6)) hue-rotate(10deg);
    }
    66% { 
        transform: translate(-50%, -50%) scale(1.04);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.7)) hue-rotate(-10deg);
    }
}

@keyframes romanticGlow {
    0%, 100% { 
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) brightness(1);
    }
    50% { 
        filter: drop-shadow(0 0 40px rgba(255, 215, 0, 0.6)) brightness(1.2);
    }
}

@keyframes intenseConnection {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.03);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.7));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.06);
        filter: drop-shadow(0 0 40px rgba(213, 54, 90, 0.9));
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.03);
        filter: drop-shadow(0 0 35px rgba(213, 54, 90, 0.8));
    }
}

@keyframes ultimateUnity {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.8)) 
                drop-shadow(0 0 60px rgba(255, 215, 0, 0.4));
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.02) rotate(0.5deg);
        filter: drop-shadow(0 0 40px rgba(213, 54, 90, 0.9)) 
                drop-shadow(0 0 80px rgba(255, 215, 0, 0.6));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.05) rotate(0deg);
        filter: drop-shadow(0 0 50px rgba(213, 54, 90, 1)) 
                drop-shadow(0 0 100px rgba(255, 215, 0, 0.8));
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.02) rotate(-0.5deg);
        filter: drop-shadow(0 0 45px rgba(213, 54, 90, 0.95)) 
                drop-shadow(0 0 90px rgba(255, 215, 0, 0.7));
    }
}

/* Mobile-Safe Silhouette Animations */
@keyframes mobileGentleSway {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.01) rotate(0deg);
    }
}

@keyframes mobileIntimateLevel {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
        opacity: 0.8;
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.02);
        filter: drop-shadow(0 0 25px rgba(213, 54, 90, 0.7));
        opacity: 0.9;
    }
}

/* Silhouette Animation Classes */
.silhouette-gentle-sway {
    animation: gentleSway 6s ease-in-out infinite;
}

.silhouette-intimate-pulse {
    animation: intimatePulse 4s ease-in-out infinite;
}

.silhouette-passionate-breathe {
    animation: passionateBreathe 3s ease-in-out infinite;
}

.silhouette-tender-rock {
    animation: tenderRock 8s ease-in-out infinite;
}

.silhouette-loving-embrace {
    animation: lovingEmbrace 5s ease-in-out infinite;
}

.silhouette-romantic-glow {
    animation: romanticGlow 7s ease-in-out infinite;
}

.silhouette-intense-connection {
    animation: intenseConnection 4s ease-in-out infinite;
}

.silhouette-ultimate-unity {
    animation: ultimateUnity 6s ease-in-out infinite;


/* =================================
   ACHIEVEMENT BOARD DESKTOP-ONLY
   ================================= */

/* Hide completely on mobile */
@media (max-width: 768px) {
    .achievement-board,
    #achievementBoard {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
    }
}

/* Show only on desktop */
@media (min-width: 769px) {
    .achievement-board,
    #achievementBoard {
        display: block !important;
        visibility: visible !important;
        opacity: 0.8 !important;
        position: absolute !important;
        top: 80px !important;
        left: 20px !important;
        width: 200px !important;
        min-width: 200px !important;
        height: auto !important;
        min-height: 120px !important;
        z-index: 1000 !important;
    }
    
    /* Achievement glow animation */
    .achievement-board li.unlocked {
        opacity: 1 !important;
        color: #FFD700 !important;
        font-weight: bold !important;
        text-shadow: 0 0 12px rgba(255, 215, 0, 0.8) !important;
        animation: achievementPulse 3s ease-in-out infinite !important;
        background: rgba(255, 215, 0, 0.1) !important;
        border-radius: 4px !important;
        padding: 2px 4px !important;
    }
}

/* Pulse animation for achievements */
@keyframes achievementPulse {
    0%, 100% { 
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        transform: scale(1);
    }
    50% { 
        text-shadow: 0 0 16px rgba(255, 215, 0, 1);
        transform: scale(1.02);
    }
}    
</style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
       <div class="glass" style="padding: 40px; max-width: 500px; width: 90%; text-align: center;">
        <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
        <h2>Loading Endless Embrace...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    <div class="loading-tip loading-tip-custom" id="loadingTip">
        <p>💡 Pro tip: Lasting longer starts with the right preparation... 😉</p>
    </div>
   </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <div class="glass start-panel">
            <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
            <h1>Endless Embrace</h1>
            <img src="https://assets.codepen.io/t-24779/bg-seated-embrace-pose.png" alt="Endless Embrace" class="game-logo">
            <p style="color: #FFD700; font-size: 1.2rem; margin: 20px 0;">Kill the mood killers. Last longer!</p>
            <button class="btn" onclick="showScreen('gameScreen')">Play Game</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        <div class="couple-silhouette" id="coupleSilhouette" style="display: none;">
            <img id="silhouetteImage" src="" alt="Couple">
        </div>
        <div class="game-hud">
            <div class="hud-top">
                <div class="score-display">
                    Score: <span id="score">0</span>
                </div>
                <div class="intimacy-meter" id="intimacyMeter">
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                </div>
            </div>
            <!-- Achievement Board positioned below score -->
            <div class="achievement-board" id="achievementBoard" style="display: none;">
                <h4>🏆 Achievements</h4>
                <ul>
                    <li><span class="icon">🎯</span> Quick Draw: &lt;0.8s</li>
                    <li><span class="icon">🔥</span> Perfect Round</li>
                    <li><span class="icon">💪</span> Multi-Position: 3 in 2s</li>
                    <li><span class="icon">🌡️</span> Heat Wave: 7+ streak</li>
                    <li><span class="icon">⚡</span> 3X Warrior: 150+ pts</li>
                    <li><span class="icon">⏰</span> Speed Demon: R1 &lt;30s</li>
                </ul>
            </div>
        </div>
        <div class="audio-toggle" id="audioToggle" onclick="toggleAudio()">
            <span id="audioIcon">🔊</span>
        </div>
    </div>

    <!-- Results Screen -->
    <div id="resultsScreen" class="screen">
        <div class="glass results-panel">
            <h1 style="color: #d5365a; margin-bottom: 10px; font-size: 2.5rem;">GAME OVER</h1>
            <p style="font-size: 2rem; color: #FFD700; margin-bottom: 20px;">
                Score: <span id="finalScore">0</span>
            </p>
            <p id="performanceMessage" style="margin-bottom: 20px;"></p>

        <div class="promo-section" style="margin: 20px 0;">
            <button class="btn btn-promo" onclick="window.open('https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756','_blank')">
             🎉 20% OFF
            </button>
           </div>
            
            <div class="image-row">
                <div class="qr-code" id="qrCode" style="background: #fff; padding: 10px;">
                    <!-- QR Code will be generated here -->
                </div>
                <img src="https://assets.codepen.io/t-24779/KamaSutra-longlast-product.png" alt="KamaSutra LongLast" class="product-display" style="height: 150px; width: auto;">
            </div>
            
            <div class="button-row">
                <button class="btn btn-gold btn-small" onclick="saveQRCode()">Save Code</button>
                <a href="https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756" target="_blank" class="btn btn-gold btn-small" style="text-decoration: none;">
                    Passion 3X  
                </a>
            </div>
            
            <p style="font-size: 1rem; margin: 15px 0;">
                For longer lasting moments, choose KamaSutra LongLast.<br>
                <span style="color: #FFD700; font-weight: bold;">3X Longer Lasting!</span>
            </p>
            
            <!-- Challenge Section -->
            <div class="challenge-section">
                <p style="font-size: 0.9rem; margin-bottom: 10px;">🔥 Couple Challenge Mode 🔥</p>
                <div class="challenge-code" id="challengeCode">------</div>
                <div id="coupleStatus" style="margin: 10px 0; display: none;">
                    <p style="font-size: 0.8rem;" id="challengeStatusText"></p>
                </div>
                <button class="btn btn-secondary btn-small" onclick="generateChallengeCode()">Generate Challenge Code</button>
                <button class="btn btn-secondary btn-small" onclick="showEnterCode()" style="margin-top: 5px;">Enter Partner's Code</button>
            </div>
            
            <!-- Couple Results Display -->
            <div class="couple-results" id="coupleResults" style="display: none;">
                <h3 style="color: #FFD700;">💕 Couple Challenge Results</h3>
                <div class="performance-comparison">
                    <div class="player-stats">
                        <h4>You</h4>
                        <div class="score" id="yourScore">0</div>
                    </div>
                    <div class="vs-indicator">VS</div>
                    <div class="partner-stats">
                        <h4>Partner</h4>
                        <div class="score" id="partnerScore">0</div>
                    </div>
                </div>
                <div class="combined-metrics">
                    <h4>Together You Achieved:</h4>
                    <div class="metric">
                        <span class="label">Total Score:</span>
                        <span class="value" id="totalScore">0</span>
                    </div>
                    <div class="metric">
                        <span class="label">Harmony Level:</span>
                        <span class="value" id="harmonyLevel">-</span>
                    </div>
                    <div class="metric">
                        <span class="label">Combined Time:</span>
                        <span class="value" id="combinedTime">0s</span>
                    </div>
                </div>
            </div>
            
            <div class="share-buttons">
                <div class="share-btn" onclick="shareWhatsApp()">
                    <span>📱</span>
                    <span>WhatsApp</span>
                </div>
            </div>
            
            <button class="btn" style="margin-top: 20px;" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <!-- Achievement Popup - Desktop Only -->
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon" id="achievementIcon">🏆</div>
        <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
        <div class="achievement-desc" id="achievementDesc">Description</div>
    </div>

    <!-- Round Complete Popup - Desktop Only -->
    <div id="roundCompletePopup" class="round-complete-popup">
        <div style="font-size: 1.5rem;">✨</div>
        <div style="font-weight: bold; margin: 5px 0;">Round <span id="roundNumber"></span> Complete!</div>
        <div style="font-size: 0.85rem;">Your embrace deepens...</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
    
   <script>

class GameStateManager {
    constructor() {
        this.gameActive = false;
        this.spawnTimeouts = new Set();
        this.spawnIntervals = new Set();
        this.activeDistractions = new Set();
        this.gameCleanupCallbacks = [];
        console.log("🎮 GameStateManager initialized");
    }

    addDistraction(distractionElement) {
    if (distractionElement) {
        this.activeDistractions.add(distractionElement);
        console.log(`📍 Added distraction to tracking (total: ${this.activeDistractions.size})`);
    }
}

     removeDistraction(distractionElement) {
    if (this.activeDistractions.has(distractionElement)) {
        this.activeDistractions.delete(distractionElement);
        console.log(`🗑️ Removed distraction from tracking (remaining: ${this.activeDistractions.size})`);
    }
}
    
    startGame() {
        console.log("🚀 Starting game with proper state management");
        this.gameActive = true;
        this.clearAllTimeouts();
    }
    
    endGame() {
        console.log("🏁 Ending game with proper cleanup");
        this.gameActive = false;
        this.clearAllTimeouts();
        this.executeCleanupCallbacks();
    }
    
    addTimeout(timeoutId) {
        this.spawnTimeouts.add(timeoutId);
    }
    
    addInterval(intervalId) {
        this.spawnIntervals.add(intervalId);
    }
    
    addCleanupCallback(callback) {
        this.gameCleanupCallbacks.push(callback);
    }
    
    clearAllTimeouts() {
        console.log(`🧹 Clearing ${this.spawnTimeouts.size} timeouts and ${this.spawnIntervals.size} intervals`);
        
        this.spawnTimeouts.forEach(timeoutId => {
            clearTimeout(timeoutId);
        });
        this.spawnTimeouts.clear();
        
        this.spawnIntervals.forEach(intervalId => {
            clearInterval(intervalId);
        });
        this.spawnIntervals.clear();
    }
    
    executeCleanupCallbacks() {
        this.gameCleanupCallbacks.forEach(callback => {
            try {
                callback();
            } catch (error) {
                console.error("❌ Cleanup callback failed:", error);
            }
        });
        this.gameCleanupCallbacks = [];
    }
    
    isGameActive() {
        return this.gameActive;
    }
}

// Global instance
const gameStateManager = new GameStateManager();

function spawnDistractions() {
    // CRITICAL: Always check if game is still active
    if (!gameStateManager.isGameActive()) {
        console.log("🛑 Spawning cancelled - game no longer active");
        return;
    }
    
    // Check if we've spawned enough distractions for this round
    if (currentSpawnedDistractions >= currentRequiredDistractions) {
        console.log(`✅ All distractions spawned for round (${currentSpawnedDistractions}/${currentRequiredDistractions})`);
        return;
    }
    
    try {
        // Spawn a single distraction
        createDistraction();
        currentSpawnedDistractions++;
        console.log(`📍 Spawned distraction ${currentSpawnedDistractions}/${currentRequiredDistractions}`);
        
        // Calculate next spawn delay (use your existing logic or this simple version)
        const nextSpawnDelay = calculateSpawnDelay();
        console.log(`⏱️ Next spawn in ${nextSpawnDelay}ms (adaptive)`);
        
        // Schedule next spawn with proper tracking
        const timeoutId = setTimeout(() => {
            // Remove this timeout from tracking when it executes
            gameStateManager.spawnTimeouts.delete(timeoutId);
            spawnDistractions(); // Continue spawning
        }, nextSpawnDelay);
        
        // Track this timeout so we can cancel it if needed
        gameStateManager.addTimeout(timeoutId);
        
    } catch (error) {
        console.error("❌ Error in spawn system:", error);
        // If spawning fails, end the game gracefully
        endGame();
    }
}

function calculateAdaptiveSpawnDelay() {
    const baseDelay = 1000; // 1 second base
    const skillLevel = getCurrentSkillLevel();
    const roundMultiplier = 1 - (currentRoundData.roundNumber * 0.05);
    
    // Higher skill = shorter delays (more challenging)
    const skillMultiplier = Math.max(0.3, 1.5 - skillLevel);
    
    return Math.max(300, baseDelay * skillMultiplier * roundMultiplier);
}    

// ========================================================================
// PERFORMANCE MONITORING SYSTEM
// ========================================================================
const performanceMonitor = {
    fps: 60,
    frameCount: 0,
    lastTime: performance.now(),
    memoryWarning: false,
    consecutiveLowFrames: 0,
    
    update() {
        this.frameCount++;
        const now = performance.now();
        const deltaTime = now - this.lastTime;
        
        if (deltaTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / deltaTime);
            this.frameCount = 0;
            this.lastTime = now;
            
            // FIXED: Better performance detection
            if (this.fps < 20) {
                this.consecutiveLowFrames++;
                if (this.consecutiveLowFrames >= 2 && !this.memoryWarning) {
                    console.warn('⚠️ Severe performance issue detected:', this.fps, 'fps');
                    this.memoryWarning = true;
                    this.optimizePerformance();
                }
            } else if (this.fps > 30) {
                this.consecutiveLowFrames = 0;
                this.memoryWarning = false;
            }
        }
    },

    optimizePerformance() {
        console.log('🔧 Optimizing performance...');
        
        try {
            // Reduce particle count more aggressively
            if (particleSystem && particleSystem.geometry) {
                const positions = particleSystem.geometry.attributes.position.array;
                const newCount = Math.floor(positions.length / 12); // Reduce by 90%
                particleSystem.geometry.attributes.position.count = Math.max(30, newCount);
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // Reduce animation complexity
            document.documentElement.style.setProperty('--animation-scale', '0.3');
            
            // Disable some visual effects for mobile
            if (gameState.isMobile) {
                const particles = document.querySelectorAll('.particle-effect');
                particles.forEach(p => p.style.display = 'none');
            }
        } catch (error) {
            console.error('Performance optimization failed:', error);
        }
    }
};

// ========================================================================
// GAME STATE 
// ========================================================================
const gameState = {
    currentScreen: 'loading',
    currentRound: 1,
    score: 0,
    lives: 5,
    intimacyHearts: 5,
    maxHearts: 5,
    consecutiveMisses: 0,
    lastMissTime: 0,
    streak: 0,
    bestStreak: 0,
    achievements: new Set(),
    distractions: [],
    lastDistraction: 0,
    gameRunning: false,
    audioEnabled: true,
    roundScore: 0,
    totalEliminations: 0,
    perfectRounds: 0,
    gameStartTime: 0,
    tipIndex: 0,
    lastScore: 0,
    roundMissed: 0,
    comboCount: 0,
    comboMultiplier: 1,
    lastEliminationTime: 0,
    comboTimeWindow: 2000,
    multiKillTimer: null,
    multiKillCount: 0,
    challengeCode: null,
    distractionsSpawned: 0,
    distractionsRequired: 5,
    roundStartTime: 0,
    spawnTimeout: null,
    roundInProgress: false,
    achievementShown: new Set(),
    heartUpdateInProgress: false,
    isMobile: window.innerWidth <= 768,
    gameplayStarted: false,
    comboTutorialShown: false,
    lastShakeTime: 0,
    shakeIntensity: 1,
    trophyBonusShown: false,
    totalTrophiesCollected: 0,
    priorityTutorialShown: false,
    gameEnding: false,
    
    // Enhanced cleanup system
    cleanup() {
    console.log('🧹 Cleaning up game state...');
    
    // Emergency cleanup for silhouette animations
    if (typeof silhouetteSeparationSystem !== 'undefined') {
        silhouetteSeparationSystem.emergencyCleanup();
    }
    
    // Clear all timeouts and intervals
    if (this.spawnTimeout) {
        clearTimeout(this.spawnTimeout);
        this.spawnTimeout = null;
    }
    if (this.multiKillTimer) {
        clearTimeout(this.multiKillTimer);
        this.multiKillTimer = null;
    }
    
    // Clean up distractions with safety checks
    this.distractions.forEach(distraction => {
        try {
            if (distraction && distraction.timerInterval) {
                clearInterval(distraction.timerInterval);
            }
            if (distraction && distraction.parentNode) {
                distraction.remove();
            }
        } catch (error) {
            console.warn('Distraction cleanup failed:', error);
        }
    });
    
    this.distractions = [];
    this.gameRunning = false;
    this.roundInProgress = false;
    this.gameEnding = false;
    
    // Clear any remaining intervals from cleanup tracker
    cleanupTracker.cleanup();
},
    
    // Proper state reset
    reset() {
        this.cleanup();
        
        // Reset core game values
        this.currentRound = 1;
        this.score = 0;
        this.lives = 5;
        this.intimacyHearts = 5;
        this.consecutiveMisses = 0;
        this.streak = 0;
        this.roundScore = 0;
        this.totalEliminations = 0;
        this.perfectRounds = 0;
        this.roundMissed = 0;
        this.multiKillCount = 0;
        this.distractionsSpawned = 0;
        this.gameplayStarted = false;
        this.gameEnding = false;
        this.heartUpdateInProgress = false;
        
        // Clear achievement tracking
        this.achievementShown.clear();
        
        console.log('🔄 Game state reset complete');
    }
};

const heartSystemManager = {
    updateQueue: [],
    isProcessing: false,
    
    queueUpdate(heartCount, reason = 'update') {
        this.updateQueue.push({ heartCount, reason, timestamp: Date.now() });
        this.processQueue();
    },
    
    async processQueue() {
        if (this.isProcessing || this.updateQueue.length === 0) return;
        
        this.isProcessing = true;
        
        while (this.updateQueue.length > 0) {
            const update = this.updateQueue.shift();
            
            // Skip outdated updates (older than 1 second)
            if (Date.now() - update.timestamp > 1000) continue;
            
            await this.performHeartUpdate(update.heartCount, update.reason);
            
            // Small delay to prevent visual artifacts
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        this.isProcessing = false;
    },
    
    async performHeartUpdate(heartCount, reason) {
        return new Promise((resolve) => {
            try {
                const hearts = document.querySelectorAll('.game-hud .intimacy-meter .heart');
                console.log(`❤️ Processing heart update: ${heartCount} hearts (${reason})`);
                
                hearts.forEach((heart, index) => {
                    heart.classList.remove('breaking', 'gaining', 'active', 'inactive', 'pulsing');
                    
                    // Add appropriate animation based on reason
                    if (reason === 'loss' && index === heartCount) {
                        heart.classList.add('breaking');
                    } else if (reason === 'gain' && index === heartCount - 1) {
                        heart.classList.add('gaining');
                    }
                    
                    // Set final state after animation
                    setTimeout(() => {
                        if (index < heartCount) {
                            heart.classList.add('active');
                        } else {
                            heart.classList.add('inactive');
                        }
                    }, 200);
                });
                
                console.log(`❤️ Heart update completed: ${heartCount} active hearts`);
                resolve();
                
            } catch (error) {
                console.error('Heart update failed:', error);
                resolve();
            }
        });
    }
};

const comboSystemManager = {
    currentCombo: 0,
    comboTimer: null,
    comboWindow: 2000, // 2 seconds to maintain combo
    comboMultipliers: {
        3: 1.2,   // 20% bonus
        5: 1.5,   // 50% bonus
        7: 2.0,   // 100% bonus
        10: 2.5,  // 150% bonus
        15: 3.0   // 200% bonus
    },
    bestCombo: 0,
    
    registerElimination() {
        this.currentCombo++;
        this.resetComboTimer();
        
        if (this.currentCombo > this.bestCombo) {
            this.bestCombo = this.currentCombo;
        }
        
        const multiplier = this.getComboMultiplier();
        
        if (multiplier > 1) {
            this.showComboFeedback(this.currentCombo, multiplier);
        }
        
        return multiplier;
    },
    
    breakCombo() {
        if (this.currentCombo > 0) {
            console.log(`💔 Combo broken at ${this.currentCombo}`);
            this.currentCombo = 0;
            this.clearComboTimer();
        }
    },
    
    resetComboTimer() {
        this.clearComboTimer();
        
        this.comboTimer = setTimeout(() => {
            this.breakCombo();
        }, this.comboWindow);
        
        cleanupTracker.addTimeout(this.comboTimer);
    },
    
    clearComboTimer() {
        if (this.comboTimer) {
            clearTimeout(this.comboTimer);
            this.comboTimer = null;
        }
    },
    
    getComboMultiplier() {
        const milestones = Object.keys(this.comboMultipliers)
            .map(k => parseInt(k))
            .sort((a, b) => b - a);
        
        for (const milestone of milestones) {
            if (this.currentCombo >= milestone) {
                return this.comboMultipliers[milestone];
            }
        }
        
        return 1.0;
    },
    
    showComboFeedback(combo, multiplier) {
        try {
            const comboEl = document.createElement('div');
            comboEl.style.cssText = `
                position: fixed;
                top: 25%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 1.4rem;
                font-weight: bold;
                color: #FFD700;
                text-shadow: 0 0 15px #FFD700;
                pointer-events: none;
                z-index: 2500;
                animation: comboPopIn 1.2s ease-out forwards;
                text-align: center;
                background: rgba(0, 0, 0, 0.8);
                padding: 10px 20px;
                border-radius: 15px;
                border: 2px solid #FFD700;
            `;
            
            comboEl.innerHTML = `
                <div>COMBO x${combo}!</div>
                <div style="font-size: 0.9rem; margin-top: 5px;">${multiplier}x MULTIPLIER</div>
            `;
            
            document.body.appendChild(comboEl);
            
            setTimeout(() => {
                if (comboEl.parentNode) {
                    comboEl.remove();
                }
            }, 1200);
            
        } catch (error) {
            console.error('Combo feedback failed:', error);
        }
    },
    
    getComboInfo() {
        return {
            current: this.currentCombo,
            multiplier: this.getComboMultiplier(),
            best: this.bestCombo,
            timeRemaining: this.comboTimer ? this.comboWindow : 0
        };
    }
};

// ========================================================================
// PROGRESSIVE DIFFICULTY SYSTEM
// ========================================================================
const difficultyState = {
    playerSkill: 0.5,
    recentPerformance: [],
    currentDifficultyLevel: 'normal',
    
    // Performance tracking
    totalEliminations: 0,
    totalMisses: 0,
    averageReactionTime: 1500,
    recentReactionTimes: [],
    perfectRoundsStreak: 0,
    
    // FIXED: Balanced difficulty modifiers
    spawnRateMultiplier: 1.0,
    reactionTimeMultiplier: 1.0,
    criticalChance: 0.1,
    urgencyDistribution: { critical: 0.1, warning: 0.3, safe: 0.6 },
    
    // Adaptation settings
    adaptationRate: 0.05, // Slower adaptation for stability
    minDifficulty: 0.3,
    maxDifficulty: 1.8, // More reasonable max difficulty
    
    // FIXED: More stable skill updating
    updateSkill(reactionTime, success, urgency) {
        // Track reaction time with bounds checking
        const clampedReactionTime = Math.max(300, Math.min(5000, reactionTime));
        this.recentReactionTimes.push(clampedReactionTime);
        
        if (this.recentReactionTimes.length > 15) { // Smaller window for stability
            this.recentReactionTimes.shift();
        }
        
        // Calculate average reaction time
        this.averageReactionTime = this.recentReactionTimes.reduce((a, b) => a + b, 0) / this.recentReactionTimes.length;
        
        // Track recent performance
        this.recentPerformance.push(success ? 1 : 0);
        if (this.recentPerformance.length > 8) { // Smaller window
            this.recentPerformance.shift();
        }
        
        // FIXED: More stable skill calculation
        const successRate = this.recentPerformance.reduce((a, b) => a + b, 0) / this.recentPerformance.length;
        const reactionScore = Math.max(0, (2500 - this.averageReactionTime) / 2500);
        const urgencyBonus = urgency === 'critical' ? 0.15 : urgency === 'warning' ? 0.08 : 0;
        
        // Calculate new skill level with stability
        const targetSkill = Math.max(0.2, Math.min(0.9, 
            (successRate * 0.7) + (reactionScore * 0.2) + (urgencyBonus * 0.1)
        ));
        
        // FIXED: Smoother skill adjustment
        this.playerSkill += (targetSkill - this.playerSkill) * this.adaptationRate;
        this.playerSkill = Math.max(0.2, Math.min(0.9, this.playerSkill));
        
        // Update difficulty level
        this.updateDifficultyLevel();
        
        // Less frequent logging
        if (Math.random() < 0.1) {
            console.log(`🎯 Skill: ${this.playerSkill.toFixed(2)}, Success: ${(successRate * 100).toFixed(0)}%, Level: ${this.currentDifficultyLevel}`);
        }
    },
    
    // FIXED: Better balanced difficulty levels
    updateDifficultyLevel() {
        if (this.playerSkill < 0.35) {
            this.currentDifficultyLevel = 'easy';
            this.spawnRateMultiplier = 1.4; // Slower spawning
            this.reactionTimeMultiplier = 1.3; // More time
            this.criticalChance = 0.05;
            this.urgencyDistribution = { critical: 0.05, warning: 0.25, safe: 0.7 };
        } else if (this.playerSkill < 0.55) {
            this.currentDifficultyLevel = 'normal';
            this.spawnRateMultiplier = 1.0;
            this.reactionTimeMultiplier = 1.0;
            this.criticalChance = 0.1;
            this.urgencyDistribution = { critical: 0.1, warning: 0.3, safe: 0.6 };
        } else if (this.playerSkill < 0.75) {
            this.currentDifficultyLevel = 'hard';
            this.spawnRateMultiplier = 0.9; // Slightly faster
            this.reactionTimeMultiplier = 0.9; // Slightly less time
            this.criticalChance = 0.15;
            this.urgencyDistribution = { critical: 0.15, warning: 0.35, safe: 0.5 };
        } else {
            this.currentDifficultyLevel = 'expert';
            this.spawnRateMultiplier = 0.8; // Faster spawning
            this.reactionTimeMultiplier = 0.85; // Less time
            this.criticalChance = 0.2;
            this.urgencyDistribution = { critical: 0.2, warning: 0.4, safe: 0.4 };
        }
    },
    
    reset() {
        this.recentPerformance = [];
        this.recentReactionTimes = [];
        this.perfectRoundsStreak = 0;
        // Keep playerSkill to maintain learning across games
    }
};

// ENHANCED SKILL TRACKER 
const advancedSkillTracker = {
    skillLevel: 0.5,
    recentPerformance: [], // Last 15 actions for real-time adaptation
    failureHistory: {},
    lastSpawnTime: 0,
    skillTrend: 'stable', // 'improving', 'declining', 'stable'
    confidenceLevel: 0.5, // How confident we are in skill assessment
    
    // Performance metrics
    totalActions: 0,
    successfulActions: 0,
    averageReactionTime: 1500,
    recentReactionTimes: [],
    
    updateSkill(success, reactionTime, distractionType) {
        this.totalActions++;
        if (success) this.successfulActions++;
        
        // Track recent performance with more granular data
        const performanceScore = this.calculatePerformanceScore(success, reactionTime);
        this.recentPerformance.push({
            success,
            reactionTime,
            score: performanceScore,
            timestamp: Date.now(),
            type: distractionType
        });
        
        // Keep only last 15 actions for responsiveness
        if (this.recentPerformance.length > 15) {
            this.recentPerformance.shift();
        }
        
        // Track reaction times
        this.recentReactionTimes.push(reactionTime);
        if (this.recentReactionTimes.length > 10) {
            this.recentReactionTimes.shift();
        }
        
        // Track failures by type for intelligent distraction selection
        if (!success) {
            this.failureHistory[distractionType] = (this.failureHistory[distractionType] || 0) + 1;
        }
        
        // Calculate new skill level
        this.calculateSkillLevel();
        this.assessSkillTrend();
        this.updateConfidenceLevel();
        
        // Update global difficulty state
        difficultyState.playerSkill = this.skillLevel;
        difficultyState.updateDifficultyLevel();
        
        // Report skill consistently
        this.reportSkill();
    },
    
    calculatePerformanceScore(success, reactionTime) {
        if (!success) return 0;
        
        // Optimal reaction time is around 800-1200ms
        const optimalTime = 1000;
        const timeScore = Math.max(0, 1 - Math.abs(reactionTime - optimalTime) / 2000);
        
        return timeScore;
    },
    
    calculateSkillLevel() {
        if (this.recentPerformance.length === 0) return;
        
        // Weighted average of recent performance (more recent = higher weight)
        let weightedSum = 0;
        let totalWeight = 0;
        
        this.recentPerformance.forEach((perf, index) => {
            const weight = index + 1; // More recent actions have higher weight
            const recencyBonus = (Date.now() - perf.timestamp) < 10000 ? 1.2 : 1.0; // Bonus for very recent actions
            const finalWeight = weight * recencyBonus;
            
            weightedSum += perf.score * finalWeight;
            totalWeight += finalWeight;
        });
        
        const newSkill = totalWeight > 0 ? weightedSum / totalWeight : 0.5;
        
        // Smooth skill transitions to avoid jarring difficulty changes
        const smoothingFactor = 0.3;
        this.skillLevel = this.skillLevel * (1 - smoothingFactor) + newSkill * smoothingFactor;
        this.skillLevel = Math.max(0.1, Math.min(0.95, this.skillLevel));
        
        // Update average reaction time
        if (this.recentReactionTimes.length > 0) {
            this.averageReactionTime = this.recentReactionTimes.reduce((a, b) => a + b, 0) / this.recentReactionTimes.length;
        }
    },
    
    assessSkillTrend() {
        if (this.recentPerformance.length < 8) return;
        
        // Compare recent half vs older half
        const mid = Math.floor(this.recentPerformance.length / 2);
        const recentHalf = this.recentPerformance.slice(mid);
        const olderHalf = this.recentPerformance.slice(0, mid);
        
        const recentAvg = recentHalf.reduce((sum, p) => sum + p.score, 0) / recentHalf.length;
        const olderAvg = olderHalf.reduce((sum, p) => sum + p.score, 0) / olderHalf.length;
        
        const difference = recentAvg - olderAvg;
        
        if (difference > 0.1) {
            this.skillTrend = 'improving';
        } else if (difference < -0.1) {
            this.skillTrend = 'declining';
        } else {
            this.skillTrend = 'stable';
        }
    },
    
    updateConfidenceLevel() {
        // Confidence increases with more data and consistent performance
        const dataPoints = this.recentPerformance.length;
        const variance = this.calculatePerformanceVariance();
        
        const dataConfidence = Math.min(dataPoints / 15, 1);
        const consistencyConfidence = Math.max(0, 1 - variance);
        
        this.confidenceLevel = (dataConfidence + consistencyConfidence) / 2;
    },
    
    calculatePerformanceVariance() {
        if (this.recentPerformance.length < 3) return 1;
        
        const scores = this.recentPerformance.map(p => p.score);
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
        
        return Math.sqrt(variance);
    },
    
    getAdaptiveSpawnRate(baseRate) {
        // Multi-factor spawn rate calculation
        
        // 1. Base skill adjustment
        let skillMultiplier = 1.8 - (this.skillLevel * 1.2); // Higher skill = faster spawning
        
        // 2. Trend adjustment
        if (this.skillTrend === 'improving') {
            skillMultiplier *= 0.9; // Speed up if player is improving
        } else if (this.skillTrend === 'declining') {
            skillMultiplier *= 1.2; // Slow down if player is struggling
        }
        
        // 3. Confidence adjustment
        const confidenceMultiplier = 0.8 + (this.confidenceLevel * 0.4); // Less confident = more conservative
        skillMultiplier *= confidenceMultiplier;
        
        // 4. Recent failure adjustment
        const recentFailures = this.recentPerformance.filter(p => !p.success).length;
        if (recentFailures > 5) {
            skillMultiplier *= 1.3; // Mercy spawning
        }
        
        const adaptedRate = Math.floor(baseRate * skillMultiplier);
        
        // Safety bounds
        return Math.max(500, Math.min(4000, adaptedRate));
    },
    
    selectIntelligentDistraction(availableTypes) {
        // Weight against problem types, but still maintain variety
        const weights = availableTypes.map(type => {
            const failures = this.failureHistory[type.name] || 0;
            const totalOfThisType = this.recentPerformance.filter(p => p.type === type.name).length || 1;
            const failureRate = failures / totalOfThisType;
            
            // Reduce weight for problematic types, but don't eliminate them
            return Math.max(0.2, 1 - (failureRate * 0.6));
        });
        
        // Weighted random selection
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let random = Math.random() * totalWeight;
        
        for (let i = 0; i < availableTypes.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return availableTypes[i];
            }
        }
        
        return availableTypes[0];
    },
    
    reportSkill() {
        // Consistent skill reporting with context
        const successRate = this.successfulActions / this.totalActions * 100;
        const difficulty = difficultyState.currentDifficultyLevel;
        
        console.log(`🎯 Skill: ${this.skillLevel.toFixed(2)} | Success: ${successRate.toFixed(0)}% | Level: ${difficulty} | Trend: ${this.skillTrend} | Confidence: ${this.confidenceLevel.toFixed(2)}`);
    },
    
    getSkillAnalytics() {
        return {
            currentSkill: this.skillLevel,
            trend: this.skillTrend,
            confidence: this.confidenceLevel,
            successRate: this.successfulActions / this.totalActions * 100,
            averageReactionTime: this.averageReactionTime,
            totalActions: this.totalActions,
            recentPerformance: this.recentPerformance.slice(-5), // Last 5 actions
            problemAreas: Object.entries(this.failureHistory)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([type, failures]) => ({ type, failures }))
        };
    }
};

// ========================================================================
// MESSAGE BOX CONFIGURATION
// ========================================================================
const messageBoxConfig = {
    mobile: {
        topPosition: '10%',     // Adjust this to move up/down on mobile
        fontSize: '0.7rem',     // Smaller font for mobile
        padding: '6px 12px',    // Compact padding
        maxWidth: '240px',      // Narrower width
        borderRadius: '10px'
    },
    desktop: {
        topPosition: '10%',     // Desktop position
        fontSize: '0.9rem',     // Larger font for desktop
        padding: '12px 20px',   // More padding
        maxWidth: '280px',      // Wider width
        borderRadius: '15px'
    }
};

// ========================================================================
// MESSAGE QUEUE SYSTEM 
// ========================================================================
const messageQueue = {
    queue: [],
    isShowing: false,
    
    add(message, type = 'hint', duration = 2000) {
        // FIXED: Prevent message spam
        if (this.queue.length > 3) {
            this.queue.shift(); // Remove oldest message
        }
        
        this.queue.push({ message, type, duration });
        this.processQueue();
    },
    
    processQueue() {
        if (this.isShowing || this.queue.length === 0) return;
        
        this.isShowing = true;
        const { message, type, duration } = this.queue.shift();
        
        this.showMessage(message, type, duration);
    },
    
   showMessage(message, type, duration) {
    try {
        const messageEl = document.createElement('div');
        
        // Use configuration based on screen size
        const isMobile = window.innerWidth <= 768;
        const config = isMobile ? messageBoxConfig.mobile : messageBoxConfig.desktop;
        
        messageEl.style.cssText = `
            position: fixed;
            top: ${config.topPosition};
            left: 50%;
            transform: translate(-50%, 0);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: ${config.padding};
            border-radius: ${config.borderRadius};
            font-size: ${config.fontSize};
            font-weight: bold;
            z-index: 1500;
            max-width: ${config.maxWidth};
            text-align: center;
            border: 2px solid ${type === 'combo' ? '#FFD700' : type === 'achievement' ? '#00FF00' : '#FF4444'};
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            animation: topMessageSlideIn 0.4s ease-out forwards;
            opacity: 0;
            line-height: 1.3;
        `;
        
        messageEl.textContent = message;
        document.body.appendChild(messageEl);
        
        const timeoutId = setTimeout(() => {
            messageEl.style.animation = 'topMessageSlideOut 0.4s ease-out forwards';
            
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.remove();
                }
                this.isShowing = false;
                setTimeout(() => this.processQueue(), 100);
            }, 400);
        }, duration);
        
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.error('Message display failed:', error);
        this.isShowing = false;
        setTimeout(() => this.processQueue(), 200);
    }
}
};

const gameAnalytics = {
    sessionData: {
        startTime: null,
        endTime: null,
        totalScore: 0,
        roundsCompleted: 0,
        totalEliminations: 0,
        totalMisses: 0,
        bestCombo: 0,
        achievements: [],
        skillProgression: [],
        roundTimes: [],
        distractionTypes: {}
    },
    
    startSession() {
        this.sessionData.startTime = Date.now();
        this.sessionData = { ...this.sessionData, ...this.getEmptySession() };
    },
    
    getEmptySession() {
        return {
            totalScore: 0,
            roundsCompleted: 0,
            totalEliminations: 0,
            totalMisses: 0,
            bestCombo: 0,
            achievements: [],
            skillProgression: [],
            roundTimes: [],
            distractionTypes: {}
        };
    },
    
    recordRoundComplete(roundNumber, time, score, missed) {
        this.sessionData.roundsCompleted++;
        this.sessionData.roundTimes.push(time);
        this.sessionData.totalScore += score;
        this.sessionData.totalMisses += missed;
        
        // Record skill progression
        const skillData = advancedSkillTracker.getSkillAnalytics();
        this.sessionData.skillProgression.push({
            round: roundNumber,
            skill: skillData.currentSkill,
            trend: skillData.trend,
            timestamp: Date.now()
        });
    },
    
    recordElimination(distractionType, reactionTime, comboMultiplier) {
        this.sessionData.totalEliminations++;
        
        // Track distraction type performance
        if (!this.sessionData.distractionTypes[distractionType]) {
            this.sessionData.distractionTypes[distractionType] = {
                eliminations: 0,
                totalReactionTime: 0,
                averageReactionTime: 0
            };
        }
        
        const typeData = this.sessionData.distractionTypes[distractionType];
        typeData.eliminations++;
        typeData.totalReactionTime += reactionTime;
        typeData.averageReactionTime = typeData.totalReactionTime / typeData.eliminations;
    },
    
    recordMiss(distractionType) {
        this.sessionData.totalMisses++;
    },
    
    recordAchievement(achievementId) {
        if (!this.sessionData.achievements.includes(achievementId)) {
            this.sessionData.achievements.push(achievementId);
        }
    },
    
    endSession() {
        this.sessionData.endTime = Date.now();
        this.sessionData.bestCombo = comboSystemManager.bestCombo;
        
        return this.generateReport();
    },
    
    generateReport() {
        const duration = (this.sessionData.endTime - this.sessionData.startTime) / 1000;
        const averageRoundTime = this.sessionData.roundTimes.length > 0 
            ? this.sessionData.roundTimes.reduce((a, b) => a + b, 0) / this.sessionData.roundTimes.length 
            : 0;
        
        const accuracy = this.sessionData.totalEliminations / 
            (this.sessionData.totalEliminations + this.sessionData.totalMisses) * 100;
        
        const skillData = advancedSkillTracker.getSkillAnalytics();
        
        return {
            summary: {
                duration: Math.floor(duration),
                finalScore: this.sessionData.totalScore,
                roundsCompleted: this.sessionData.roundsCompleted,
                accuracy: accuracy.toFixed(1),
                bestCombo: this.sessionData.bestCombo,
                achievementsUnlocked: this.sessionData.achievements.length
            },
            performance: {
                totalEliminations: this.sessionData.totalEliminations,
                totalMisses: this.sessionData.totalMisses,
                averageRoundTime: averageRoundTime.toFixed(1),
                finalSkillLevel: skillData.currentSkill.toFixed(2),
                skillTrend: skillData.trend
            },
            distractionAnalysis: Object.entries(this.sessionData.distractionTypes)
                .map(([type, data]) => ({
                    type,
                    eliminations: data.eliminations,
                    avgReactionTime: data.averageReactionTime.toFixed(0)
                }))
                .sort((a, b) => b.eliminations - a.eliminations),
            skillProgression: this.sessionData.skillProgression
        };
    }
};

// ========================================================================
// CSS ANIMATIONS FOR ADVANCED FEATURES
// ========================================================================

const enhancedGameCSS = `
@keyframes comboPopIn {
    0% { 
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
    }
    20% { 
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
    }
    40% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
    100% { 
        transform: translate(-50%, -60%) scale(0.8);
        opacity: 0;
    }
}

@keyframes heartBreaking {
    0% { transform: scale(1); }
    25% { transform: scale(1.1); background: #ff4444; }
    50% { transform: scale(0.9); }
    75% { transform: scale(1.05); }
    100% { transform: scale(1); background: #666; }
}

@keyframes heartGaining {
    0% { transform: scale(1); background: #666; }
    25% { transform: scale(1.2); background: #44ff44; }
    50% { transform: scale(1.1); }
    75% { transform: scale(1.15); }
    100% { transform: scale(1); background: #ff4444; }
}

.heart.breaking {
    animation: heartBreaking 0.6s ease-out;
}

.heart.gaining {
    animation: heartGaining 0.6s ease-out;
}

.heart.pulsing {
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}
`;

// Enhanced CSS
if (!document.getElementById('enhancedGameCSS')) {
    const style = document.createElement('style');
    style.id = 'enhancedGameCSS';
    style.textContent = enhancedGameCSS;
    document.head.appendChild(style);
}

console.log('🎮 Enhanced Game Systems Loaded: Advanced Skill Tracking, Dynamic Difficulty, Fixed Hearts, Clear Combos, Analytics');

// ========================================================================
// MOBILE OPTIMIZATION SYSTEM
// ========================================================================
const mobileState = {
    isMobile: window.innerWidth <= 768,
    isTouch: 'ontouchstart' in window,
    devicePixelRatio: window.devicePixelRatio || 1,
    orientation: window.innerHeight > window.innerWidth ? 'portrait' : 'landscape',
    vibrationSupported: 'vibrate' in navigator,
    
    performance: {
        frameDrops: 0,
        averageFPS: 60,
        lowFPSCount: 0
    },
    
    update() {
        this.isMobile = window.innerWidth <= 768;
        this.orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    }
};

// ========================================================================
// CLEANUP TRACKER 
// ========================================================================
const cleanupTracker = {
    timeouts: new Set(),
    intervals: new Set(),
    audioSources: new Set(),
    
    addTimeout(id) { 
        this.timeouts.add(id); 
    },
    
    addInterval(id) { 
        this.intervals.add(id); 
    },
    
    addAudioSource(source) { 
        this.audioSources.add(source); 
    },
    
    cleanup() {
        // Clear all timeouts
        this.timeouts.forEach(id => {
            try {
                clearTimeout(id);
            } catch (e) {}
        });
        this.timeouts.clear();
        
        // Clear all intervals
        this.intervals.forEach(id => {
            try {
                clearInterval(id);
            } catch (e) {}
        });
        this.intervals.clear();
        
        // Stop all audio sources
        this.audioSources.forEach(source => {
            try {
                if (source && source.stop) {
                    source.stop();
                }
            } catch (e) {}
        });
        this.audioSources.clear();
        
        console.log('🧹 Cleanup tracker cleared');
    }
};

// ========================================================================
// STATIC DATA ARRAYS
// ========================================================================
const loadingTips = [
    "💡 Pro tip: Lasting longer starts with the right preparation... 😉",
    "🎯 Focus is everything - in games and in life! #LongLast3X",
    "🔥 Some moments deserve to last 3X longer... just saying",
    "💪 Protect your moments. Embrace Up 3X.",
    "⚡ The best performances require the right preparation"
];

const hinglishTemplates = [
    "Yaar, maine {score} points banaye! 💪 Tera stamina kitna hai? 😏 #LongLast3X",
    "Boss, {time} seconds tak tika raha! 🔥 Tu kitna der chalega? 😎 #EndlessEmbrace",
    "Mera score dekh: {score}! 🏆 Teri baari ab... himmat hai? 😈 #3XPower",
    "Bhai, streak toh dekh: {streak} 🔥🔥 Beat kar sake toh kar! 💯 #StaminaKing",
    "Distraction ka baap hun main! 🎯 Score: {score} - tera kya scene? 🤔",
    "3X warrior ban gaya! ⚡ {score} points! Chal competition karte hai 😏",
    "Mast game hai yaar! 🎮 {time} seconds survive kiya... tu try kar! 💪",
    "Kya focus hai mera! 🧘‍♂️ Score {score}! Tere paas hai dum? 🔥",
    "Endless embrace mein {score} banaye! 💕 Partner ke saath khelo, maza aayega 😉",
    "Stamina check kar apna! 💯 Mera score: {score} - challenge accept? 🎯",
    "Power packed performance! 💥 {time} seconds! Teri turn ab 😎 #3XLonger",
    "Distraction destroyer! 🔥 Score {score}! Aa jaa ring mein 🥊 #EndlessEmbrace"
];

const coupleSharingTemplates = [
    "Couple power! 💑 Total score: {totalScore}! Harmony: {harmonyLevel} 💕 Combined time: {combinedTime}s! #CoupleGoals #LongLast3X",
    "Partner ke saath {totalScore} points! 🔥 Harmony level: {harmonyLevel} ❤️ Time: {combinedTime}s - Beat this! 😎",
    "Double trouble! 💪 Score {totalScore}, Harmony {harmonyLevel} 💕 {combinedTime} seconds of pure focus! #PowerCouple",
    "Couple challenge complete! 🏆 {totalScore} combined! {harmonyLevel} connection 💖 Challenge us: {challengeCode}",
    "Partner aur main = {totalScore} points! 🔥 {harmonyLevel} sync! Time {combinedTime}s 💪 #EndlessEmbrace",
    "Love + Focus = {totalScore}! ❤️ {harmonyLevel} harmony, {combinedTime}s stamina! Couple ho toh aisi! 😍"
];

const achievements = {
    quickDraw: {
        id: 'quickDraw',
        name: 'Quick Draw McGraw',
        desc: 'Eliminate distractions within 0.8 seconds',
        icon: '🎯'
    },
    penetratingFocus: {
        id: 'penetratingFocus',
        name: 'Penetrating Focus',
        desc: 'Complete a round without missing any distractions',
        icon: '🔥'
    },
    multiPosition: {
        id: 'multiPosition',
        name: 'Multi-Position Master',
        desc: 'Eliminate 3 distractions within 2 seconds',
        icon: '💪'
    },
    climaxControl: {
        id: 'climaxControl',
        name: 'Climax Control Expert',
        desc: 'Complete game without losing any intimacy points',
        icon: '🧘‍♂️'
    },
    speedDemon: {
        id: 'speedDemon',
        name: 'Speed Demon',
        desc: 'Complete Round 1 in under 30 seconds',
        icon: '⚡'
    },
    heatWave: {
        id: 'heatWave',
        name: 'Heat Wave',
        desc: '7+ consecutive eliminations',
        icon: '🌡️'
    },
    staminaSupreme: {
        id: 'staminaSupreme',
        name: 'Stamina Supreme',
        desc: 'Complete 2 perfect rounds',
        icon: '💯'
    },
    warrior3x: {
        id: 'warrior3x',
        name: '3X Warrior',
        desc: 'Achieve 150+ score',
        icon: '⚡'
    }
};

const coupleAchievements = {
    perfectHarmony: {
        id: 'perfectHarmony',
        name: 'Perfect Harmony',
        desc: 'Scores within 10% of each other',
        icon: '❤️'
    },
    powerCouple: {
        id: 'powerCouple',
        name: 'Power Couple',
        desc: 'Combined score over 300',
        icon: '💪'
    },
    marathonLovers: {
        id: 'marathonLovers',
        name: 'Marathon Lovers',
        desc: 'Combined play time over 3 minutes',
        icon: '⏰'
    },
    synchronizedSouls: {
        id: 'synchronizedSouls',
        name: 'Synchronized Souls',
        desc: 'Share 3+ achievements',
        icon: '🔗'
    },
    competitiveSpirits: {
        id: 'competitiveSpirits',
        name: 'Competitive Spirits',
        desc: 'Score difference over 100',
        icon: '🏁'
    },
    twinFlames: {
        id: 'twinFlames',
        name: 'Twin Flames',
        desc: 'Identical scores',
        icon: '👫'
    }
};

// Ensure we have exactly 8 rounds
const rounds = [
    {
        name: "The First Spark",
        setting: "Home: Morning Rush",
        silhouette: "https://assets.codepen.io/t-24779/hug-embrace.png",
        bgMusic: 'romantic',
        distractions: [
            { icon: '⏰', name: 'alarm', sound: 'ring' },
            { icon: '📱', name: 'notification', sound: 'ding' },
            { icon: '📝', name: 'reminder', sound: 'pop', special: 'sticky' },
            { icon: '☕', name: 'coffee', sound: 'bubble' },
            { icon: '🗞️', name: 'newspaper', sound: 'rustle', booster: true }
        ],
        spawnRate: 2000,
        reactionTime: 2000,
        distractionsRequired: 8
    },
    {
        name: "Sneaking Moments",
        setting: "On the Way: Public Transport",
        silhouette: "https://assets.codepen.io/t-24779/romantic-embrace.png",
        bgMusic: 'upbeat',
        distractions: [
            { icon: '🚗', name: 'horn', sound: 'honk' },
            { icon: '💬', name: 'chatter', sound: 'talk' },
            { icon: '📢', name: 'announcement', sound: 'announce' },
            { icon: '🚍', name: 'bus', sound: 'brake' },
            { icon: '📻', name: 'radio', sound: 'static' },
            { icon: '🎵', name: 'music', sound: 'loud', booster: true }
        ],
        spawnRate: 1800,
        reactionTime: 1800,
        distractionsRequired: 10
    },
    {
        name: "Hidden Desires",
        setting: "At Work: Office Desk",
        silhouette: "https://assets.codepen.io/t-24779/standing-embrace.png",
        bgMusic: 'electronic',
        distractions: [
            { icon: '✉️', name: 'email', sound: 'ding' },
            { icon: '👤', name: 'boss', sound: 'footstep', booster: true },
            { icon: '☎️', name: 'phone', sound: 'ring' },
            { icon: '💻', name: 'computer', sound: 'beep' },
            { icon: '🖨️', name: 'printer', sound: 'print' },
            { icon: '📊', name: 'deadline', sound: 'alert' }
        ],
        spawnRate: 1600,
        reactionTime: 1700,
        distractionsRequired: 12
    },
    {
        name: "A Quick Escape",
        setting: "Coffee Break: Cafe Nook",
        silhouette: "https://assets.codepen.io/t-24779/stand-kiss-embrace.png",
        bgMusic: 'jazz',
        distractions: [
            { icon: '☕', name: 'grinder', sound: 'whir' },
            { icon: '🗣️', name: 'calling', sound: 'call' },
            { icon: '📢', name: 'ad', sound: 'pop', swipe: true },
            { icon: '🍰', name: 'cake', sound: 'ding' },
            { icon: '🪑', name: 'chair', sound: 'scrape' },
            { icon: '🎵', name: 'jukebox', sound: 'music', booster: true }
        ],
        spawnRate: 1400,
        reactionTime: 1600,
        distractionsRequired: 15
    },
    {
        name: "Lunchtime Rendezvous",
        setting: "Lunch Break: Park Bench",
        silhouette: "https://assets.codepen.io/t-24779/lap-embrace.png",
        bgMusic: 'warm',
        distractions: [
            { icon: '⚽', name: 'ball', sound: 'bounce', booster: true },
            { icon: '👁️', name: 'passerby', sound: 'look' },
            { icon: '🍦', name: 'icecream', sound: 'jingle' },
            { icon: '🐕', name: 'dog', sound: 'bark' },
            { icon: '🎵', name: 'music', sound: 'loud' },
            { icon: '🌤️', name: 'glare', sound: 'bright' },
            { icon: '🐦', name: 'birds', sound: 'chirp' },
            { icon: '🚴', name: 'cyclist', sound: 'bell' }
        ],
        spawnRate: 1300,
        reactionTime: 1500,
        distractionsRequired: 18
    },
    {
        name: "Evening Delight",
        setting: "After Work: Restaurant Dinner",
        silhouette: "https://assets.codepen.io/t-24779/held-up-lap-embrace.png",
        bgMusic: 'sophisticated',
        distractions: [
            { icon: '🗣️', name: 'loudtable', sound: 'chatter' },
            { icon: '🤚', name: 'waiter', sound: 'excuse' },
            { icon: '📳', name: 'vibration', sound: 'buzz', booster: true },
            { icon: '🍽️', name: 'dishes', sound: 'clatter' },
            { icon: '👶', name: 'baby', sound: 'cry' },
            { icon: '📸', name: 'camera', sound: 'flash' },
            { icon: '🎂', name: 'birthday', sound: 'singing' },
            { icon: '💳', name: 'bill', sound: 'receipt' }
        ],
        spawnRate: 1200,
        reactionTime: 1400,
        distractionsRequired: 22
    },
    {
        name: "Anticipation",
        setting: "On the Way Back Home: Night Drive",
        silhouette: "https://assets.codepen.io/t-24779/holding-embrace.png",
        bgMusic: 'driving',
        distractions: [
            { icon: '🔊', name: 'roadnoise', sound: 'vroom' },
            { icon: '🗺️', name: 'gps', sound: 'reroute' },
            { icon: '💬', name: 'texts', sound: 'multiple', booster: true },
            { icon: '🚦', name: 'traffic', sound: 'stop' },
            { icon: '🚓', name: 'police', sound: 'siren' },
            { icon: '⛽', name: 'fuel', sound: 'warning' },
            { icon: '🌧️', name: 'rain', sound: 'wiper' },
            { icon: '📻', name: 'radio', sound: 'static' }
        ],
        spawnRate: 1100,
        reactionTime: 1300,
        distractionsRequired: 25
    },
    {
        name: "Ultimate Intimacy",
        setting: "Back at Home: Bedroom Night",
        silhouette: "https://assets.codepen.io/t-24779/holding-behind-pose.png",
        bgMusic: 'intimate',
        distractions: [
            { icon: '📧', name: 'latework', sound: 'urgent' },
            { icon: '🐱', name: 'pet', sound: 'meow' },
            { icon: '🏠', name: 'creak', sound: 'creak' },
            { icon: '💭', name: 'thoughts', sound: 'whisper', booster: true },
            { icon: '🚪', name: 'door', sound: 'knock' },
            { icon: '🌡️', name: 'temperature', sound: 'ac' },
            { icon: '💡', name: 'lights', sound: 'switch' },
            { icon: '⏰', name: 'tomorrow', sound: 'worry' }
        ],
        spawnRate: 1000,
        reactionTime: 1200,
        distractionsRequired: 30
    }
];

// ========================================================================
// GLOBAL VARIABLES
// ========================================================================
let scene, camera, renderer;
let particleSystem;
let audioContext, audioBuffers = {};
let backgroundMusic = null;
let currentBgMusic = null;
let heartUpdateQueue = null;

// ========================================================================
// INITIALIZATION SYSTEM 
// ========================================================================
window.addEventListener('load', init);

async function init() {
    try {
        console.log('🎮 Initializing KamaSutra Endless Embrace Game...');
        
        gameState.lastScore = parseInt(localStorage.getItem('lastScore') || '0');
        gameState.isMobile = window.innerWidth <= 480;
        
        updateLoadingProgress(10);
        updateLoadingTip();
        
        setupThreeJS();
        updateLoadingProgress(30);
        
        await preloadAssets();
        updateLoadingProgress(70);
        
        await initAudio();
        updateLoadingProgress(90);
        
        checkEmergencySave();
        
        setTimeout(() => {
            updateLoadingProgress(100);
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
                showScreen('startScreen');
            }, 500);
        }, 1000);

        setInterval(updateLoadingTip, 4000);
        setupEventListeners();
        
        console.log('✅ Game initialized successfully');
    } catch (error) {
        console.error('❌ Initialization failed:', error);
        gracefulRecover();
    }
}

function updateLoadingProgress(percent) {
    const progressEl = document.getElementById('loadingProgress');
    if (progressEl) {
        progressEl.style.width = percent + '%';
    }
}

function updateLoadingTip() {
    gameState.tipIndex = Math.floor(Math.random() * loadingTips.length);
    const tipElement = document.getElementById('loadingTip');
    if (tipElement) {
        tipElement.innerHTML = `<p>${loadingTips[gameState.tipIndex]}</p>`;
    }
}

// ========================================================================
// THREEJS SETUP 
// ========================================================================
function setupThreeJS() {
    try {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            console.warn('Game canvas not found, creating fallback');
            return;
        }
        
        renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            alpha: true,
            antialias: false, // FIXED: Disabled for better performance
            powerPreference: 'low-power'
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // FIXED: Cap pixel ratio
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        camera.position.z = 5;
        createParticleSystem();
        
        console.log('🎨 Three.js setup completed');
    } catch (error) {
        console.error('Three.js setup failed:', error);
    }
}

function createParticleSystem() {
    try {
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = gameState.isMobile ? 80 : 120; // FIXED: Reduced particle count
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            
            if (Math.random() > 0.5) {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.84;
                colors[i * 3 + 2] = 0.0;
            } else {
                colors[i * 3] = 0.83;
                colors[i * 3 + 1] = 0.21;
                colors[i * 3 + 2] = 0.35;
            }
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: gameState.isMobile ? 0.06 : 0.08, // FIXED: Smaller particles
            transparent: true,
            opacity: 0.7, // FIXED: Lower opacity
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        
        particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);
    } catch (error) {
        console.error('Particle system creation failed:', error);
    }
}

// ========================================================================
// ASSET PRELOADING 
// ========================================================================
async function preloadAssets() {
    try {
        const imagePromises = rounds.map(round => {
            return new Promise((resolve) => {
                const img = new Image();
                const timeoutId = setTimeout(() => resolve(), 3000); // FIXED: Shorter timeout
                img.onload = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                img.src = round.silhouette;
            });
        });
        
        await Promise.allSettled(imagePromises);
        console.log('📸 Assets preloaded successfully');
    } catch (error) {
        console.error('Asset preloading failed:', error);
    }
}

// ========================================================================
// AUDIO SYSTEM 
// ========================================================================
async function initAudio() {
    try {
        const savedAudioState = localStorage.getItem('audioEnabled');
        if (savedAudioState !== null) {
            gameState.audioEnabled = savedAudioState === 'true';
        }
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // FIXED: Simplified audio buffer creation
        audioBuffers.success = createTone(880, 0.1);
        audioBuffers.fail = createTone(220, 0.2);
        audioBuffers.achievement = createTone(1320, 0.3);
        audioBuffers.ring = createTone(440, 0.3);
        audioBuffers.ding = createTone(660, 0.1);
        audioBuffers.pop = createTone(550, 0.05);
        audioBuffers.buzz = createNoise(0.1);
        
        createBackgroundMusic();
        
        console.log('🔊 Audio system initialized');
    } catch (error) {
        console.warn('Audio initialization failed, continuing without audio:', error);
        gameState.audioEnabled = false;
    }
}

function createTone(frequency, duration) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        data[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 
                 Math.exp(-i / (length * 0.3));
    }
    
    return buffer;
}

function createNoise(duration) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        data[i] = (Math.random() - 0.5) * 0.5 * Math.exp(-i / (length * 0.3));
    }
    
    return buffer;
}

function createBackgroundMusic() {
    const musicTracks = {
        romantic: { freq: [440, 550, 660], vol: 0.2 },
        upbeat: { freq: [523, 659, 784], vol: 0.25 },
        electronic: { freq: [494, 587, 740], vol: 0.2 },
        jazz: { freq: [466, 554, 698], vol: 0.2 },
        warm: { freq: [440, 554, 659], vol: 0.2 },
        sophisticated: { freq: [415, 523, 622], vol: 0.2 },
        driving: { freq: [494, 622, 740], vol: 0.25 },
        intimate: { freq: [440, 523, 659], vol: 0.15 }
    };

    Object.entries(musicTracks).forEach(([name, config]) => {
        try {
            audioBuffers[name] = createMusicTrack(config.freq, config.vol);
        } catch (error) {
            console.warn(`Failed to create ${name} track:`, error);
        }
    });
}

function createMusicTrack(frequencies, volume) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 4;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            let sample = 0;
            const t = i / sampleRate;
            
            frequencies.forEach((freq) => {
                const envelope = Math.sin(Math.PI * t / duration);
                sample += Math.sin(2 * Math.PI * freq * t) * envelope / frequencies.length;
            });
            
            data[i] = sample * volume * (1 - i / length);
        }
    }
    
    return buffer;
}

function playSound(soundName, volume = 0.5) {
    if (!gameState.audioEnabled || !audioContext || !audioBuffers[soundName]) return;
    
    try {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        
        source.buffer = audioBuffers[soundName];
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = volume;
        
        cleanupTracker.addAudioSource(source);
        source.start();
        
    } catch (error) {
        console.warn('Sound playback failed:', error);
    }
}

function playBackgroundMusic(trackName) {
    if (!gameState.audioEnabled || !audioContext || !audioBuffers[trackName]) return;
    
    stopBackgroundMusic();
    
    try {
        backgroundMusic = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        
        backgroundMusic.buffer = audioBuffers[trackName];
        backgroundMusic.loop = true;
        backgroundMusic.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = 0.15; // FIXED: Lower volume
        
        backgroundMusic.start();
        currentBgMusic = backgroundMusic;
        cleanupTracker.addAudioSource(backgroundMusic);
    } catch (error) {
        console.warn('Background music playback failed:', error);
    }
}

function stopBackgroundMusic() {
    if (currentBgMusic) {
        try {
            currentBgMusic.stop();
            cleanupTracker.audioSources.delete(currentBgMusic);
        } catch (error) {
            // Already stopped
        }
        currentBgMusic = null;
    }
}

// ========================================================================
// HEART SYSTEM 
// ========================================================================
function updateHeartMeter() {
    heartSystemManager.queueUpdate(gameState.intimacyHearts, 'update');
}

function loseHeart(reason = 'missed') {
    console.log(`💔 loseHeart called with reason: ${reason}`);
    console.log(`💔 Current hearts: ${gameState.intimacyHearts}, gameEnding: ${gameState.gameEnding}`);
    
    // Early exit conditions
    if (gameState.intimacyHearts <= 0 || 
        gameState.heartUpdateInProgress || 
        gameState.gameEnding) {
        
        console.log('❤️ Cannot lose heart - hearts:', gameState.intimacyHearts, 'updating:', gameState.heartUpdateInProgress, 'gameEnding:', gameState.gameEnding);
        return;
    }
    
    // Calculate hearts to lose based on reason
    let heartsToLose = 1;
    
    if (reason === 'consecutive' && gameState.consecutiveMisses >= 3) {
        heartsToLose = 2;
    }
    
    if (reason === 'critical' && gameState.currentRound >= 6) {
        heartsToLose = 2;
    }
    
    // Apply heart loss
    const previousHearts = gameState.intimacyHearts;
    gameState.intimacyHearts = Math.max(0, gameState.intimacyHearts - heartsToLose);
    
    console.log(`💔 Lost ${heartsToLose} heart(s). ${previousHearts} → ${gameState.intimacyHearts} (reason: ${reason})`);
    
    // Update heart systems
    if (typeof heartSystemManager !== 'undefined' && heartSystemManager.queueUpdate) {
        heartSystemManager.queueUpdate(gameState.intimacyHearts, 'loss');
    }
    
    if (typeof updateHeartMeter === 'function') {
        updateHeartMeter();
    }
    
    // Play sound effect
    if (typeof playSound === 'function') {
        playSound('fail', 0.3);
        enhancedFeedback.heartLoss(gameState.intimacyHearts);
    }
    
    // ✅ SINGLE POINT OF GAME ENDING LOGIC
    if (gameState.intimacyHearts <= 0 && !gameState.gameEnding) {
        console.log('💔 loseHeart: No hearts remaining - ending game');
        
        // Set flag immediately to prevent duplicates
        gameState.gameEnding = true;
        
        // Stop all game activity
        if (typeof gameStateManager !== 'undefined') {
            gameStateManager.endGame();
        }
        
        // End game with delay for UI updates
        setTimeout(() => {
            endGame();
        }, 1000);
    }
}
function calculateHeartLoss(reason) {
    switch(reason) {
        case 'missed':
        case 'timeout':
            return 1;
            
        case 'consecutive':
            return gameState.consecutiveMisses >= 3 ? 2 : 1;
            
        case 'critical':
        case 'major':
            return gameState.currentRound >= 6 ? 2 : 1;
            
        case 'devastating':
            return 3;
            
        default:
            return 1;
    }
}

function updateHeartSystems() {
    // Use heart system manager if available
    if (typeof heartSystemManager !== 'undefined' && heartSystemManager.queueUpdate) {
        heartSystemManager.queueUpdate(gameState.intimacyHearts, 'loss');
    }
    
    // Backup direct update
    if (typeof updateHeartMeter === 'function') {
        updateHeartMeter();
    }
}

function playHeartLossSound(heartsLost) {
    if (typeof playSound === 'function') {
        const soundType = heartsLost >= 2 ? 'critical_fail' : 'fail';
        const volume = Math.min(0.5, 0.2 + (heartsLost * 0.1));
        playSound(soundType, volume);
    }
}

function checkGameOver() {
    if (gameState.intimacyHearts <= 0) {
        console.log('💔 No hearts remaining - ending game');
        
        // Stop all game activity immediately
        if (typeof gameStateManager !== 'undefined') {
            gameStateManager.endGame();
        }
        
        // End game with delay
        setTimeout(() => {
            endGame();
        }, 1000);
    }
}

function gainHeart(reason = 'bonus') {
    if (gameState.intimacyHearts >= gameState.maxHearts) {
        console.log('❤️ Cannot gain heart - already at max');
        return;
    }
    
    const previousHearts = gameState.intimacyHearts;
    gameState.intimacyHearts = Math.min(gameState.maxHearts, gameState.intimacyHearts + 1);

    console.log(`💖 Gained heart! ${previousHearts} → ${gameState.intimacyHearts} (${reason})`);
    
    playSound('success', 0.5);
    updateHeartMeter();
    
    if (reason === 'perfectCombo') {
        messageQueue.add("Perfect combo! Heart restored! 💕", 'hint', 1500);
    } else if (reason === 'roundCompletion') {
        messageQueue.add("Perfect round! Bonus heart! ❤️", 'hint', 1500);
    }
}

// ========================================================================
// EVENT SYSTEM 
// ========================================================================
function setupEventListeners() {
    window.addEventListener('resize', handleResize);
    document.addEventListener('click', handleInteraction);
    
    // FIXED: Simplified mobile handling
    if (mobileState.isMobile) {
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('.modal-content, .results-panel')) {
                e.preventDefault();
            }
        }, { passive: false });
    }
    
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            handleResize();
            mobileState.update();
        }, 200);
    });
}

function handleResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    gameState.isMobile = window.innerWidth <= 768;
}

function handleInteraction(event) {
    if (!gameState.gameRunning) return;
    
    const x = event.clientX;
    const y = event.clientY;
    
    if (!x || !y) return;
    
    handleGameTap(x, y);
}

//  Mobile touch handling
let touchStartTime = 0;
let touchStartPos = { x: 0, y: 0 };

function handleTouchStart(e) {
    touchStartTime = Date.now();
    const touch = e.touches[0];
    touchStartPos = { x: touch.clientX, y: touch.clientY };
}

function handleTouchEnd(e) {
    if (!gameState.gameRunning) return;
    
    const touchDuration = Date.now() - touchStartTime;
    const touch = e.changedTouches[0];
    
    // Only process quick taps
    if (touchDuration < 500) {
        const deltaX = Math.abs(touch.clientX - touchStartPos.x);
        const deltaY = Math.abs(touch.clientY - touchStartPos.y);
        
        // Only process if not a drag
        if (deltaX < 20 && deltaY < 20) {
            handleGameTap(touch.clientX, touch.clientY);
        }
    }
}

function handleGameTap(x, y) {
    const distractions = document.querySelectorAll('.distraction');
    let hitDetected = false;
    
    distractions.forEach(distraction => {
        if (!distraction.parentNode) return;
        
        const rect = distraction.getBoundingClientRect();
        const padding = mobileState.isMobile ? 15 : 10;
        
        if (x >= (rect.left - padding) && x <= (rect.right + padding) && 
            y >= (rect.top - padding) && y <= (rect.bottom + padding)) {
            hitDetected = true;
            eliminateDistraction(distraction);
        }
    });
    
    // Visual feedback for misses
    if (!hitDetected && distractions.length > 0) {
        createMissEffect(x, y);
    }
}

function createMissEffect(x, y) {
    try {
        // Handle both coordinate parameters and distraction element parameter
        let effectX, effectY;
        
        if (typeof x === 'object' && x && x.getBoundingClientRect) {
            // Called with distraction element (from failDistraction)
            const rect = x.getBoundingClientRect();
            effectX = rect.left + rect.width / 2;
            effectY = rect.top + rect.height / 2;
        } else if (typeof x === 'number' && typeof y === 'number') {
            // Called with coordinates (from handleGameTap)
            effectX = x;
            effectY = y;
        } else {
            console.warn('Invalid parameters for createMissEffect:', x, y);
            return;
        }
        
        const missEffect = document.createElement('div');
        missEffect.style.cssText = `
            position: fixed;
            left: ${effectX - 20}px;
            top: ${effectY - 20}px;
            width: 40px;
            height: 40px;
            border: 3px solid #FF4444;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            animation: missExpand 0.6s ease-out forwards;
        `;
        
        document.body.appendChild(missEffect);
        
        const timeoutId = setTimeout(() => {
            if (missEffect.parentNode) {
                missEffect.remove();
            }
        }, 600);
        
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.error('Miss effect creation failed:', error);
    }
}
// ========================================================================
// SCREEN MANAGEMENT 
// ========================================================================
function showScreen(screenId) {
    try {
        // Hide all screens
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
            screen.style.display = 'none';
        });
        
        // Show target screen
        const screen = document.getElementById(screenId);
        if (screen) {
            screen.style.display = 'flex';
            screen.classList.add('active');
            gameState.currentScreen = screenId;
            
            console.log('📺 Screen changed to:', screenId);
        }
        
        if (screenId === 'gameScreen') {
            setTimeout(() => {
                startGame();
            }, 100);
        } else {
            gameState.cleanup();
        }
        
    } catch (error) {
        console.error('Screen change failed:', error);
    }
}

// ========================================================================
// GAME LOGIC - MAIN FUNCTIONS
// ========================================================================
function startGame() {
    try {
        console.log("🚀 Starting new game");
        
        gameStateManager.startGame();
            
        // Clean up and reset
        gameState.reset();
        difficultyState.reset();
        
        // Start analytics session
        gameAnalytics.startSession();
        
        // Initialize game state
        Object.assign(gameState, {
            currentRound: 1,
            score: 0,
            lives: 5,
            intimacyHearts: 5,
            gameStartTime: Date.now(),
            gameRunning: true,
            gameplayStarted: false
        });
        
        updateHUD();
        updateHeartMeter();
        
        // Setup achievement board for desktop only
        setTimeout(() => {
            handleAchievementBoardVisibility();
        }, 500);
        
        startRound(gameState.currentRound);
        animate();
        
        console.log('✅ Game started successfully');
    } catch (error) {
        console.error('❌ Game start failed:', error);
        gracefulRecover();
    }
}

function startRound(roundNumber) {
    // Proper bounds checking
    if (roundNumber > rounds.length) {
        console.log('🏁 All rounds completed! Ending game...');
        endGame();
        return;
    }
    
    try {
        gameState.roundInProgress = true;
        const round = rounds[roundNumber - 1];
        gameState.roundScore = 0;
        gameState.roundMissed = 0;
        gameState.distractionsSpawned = 0;
        gameState.distractionsRequired = round.distractionsRequired;
        gameState.roundStartTime = Date.now();
        
        console.log(`🚀 Starting Round ${roundNumber}: ${round.name} - Need ${round.distractionsRequired} distractions`);
        
        // Clean up previous round
        if (gameState.spawnTimeout) {
            clearTimeout(gameState.spawnTimeout);
        }
        
        updateCoupleSilhouette(round.silhouette);
        playBackgroundMusic(round.bgMusic);
        
        showRoundIntro(round);
        
        // Start spawning after intro
        gameState.spawnTimeout = setTimeout(() => {
            spawnDistractions();
        }, 2000);
        cleanupTracker.addTimeout(gameState.spawnTimeout);
        
    } catch (error) {
        console.error('❌ Round start failed:', error);
        gracefulRecover();
    }
}
function showRoundIntro(round) {
    try {
        const message = `Round ${gameState.currentRound}: ${round.name}`;
        messageQueue.add(message, 'round', 2000);
        
        // Add tutorial message specifically for Round 1
        if (gameState.currentRound === 1) {
            setTimeout(() => {
                messageQueue.add("Protect your embrace, tap fast! ❤️", 'hint', 2500);
            }, 2500); // Show after round intro message
        }
        
    } catch (error) {
        console.error('Round intro failed:', error);
    }
}
function updateCoupleSilhouette(imageSrc) {
    try {
        const silhouetteDiv = document.getElementById('coupleSilhouette');
        const silhouetteImg = document.getElementById('silhouetteImage');
        
        if (silhouetteDiv && silhouetteImg) {
            silhouetteDiv.style.opacity = '0';
            
            
           setTimeout(() => {
        silhouetteImg.onload = () => {
        silhouetteDiv.style.display = 'block';  // Force display first
        silhouetteDiv.style.opacity = '0.8';
        silhouetteDiv.style.visibility = 'visible';  // Ensure visibility
        console.log("🎭 Silhouette updated and visible");
    };
        silhouetteImg.src = imageSrc;
    
    // Immediate display (don't wait for image load)
        silhouetteDiv.style.display = 'block';
        silhouetteDiv.style.opacity = '0.8';
    
    }, 400);
         
        }
    } catch (error) {
        console.error('Silhouette update failed:', error);
    }
}

// ========================================================================
// DISTRACTION SYSTEM 
// ========================================================================
function spawnDistractions() {
    if (!gameState.gameRunning || !gameState.roundInProgress || 
        gameState.distractionsSpawned >= gameState.distractionsRequired) {
        return;
    }
    
    try {
        const round = rounds[gameState.currentRound - 1];
        
        // NEW: Use intelligent distraction selection
        const selectedType = advancedSkillTracker.selectIntelligentDistraction(round.distractions);
        
        createDistraction(selectedType, round.reactionTime);
        gameState.distractionsSpawned++;
        
        console.log(`📍 Spawned distraction ${gameState.distractionsSpawned}/${gameState.distractionsRequired}`);
        
        if (gameState.distractionsSpawned < gameState.distractionsRequired) {
            // NEW: Use adaptive spawn rate
            const adaptiveRate = advancedSkillTracker.getAdaptiveSpawnRate(round.spawnRate);
            
            console.log(`⏱️ Next spawn in ${adaptiveRate}ms (adaptive)`);
            
            gameState.spawnTimeout = setTimeout(() => {
                spawnDistractions();
            }, adaptiveRate);
            cleanupTracker.addTimeout(gameState.spawnTimeout);
        }
        
    } catch (error) {
        console.error('Enhanced spawning failed:', error);
    }
}

function createDistraction(distractionData, baseReactionTime) {
    try {
        const distraction = document.createElement('div');
        distraction.className = 'distraction'; 
        distraction.dataset.type = distractionData.name;
        distraction.dataset.spawnTime = Date.now();
        distraction.dataset.booster = distractionData.booster || false;

        // Trophy chance
        const isTrophy = Math.random() < 0.03; // FIXED: Reduced trophy chance
        if (isTrophy) {
            distraction.dataset.trophy = 'true';
            distraction.dataset.bonusPoints = '50'; // FIXED: Reduced trophy bonus
        }

        // Adaptive urgency and reaction time
        const adaptiveUrgency = assignAdaptiveUrgency();
        distraction.dataset.urgency = adaptiveUrgency;
        
        // Apply adaptive reaction time with safety bounds
        let adaptiveReactionTime = Math.floor(baseReactionTime * difficultyState.reactionTimeMultiplier);
        adaptiveReactionTime = Math.max(gameState.isMobile ? 1000 : 800, adaptiveReactionTime);
        adaptiveReactionTime = Math.min(3000, adaptiveReactionTime); // Cap at 3 seconds
        
        // Create visual content
        if (distractionData.special === 'sticky') {
            const stickyTexts = [
                "Don't<br>forget<br>milk!",
                "Call<br>mom<br>❤️",
                "Meeting<br>at 3pm"
            ];
            const randomText = stickyTexts[Math.floor(Math.random() * stickyTexts.length)];
            distraction.innerHTML = `
                <div class="sticky-note">
                    <div style="transform: rotate(${-10 + Math.random() * 20}deg); font-size: 12px;">
                        ${randomText}
                    </div>
                </div>
            `;
        } else {
            if (isTrophy) {
                distraction.innerHTML = `
                    <div class="distraction-icon glass trophy">
                        🏆
                        <div class="trophy-bonus">BONUS!</div>
                        <div class="priority-ring ${adaptiveUrgency}"></div>
                    </div>
                `;
            } else {
                const iconClass = distractionData.booster ? 'distraction-icon glass booster' : 'distraction-icon glass';
                distraction.innerHTML = `
                    <div class="${iconClass}">
                        ${distractionData.icon}
                        <div class="priority-ring ${adaptiveUrgency}"></div>
                    </div>
                `;
            }
        }

        const gameScreen = document.getElementById('gameScreen');

        // Apply appropriate movement system based on round
        let movementApplied = false;
        // Check round and apply appropriate movement system
        if (gameState.currentRound >= 7 && gameState.currentRound <= 8) {
            // Rounds 7-8: Orbital movements
            movementApplied = orbitalMovementSystem.applyOrbital(distraction, gameState.currentRound);
        } else if (gameState.currentRound >= 5 && gameState.currentRound <= 6) {
            // Rounds 5-6: Bouncing movements
            movementApplied = bouncingMovementSystem.applyBouncing(distraction, gameState.currentRound);
        } else if (gameState.currentRound >= 3 && gameState.currentRound <= 4) {
            // Rounds 3-4: Sliding movements
            movementApplied = directSlidingSystem.applyDirectSliding(distraction, gameState.currentRound);
        }

        if (!movementApplied) {
            // Rounds 1-2: Static positioning
            const safeMargin = gameState.isMobile ? 15 : 10;
            const x = safeMargin + Math.random() * (100 - 2 * safeMargin);
            const y = safeMargin + Math.random() * (100 - 2 * safeMargin);
            
            distraction.style.left = x + '%';
            distraction.style.top = y + '%';
            distraction.style.position = 'absolute';
        }

        const movementType = gameState.currentRound >= 7 ? 'ORBITAL' : 
                            gameState.currentRound >= 5 ? 'BOUNCING' : 
                            gameState.currentRound >= 3 ? 'SLIDING' : 'STATIC';
        console.log(`🎮 Round ${gameState.currentRound}: ${movementType} distraction created`);

        if (gameScreen) {
            gameScreen.appendChild(distraction);
        }
        playSound(distractionData.sound || 'pop', 0.2);
        gameState.distractions.push(distraction);

        // Track the distraction element
        gameStateManager.addDistraction(distraction);

        // Simplified timer system
        let timeLeft = adaptiveReactionTime;
        const timerInterval = setInterval(() => {
            timeLeft -= 100;
            
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                cleanupTracker.intervals.delete(timerInterval);
                
                // Safety check before failing
                if (distraction.parentNode && gameState.distractions.includes(distraction)) {
                    // NEW: Remove from state manager before failing
                    gameStateManager.removeDistraction(distraction);
                    failDistraction(distraction);
                }
            }
        }, 100);

        distraction.timerInterval = timerInterval;
        cleanupTracker.addInterval(timerInterval);

    } catch (error) {
        console.error('❌ Distraction creation failed:', error);
    }
}

function assignAdaptiveUrgency() {
    const distribution = difficultyState.urgencyDistribution;
    const rand = Math.random();
    
    if (rand < distribution.critical) {
        return 'critical';
    } else if (rand < distribution.critical + distribution.warning) {
        return 'warning';
    } else {
        return 'safe';
    }
}

function assignAdaptiveUrgency() {
    const distribution = difficultyState.urgencyDistribution;
    const rand = Math.random();
    
    if (rand < distribution.critical) {
        return 'critical';
    } else if (rand < distribution.critical + distribution.warning) {
        return 'warning';
    } else {
        return 'safe';
    }
}

// ========================================================================
// COMBO SYSTEM - BALANCED
// ========================================================================
function eliminateDistraction(distraction) {
    if (!distraction.parentNode) return;
    
    try {
        const reactionTime = Date.now() - parseInt(distraction.dataset.spawnTime);
        const isBooster = distraction.dataset.booster === 'true';
        const isTrophy = distraction.dataset.trophy === 'true';
        const urgency = distraction.dataset.urgency || 'safe';
        const distractionType = distraction.dataset.type;
        
        // NEW: Use advanced skill tracker instead
        advancedSkillTracker.updateSkill(true, reactionTime, distractionType);
        
        // Clear timer
        if (distraction.timerInterval) {
            clearInterval(distraction.timerInterval);
            cleanupTracker.intervals.delete(distraction.timerInterval);
        }
        
        // Update difficulty tracking
        difficultyState.updateSkill(reactionTime, true, urgency);

        // Calculate base points
        let basePoints = 10;
        if (isTrophy) {
            basePoints = 50; // FIXED: Reduced trophy bonus
            gameState.totalTrophiesCollected++;
            messageQueue.add("TROPHY BONUS! +50 points! 🏆", 'hint', 1500);
        } else if (isBooster) {
            basePoints = 15; // FIXED: Reduced booster bonus
        }
        
        // Use enhanced combo system
        const comboMultiplier = comboSystemManager.registerElimination();
        if (comboSystemManager?.currentCombo >= 5) {
           enhancedFeedback.combo(comboSystemManager.currentCombo);
        }
        
        // Calculate points with combo multiplier
        const finalPoints = Math.floor(basePoints * comboMultiplier);
        gameState.score += finalPoints;
        gameState.roundScore += finalPoints;
        
        // Record in analytics
        gameAnalytics.recordElimination(distractionType, reactionTime, comboMultiplier);
        
        // Update stats
        gameState.totalEliminations++;
        gameState.streak++;
        gameState.consecutiveMisses = 0;
        
        if (gameState.streak > gameState.bestStreak) {
            gameState.bestStreak = gameState.streak;
        }
        
        // Heart bonus for perfect streaks
        if (gameState.streak >= 10 && gameState.streak % 10 === 0) {
            gainHeart('perfectCombo');
        }
        
        checkAchievements(reactionTime);
        createParticleEffect(distraction);
        
        playSound('success', 0.4);
        enhancedFeedback.elimination(distractionType, comboSystemManager?.currentCombo || 0);
        
        // Remove distraction
        distraction.remove();
        const index = gameState.distractions.indexOf(distraction);
        if (index > -1) {
            gameState.distractions.splice(index, 1);
        }
        
        updateHUD();
        checkRoundCompletion();
        
    } catch (error) {
        console.error('❌ Distraction elimination failed:', error);
    }
}

function showComboEffect(multiplier, count) {
    try {
        const comboPopup = document.createElement('div');
        
        comboPopup.style.cssText = `
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px #FFD700;
            pointer-events: none;
            z-index: 2500;
            animation: comboFloat 1.5s ease-out forwards;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid #FFD700;
        `;
        
        comboPopup.textContent = `${multiplier}X COMBO! x${count}`;
        document.body.appendChild(comboPopup);
        
        setTimeout(() => {
            if (comboPopup.parentNode) {
                comboPopup.remove();
            }
        }, 1500);
        
    } catch (error) {
        console.error('❌ Combo effect failed:', error);
    }
}

function failDistraction(distraction) {
    console.log('💥 Distraction failed:', distraction.dataset.type);
    
    try {
        const urgency = distraction.dataset.urgency || 'safe';
        const reactionTime = Date.now() - parseInt(distraction.dataset.spawnTime);
        const distractionType = distraction.dataset.type;
        
        // Use enhanced feedback for silhouette reaction
        enhancedFeedback.silhouetteReaction(urgency);

        // Use advanced skill tracker
        advancedSkillTracker.updateSkill(false, reactionTime, distractionType);
        
        // Clear timer
        if (distraction.timerInterval) {
            clearInterval(distraction.timerInterval);
            cleanupTracker.intervals.delete(distraction.timerInterval);
        }
        
        // Update difficulty tracking
        difficultyState.updateSkill(reactionTime, false, urgency);
        
        const currentTime = Date.now();
        
        // Track consecutive misses
        if (currentTime - gameState.lastMissTime < 10000) {
            gameState.consecutiveMisses++;
        } else {
            gameState.consecutiveMisses = 1;
        }
        gameState.lastMissTime = currentTime;
        
        // Determine heart loss
        let lossReason = 'missed';
        if (gameState.consecutiveMisses >= 3) {
            lossReason = 'consecutive';
        }
        if (urgency === 'critical' && gameState.currentRound >= 6) {
            lossReason = 'critical';
        }
        
        // Apply effects
        createMissEffect(distraction);
        loseHeart(lossReason);
        
        gameState.streak = 0;
        gameState.roundMissed++;
        
        // Break combo on miss
        comboSystemManager.breakCombo();
        
        // Record in analytics
        gameAnalytics.recordMiss(distractionType);
        
        playSound('fail', 0.3);
        enhancedFeedback.failure(urgency || 'normal');
        
        // Remove distraction
        distraction.remove();
        const index = gameState.distractions.indexOf(distraction);
        if (index > -1) {
            gameState.distractions.splice(index, 1);
        }
        
        // Check if game should end
         checkRoundCompletion();

    } catch (error) {
        console.error('❌ Distraction failure handling failed:', error);
    }
}

// ========================================================================
// ROUND COMPLETION 
// ========================================================================
function checkRoundCompletion() {
    try {
        console.log('🔍 Checking round completion:', {
            spawned: gameState.distractionsSpawned,
            required: gameState.distractionsRequired,
            remaining: gameState.distractions.length,
            roundInProgress: gameState.roundInProgress
        });
        
        // FIXED: Proper completion check
        if (gameState.distractionsSpawned >= gameState.distractionsRequired && 
            gameState.distractions.length === 0 && 
            gameState.roundInProgress) {
            console.log('✅ Round completion criteria met!');
            completeRound();
        }
    } catch (error) {
        console.error('❌ Round completion check failed:', error);
    }
}

function completeRound() {
    try {
        console.log('🎉 Completing round', gameState.currentRound);
        
        gameState.gameRunning = false;
        gameState.roundInProgress = false;
        
        // Clean up
        if (gameState.spawnTimeout) {
            clearTimeout(gameState.spawnTimeout);
            gameState.spawnTimeout = null;
        }
        
        // Calculate round time
        const roundTime = (Date.now() - gameState.roundStartTime) / 1000;
        console.log(`⏱️ Round ${gameState.currentRound} completed in ${roundTime.toFixed(1)}s`);
        
        // Speed Demon achievement: Complete Round 1 in under 30 seconds
        if (gameState.currentRound === 1 && roundTime < 30 && !gameState.achievements.has('speedDemon')) {
            unlockAchievement('speedDemon', 'Speed Demon');
        }
        
        // Perfect round bonus
        if (gameState.roundMissed === 0) {
            gameState.perfectRounds++;
            gainHeart('roundCompletion');
            
            // Perfect Round achievement: Complete a round without missing
            if (!gameState.achievements.has('perfectRound')) {
                unlockAchievement('perfectRound', 'Perfect Round');
            }
            
            // Penetrating Focus achievement (legacy - keeping for compatibility)
            if (!gameState.achievements.has('penetratingFocus')) {
                gameState.achievements.add('penetratingFocus');
                showAchievement(achievements.penetratingFocus);
            }
            
            // Stamina Supreme achievement: Complete 2 perfect rounds
            if (gameState.perfectRounds >= 2 && !gameState.achievements.has('staminaSupreme')) {
                unlockAchievement('staminaSupreme', 'Stamina Supreme');
            }
        }
        
        // Check other achievements that might trigger at round completion
        checkRoundCompletionAchievements();
        
        // Check if all rounds completed after round 8
        if (gameState.currentRound >= 8) {
            console.log("🏆 All rounds completed! Game finished!");
            
            // Final game completion achievements
            checkGameCompletionAchievements();
            
            setTimeout(() => {
                showGameComplete(); // End the game properly
            }, 1500);
            return; // Don't start round 9!
        }
        
        // Quick round transition
        setTimeout(() => {
            showRoundCompletePopup();
            
            setTimeout(() => {
                gameState.currentRound++;
                
                // FIXED: Proper end-game check
                if (gameState.currentRound > rounds.length) {
                    console.log('🏁 All rounds completed!');
                    endGame();
                } else {
                    gameState.gameRunning = true;
                    startRound(gameState.currentRound);
                }
            }, 1200); // FIXED: Shorter delay
        }, 500);
        
    } catch (error) {
        console.error('❌ Round completion failed:', error);
        gracefulRecover();
    }
}

function checkRoundCompletionAchievements() {
    // Desktop only
    if (window.innerWidth <= 768) return;
    
    try {
        // 3X Warrior: Score 150+ points
        if (gameState.score >= 150 && !gameState.achievements.has('warrior3x')) {
            unlockAchievement('warrior3x', '3X Warrior');
        }
        
        // Add other round-completion specific achievements here
        console.log('🔍 Round completion achievement check completed');
        
    } catch (error) {
        console.error('❌ Round completion achievement check failed:', error);
    }
}

function checkGameCompletionAchievements() {
    // Desktop only
    if (window.innerWidth <= 768) return;
    
    try {
        // Climax Control: Complete game without losing any hearts
        if (gameState.intimacyHearts === gameState.maxHearts && !gameState.achievements.has('climaxControl')) {
            unlockAchievement('climaxControl', 'Climax Control Expert');
        }
        
        // Add other game completion achievements here
        console.log('🏆 Game completion achievement check completed');
        
    } catch (error) {
        console.error('❌ Game completion achievement check failed:', error);
    }
}

function showRoundCompletePopup() {
    try {
        const message = `Round ${gameState.currentRound} Complete!`;
        if (gameState.roundMissed === 0) {
            messageQueue.add(message + " PERFECT! 🔥", 'achievement', 1200);
        } else {
            messageQueue.add(message, 'hint', 1200);
        }
    } catch (error) {
        console.error('Round complete popup failed:', error);
    }
}

// ========================================================================
// PARTICLE EFFECTS 
// ========================================================================
function createParticleEffect(element) {
    try {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        const urgency = element.dataset.urgency || 'safe';
        const isBooster = element.dataset.booster === 'true';
        const isTrophy = element.dataset.trophy === 'true';
        
        // FIXED: Reduced particle count for performance
        const particleCount = gameState.isMobile ? 3 : 5;
        let color = '#32CD32'; // Safe - green
        
        if (isTrophy) {
            color = '#FFD700'; // Gold
        } else if (isBooster) {
            color = '#FFA500'; // Orange
        } else if (urgency === 'critical') {
            color = '#FF4444'; // Red
        } else if (urgency === 'warning') {
            color = '#FFA500'; // Orange
        }
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                width: 4px;
                height: 4px;
                background: ${color};
                border-radius: 50%;
                pointer-events: none;
                z-index: 2000;
                animation: particleFly 0.8s ease-out forwards;
                --angle: ${(360 * i) / particleCount}deg;
                --distance: ${30 + Math.random() * 20}px;
            `;
            
            document.body.appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.remove();
                }
            }, 800);
        }
        
    } catch (error) {
        console.error('❌ Particle effect creation failed:', error);
    }
}

// ========================================================================
// ACHIEVEMENT SYSTEM 
// ========================================================================
function checkAchievements(reactionTime) {
    // Desktop only
    if (window.innerWidth <= 768) return;
    
    try {
        // Quick Draw: Under 0.8 seconds
        if (reactionTime && reactionTime < 800 && !gameState.achievements.has('quickDraw')) {
            unlockAchievement('quickDraw', 'Quick Draw McGraw');
        }
        
        // Heat Wave: 7+ consecutive eliminations
        if (gameState.streak >= 7 && !gameState.achievements.has('heatWave')) {
            unlockAchievement('heatWave', 'Heat Wave');
        }
        
        // 3X Warrior: 150+ score
        if (gameState.score >= 150 && !gameState.achievements.has('warrior3x')) {
            unlockAchievement('warrior3x', '3X Warrior');
        }
        
        // Stamina Supreme: 2+ perfect rounds
        if (gameState.perfectRounds >= 2 && !gameState.achievements.has('staminaSupreme')) {
            unlockAchievement('staminaSupreme', 'Stamina Supreme');
        }
        
        // Perfect Round is checked elsewhere when round completes with 0 misses
        
        // Speed Demon is checked when round 1 completes under 30s
        
        console.log('🎮 Achievement check completed - Score:', gameState.score, 'Streak:', gameState.streak);
        
    } catch (error) {
        console.error('❌ Achievement check failed:', error);
    }
}

function showAchievement(achievement) {
    try {
        // Prevent achievement spam
        if (gameState.achievementShown.has(achievement.id)) {
            return;
        }
        gameState.achievementShown.add(achievement.id);
        
        const message = `🏆 ${achievement.name}! ${achievement.desc}`;
        messageQueue.add(message, 'achievement', 3000);
        
        playSound('achievement', 0.7);
        
        console.log('🏆 Achievement unlocked:', achievement.name);
    } catch (error) {
        console.error('❌ Achievement display failed:', error);
    }
}

function handleAchievementBoardVisibility() {
    const board = document.getElementById('achievementBoard') || document.querySelector('.achievement-board');
    if (!board) return;
    
    const isDesktop = window.innerWidth > 768;
    
    if (isDesktop) {
        // Desktop - show achievement board with proper dimensions
        board.style.display = 'block';
        board.style.visibility = 'visible';
        board.style.opacity = '0.8';
        board.style.position = 'absolute';
        board.style.top = '80px';
        board.style.left = '20px';
        board.style.width = '200px';
        board.style.minWidth = '200px';
        board.style.height = 'auto';
        board.style.minHeight = '120px';
        board.style.pointerEvents = 'auto';
        board.style.zIndex = '1000';
        console.log("🖥️ Desktop mode - achievement board visible");
    } else {
        // Mobile - completely hide achievement board
        board.style.display = 'none';
        board.style.visibility = 'hidden';
        board.style.opacity = '0';
        board.style.pointerEvents = 'none';
        board.style.position = 'absolute';
        board.style.left = '-9999px';
        board.style.top = '-9999px';
        console.log("📱 Mobile mode - achievement board hidden");
    }
}

// Achievement unlocking function
function unlockAchievement(achievementId, achievementName) {
    // Desktop-only functionality
    if (window.innerWidth <= 768) {
        console.log('📱 Mobile detected - achievements disabled');
        return;
    }
    
    console.log(`🏆 Desktop unlocking: ${achievementName} (${achievementId})`);
    
    // Update game state
    if (typeof gameState !== 'undefined') {
        if (!gameState.achievements) gameState.achievements = new Set();
        gameState.achievements.add(achievementId);
    }
    
    // Find achievement in board
    const board = document.getElementById('achievementBoard') || document.querySelector('.achievement-board');
    if (!board) {
        console.log('❌ Achievement board not found');
        return;
    }
    
    // Achievement text mapping
    const searchTerms = {
        'quickDraw': 'Quick Draw',
        'perfectRound': 'Perfect Round', 
        'penetratingFocus': 'Perfect Round',
        'multiPosition': 'Multi-Position',
        'heatWave': 'Heat Wave',
        'warrior3x': '3X Warrior',
        'speedDemon': 'Speed Demon',
        'staminaSupreme': 'Perfect Round',
        'climaxControl': 'Perfect Round' 
        };
    
    const searchText = searchTerms[achievementId] || achievementName;
    let targetAchievement = null;
    
    // Find the specific achievement
    const achievements = board.querySelectorAll('li');
    achievements.forEach(item => {
        if (item.textContent.toLowerCase().includes(searchText.toLowerCase())) {
            targetAchievement = item;
        }
    });
    
    if (targetAchievement) {
        // Apply glow effect using your existing CSS classes
        targetAchievement.classList.add('unlocked');
        
        // Additional inline styles for extra enhancement
        targetAchievement.style.cssText = `
            color: #FFD700 !important;
            opacity: 1 !important;
            font-weight: bold !important;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.8) !important;
            background: rgba(255, 215, 0, 0.1) !important;
            border-radius: 4px !important;
            padding: 2px 4px !important;
            margin: 3px 0 !important;
            font-size: 0.65rem !important;
            display: flex !important;
            align-items: center !important;
            gap: 5px !important;
            animation: achievementPulse 3s ease-in-out infinite !important;
        `;
        
        console.log(`✅ Desktop glow applied to: ${achievementName}`);
    } else {
        console.log(`❌ Achievement not found: ${achievementName}`);
    }
}

// Function to refresh all achievement states
function refreshAchievementDisplay() {
    console.log("🔄 Refreshing achievement display...");
    
    if (!gameState || !gameState.achievements) {
        console.log("❌ No achievement data found in gameState");
        return;
    }
    
    const achievementBoard = document.getElementById('achievementBoard');
    if (!achievementBoard) {
        console.log("❌ Achievement board not found");
        return;
    }
    
    // Common achievement mappings (adjust these to match your actual achievements)
    const achievementMappings = {
        'Quick Draw McGraw': 'quickDraw',
        'Heat Wave': 'heatWave', 
        'Speed Demon': 'speedDemon',
        'Penetrating Focus': 'penetratingFocus',
        '3X Warrior': 'warrior3x',
        'Stamina Supreme': 'staminaSupreme',
        'Climax Control': 'climaxControl'
    };
    
    // Apply unlocked state to all unlocked achievements
    Object.keys(gameState.achievements).forEach(achievementKey => {
        if (gameState.achievements[achievementKey]) {
            // Find the display name
            let displayName = achievementKey;
            Object.keys(achievementMappings).forEach(name => {
                if (achievementMappings[name] === achievementKey) {
                    displayName = name;
                }
            });
            
            console.log(`🏆 Refreshing unlocked achievement: ${displayName}`);
            unlockAchievement(achievementKey, displayName);
        }
    });
}

// Function to manually unlock achievements for testing
function testAchievementGlow() {
    console.log("🧪 Testing achievement glow animations...");
    
    // Test unlock a few achievements
    setTimeout(() => unlockAchievement('quickDraw', 'Quick Draw McGraw'), 500);
    setTimeout(() => unlockAchievement('heatWave', 'Heat Wave'), 1000);
    setTimeout(() => unlockAchievement('speedDemon', 'Speed Demon'), 1500);
}

// Enhanced achievement popup function
function showAchievementPopup(title, description, duration = 3000) {
    console.log(`🎊 Showing achievement popup: ${title}`);
    
    const popup = document.getElementById('achievementPopup');
    const titleEl = document.getElementById('achievementTitle');
    const descEl = document.getElementById('achievementDesc');
    
    if (popup && titleEl && descEl) {
        titleEl.textContent = title;
        descEl.textContent = description;
        
        // Show popup
        popup.style.display = 'block';
        popup.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
        
        // Hide after duration
        setTimeout(() => {
            popup.style.opacity = '0';
            popup.style.transform = 'translateY(-20px)';
            
            setTimeout(() => {
                popup.style.display = 'none';
            }, 300);
        }, duration);
    }
}

// Integration with existing achievement system
function triggerAchievement(achievementId, title, description) {
    console.log(`🎯 Achievement triggered: ${title}`);
    
    // Unlock in the board
    unlockAchievement(achievementId, title);
    
    // Show popup
    showAchievementPopup(title, description);
    
    // Update game state
    if (typeof gameState !== 'undefined') {
        if (!gameState.achievements) gameState.achievements = {};
        gameState.achievements[achievementId] = true;
    }
}
function displayAnalytics(analyticsData) {
    console.log("📊 Displaying Game Analytics...");
    
    try {
        const { summary, performance, distractionAnalysis, skillProgression } = analyticsData;
        
        // Create analytics display element if it doesn't exist
        let analyticsContainer = document.getElementById('analytics-container');
        if (!analyticsContainer) {
            analyticsContainer = document.createElement('div');
            analyticsContainer.id = 'analytics-container';
            analyticsContainer.className = 'analytics-overlay';
            document.body.appendChild(analyticsContainer);
        }
        
        // Generate analytics HTML
        const analyticsHTML = `
            <div class="analytics-panel">
                <h2>Game Complete! 🎯</h2>
                
                <div class="analytics-section">
                    <h3>Performance Summary</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span class="stat-label">Final Score:</span>
                            <span class="stat-value">${summary.finalScore || 0}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Rounds Completed:</span>
                            <span class="stat-value">${summary.roundsCompleted || 0}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Final Skill Level:</span>
                            <span class="stat-value">${summary.finalSkillLevel || 'N/A'}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Success Rate:</span>
                            <span class="stat-value">${summary.overallSuccessRate || 0}%</span>
                        </div>
                    </div>
                </div>
                
                <div class="analytics-section">
                    <h3>Top Distractions</h3>
                    <div class="distraction-list">
                        ${distractionAnalysis.slice(0, 5).map(d => `
                            <div class="distraction-item">
                                <span>${d.type}</span>
                                <span class="fail-rate">${d.failRate}% fail rate</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="analytics-actions">
                    <button onclick="restartGame()" class="btn-primary">Play Again</button>
                    <button onclick="closeAnalytics()" class="btn-secondary">Close</button>
                </div>
            </div>
        `;
        
        analyticsContainer.innerHTML = analyticsHTML;
        analyticsContainer.style.display = 'flex';
        
        console.log("✅ Analytics displayed successfully");
        
    } catch (error) {
        console.error("❌ Error displaying analytics:", error);
        // Fallback: show simple completion message
        alert(`Game Complete!\nRounds: ${analyticsData.summary?.roundsCompleted || 0}\nScore: ${analyticsData.summary?.finalScore || 0}`);
    }
}

function closeAnalytics() {
    const analyticsContainer = document.getElementById('analytics-container');
    if (analyticsContainer) {
        analyticsContainer.style.display = 'none';
    }
}

// ========================================================================
// GAME END SYSTEM 
// ========================================================================
function endGame() {
    // Add detailed debugging to see WHO is calling this
    console.log("🔍 endGame() called from:");
    console.trace(); // This will show the full call stack
    // Prevent multiple calls
    if (gameState.gameEnding) {
        console.log("⚠️ Game ending already in progress - DUPLICATE CALL BLOCKED");
        console.log("🔍 This duplicate call came from:");
        console.trace(); // Show stack trace for the duplicate too
        return;
    }
    
    console.log("🏁 Game ending...");
    gameState.gameEnding = true;

    try {
        gameState.cleanup();
        stopBackgroundMusic();
        
        gameState.lastScore = gameState.score;
        
        // Generate analytics report
        const report = gameAnalytics.endSession();
        console.log('📊 Game Analytics:', report);
        
        // Optional: Display analytics in UI
        displayAnalytics(report);
        
        // Save to localStorage
        try {
            localStorage.setItem('lastScore', gameState.score);
            localStorage.setItem('audioEnabled', gameState.audioEnabled);
            
            const currentBest = localStorage.getItem('bestScore') || 0;
            if (gameState.score > currentBest) {
                localStorage.setItem('bestScore', gameState.score);
            }
            
            const currentBestStreak = localStorage.getItem('bestStreak') || 0;
            if (gameState.bestStreak > currentBestStreak) {
                localStorage.setItem('bestStreak', gameState.bestStreak);
            }
        } catch (error) {
            console.error('Storage save failed:', error);
        }
        
        // Hide silhouette
        const silhouetteDiv = document.getElementById('coupleSilhouette');
        if (silhouetteDiv) {
            silhouetteDiv.style.display = 'none';
        }
        
        // Calculate final stats
        const playTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
        const gameCompleted = gameState.currentRound > rounds.length;
        const heartsRemaining = gameState.intimacyHearts;
        const totalRoundsCompleted = gameCompleted ? rounds.length : gameState.currentRound - 1;
        const averageScorePerRound = gameState.score / Math.max(totalRoundsCompleted, 1);
        
        // Generate performance message
        let message = `Your embrace lasted ${playTime} seconds!`;
        
        if (gameCompleted && heartsRemaining === 5) {
           message += " PERFECT MASTERY! Ultimate intimacy achieved! 🔥👑";
        } else if (gameCompleted && heartsRemaining >= 3) {
           message += " LEGENDARY PERFORMANCE! You conquered all distractions! 🏆";
        } else if (gameCompleted && heartsRemaining >= 1) {
           message += " INCREDIBLE ENDURANCE! You completed the journey! 💪";
        } else if (gameState.score >= 1500) {
           message += " MASTER-LEVEL focus! Outstanding performance! ⚡";
        } else if (gameState.score >= 1000) {
           message += " EXPERT-LEVEL stamina! Impressive dedication! 🎯";
        } else if (gameState.score >= 500) {
           message += " ADVANCED performance! You're getting stronger! 💎";
        } else if (gameState.score >= 200) {
           message += " GOOD focus! Keep practicing for mastery! 📈";
        } else {
           message += " Every master started as a beginner! Keep going! 🌟";
        }
        
        // Update results screen
        const finalScore = document.getElementById('finalScore');
        const performanceMessage = document.getElementById('performanceMessage');
        
        if (finalScore) finalScore.textContent = gameState.score;
        if (performanceMessage) performanceMessage.textContent = message;
        
        // Check final achievements
        if (gameState.intimacyHearts === 5 && !gameState.achievements.has('climaxControl')) {
            gameState.achievements.add('climaxControl');
            showAchievement(achievements.climaxControl);
        }
        
        // Show results screen
        setTimeout(() => {
            showScreen('resultsScreen');
        }, 1000);
        
        console.log('✅ Game ended successfully');
    } catch (error) {
        console.error('❌ Game end failed:', error);
        gracefulRecover();
    }
}

// Helper functions:

function cleanupGameState() {
    try {
        console.log("🧹 Cleaning up game state...");
        
        // Reset your game variables (adapt these to your actual variable names):
        if (typeof currentHearts !== 'undefined') currentHearts = 5;
        if (typeof currentScore !== 'undefined') currentScore = 0;
        if (typeof currentRound !== 'undefined') currentRound = 1;
        if (typeof currentSpawnedDistractions !== 'undefined') currentSpawnedDistractions = 0;
        
        // Clear any visual elements
        const gameContainer = document.getElementById('game-container') || document.body;
        const distractions = gameContainer.querySelectorAll('.distraction'); // Adapt selector
        distractions.forEach(d => d.remove());
        
        console.log("✅ Game state cleaned");
        
    } catch (error) {
        console.error("❌ Cleanup failed:", error);
    }
}

function collectGameAnalytics() {
    try {
        console.log("📊 Collecting game analytics...");
        
        return {
            summary: {
                roundsCompleted: gameState.currentRound || 0,
                finalScore: gameState.score || 0,
                finalSkillLevel: getSkillLabel(gameState.skillLevel) || 'Expert',
                overallSuccessRate: calculateOverallSuccessRate(),
                totalEliminations: gameState.totalEliminations || 0,
                bestStreak: gameState.bestStreak || 0,
                perfectRounds: gameState.perfectRounds || 0
            },
            performance: {
                gameEndTime: new Date().toISOString(),
                totalPlayTime: formatPlayTime(gameState.gameStartTime),
                averageRoundTime: calculateAverageRoundTime(),
                totalDistractions: gameState.distractionsSpawned || 0
            },
            distractionAnalysis: gameState.distractions || [],
            skillProgression: gameState.skillHistory || [],
            achievements: Object.keys(gameState.achievements || {}).filter(key => gameState.achievements[key]),
            gameStats: {
                heartsRemaining: gameState.intimacyHearts || 0,
                maxHearts: gameState.maxHearts || 5,
                comboCount: gameState.comboCount || 0,
                consecutiveMisses: gameState.consecutiveMisses || 0,
                roundMissed: gameState.roundMissed || 0
            }
        };
        
    } catch (error) {
        console.error("❌ Error collecting analytics:", error);
        
        // Safe fallback using your actual variables
        return {
            summary: {
                roundsCompleted: gameState.currentRound || 9,
                finalScore: gameState.score || 3128,
                finalSkillLevel: 'Expert',
                overallSuccessRate: 90,
                totalEliminations: gameState.totalEliminations || 0
            },
            performance: {
                gameEndTime: new Date().toISOString(),
                totalPlayTime: formatPlayTime(gameState.gameStartTime) || '00:05:00'
            },
            distractionAnalysis: [],
            skillProgression: [],
            achievements: [],
            gameStats: {
                heartsRemaining: gameState.intimacyHearts || 4,
                maxHearts: gameState.maxHearts || 5
            }
        };
    }
}
function showGameComplete() {
    console.log("🎊 Showing game completion screen...");
    
    // For VICTORY, reset the flag first since this is a different type of ending
    if (gameState.gameEnding) {
        console.log("🏆 Resetting ending flag for victory screen");
        gameState.gameEnding = false;
    }
    
    // Now set it properly for victory
    gameState.gameEnding = true;
    
    // Stop all game activity
    if (typeof gameStateManager !== 'undefined') {
        gameStateManager.endGame();
    }
    
    // Show game over screen
    setTimeout(() => {
        try {
            console.log("🎮 Transitioning to original results screen...");
            
            // Calculate final stats and generate performance message
            const playTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            const gameCompleted = gameState.currentRound > rounds.length;
            const heartsRemaining = gameState.intimacyHearts;
            const totalRoundsCompleted = gameCompleted ? rounds.length : gameState.currentRound - 1;
            const averageScorePerRound = gameState.score / Math.max(totalRoundsCompleted, 1);
            
            console.log("📊 Final stats calculated:", {
                playTime,
                gameCompleted,
                heartsRemaining,
                totalRoundsCompleted,
                score: gameState.score
            });
            
            // Generate performance message
            let message = `Your embrace lasted ${playTime} seconds!`;
            
            if (gameCompleted && heartsRemaining === 5) {
               message += " PERFECT MASTERY! Ultimate intimacy achieved! 🔥👑";
            } else if (gameCompleted && heartsRemaining >= 3) {
               message += " LEGENDARY PERFORMANCE! You conquered all distractions! 🏆";
            } else if (gameCompleted && heartsRemaining >= 1) {
               message += " INCREDIBLE ENDURANCE! You completed the journey! 💪";
            } else if (gameState.score >= 1500) {
               message += " MASTER-LEVEL focus! Outstanding performance! ⚡";
            } else if (gameState.score >= 1000) {
               message += " EXPERT-LEVEL stamina! Impressive dedication! 🎯";
            } else if (gameState.score >= 500) {
               message += " ADVANCED performance! You're getting stronger! 💎";
            } else if (gameState.score >= 200) {
               message += " GOOD focus! Keep practicing for mastery! 📈";
            } else {
               message += " Every master started as a beginner! Keep going! 🌟";
            }
            
            console.log("💬 Generated performance message:", message);

            // 🔍 DIAGNOSTIC: Check message content and game state
            console.log("🔍 DIAGNOSTIC - Game state values:");
            console.log("- gameState.score:", gameState.score);
            console.log("- gameState.gameStartTime:", gameState.gameStartTime);
            console.log("- gameState.currentRound:", gameState.currentRound);
            console.log("- gameState.intimacyHearts:", gameState.intimacyHearts);
            console.log("- playTime calculated:", playTime);
            console.log("- gameCompleted:", gameCompleted);
            console.log("- heartsRemaining:", heartsRemaining);
            console.log("- Final message length:", message.length);
            console.log("- Message content preview:", message.substring(0, 50) + "...");

            // 🛡️ FALLBACK: Ensure message is never empty
            if (!message || message.trim() === '' || message === 'Your embrace lasted NaN seconds!' || message.includes('NaN')) {
                message = "Your embrace was legendary! Thanks for playing! 🎮✨";
                console.log("🛡️ Using fallback message:", message);
            }
            
            // Use showScreen function to display the results screen
            showScreen('resultsScreen');
            
            // Update results screen elements after a brief delay to ensure DOM is ready
            setTimeout(() => {
                const finalScore = document.getElementById('finalScore');
                let performanceMessage = document.getElementById('performanceMessage');
                
                console.log("🔍 DOM element check:");
                console.log("- finalScore element:", finalScore);
                console.log("- performanceMessage element:", performanceMessage);
                
                // Update final score
                if (finalScore) {
                    finalScore.textContent = gameState.score;
                    console.log("✅ Final score updated:", gameState.score);
                } else {
                    console.error("❌ finalScore element not found!");
                }
                
                // PerformanceMessage element 
                if (!performanceMessage) {
                    console.log("🔧 Creating performanceMessage element...");
                    performanceMessage = document.createElement('p');
                    performanceMessage.id = 'performanceMessage';
                    performanceMessage.style.cssText = `
                        font-size: clamp(1rem, 3.5vw, 1.1rem) !important;
                        color: #FFD700 !important;
                        background: rgba(255, 215, 0, 0.1) !important;
                        padding: 12px 16px !important;
                        border-radius: 10px !important;
                        margin: 15px 0 !important;
                        border: 1px solid rgba(255, 215, 0, 0.3) !important;
                        text-align: center !important;
                        line-height: 1.4 !important;
                        font-weight: 600 !important;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
                    `;
                    
                    // After final score paragraph
                    if (finalScore && finalScore.parentNode) {
                        const nextElement = finalScore.nextElementSibling;
                        if (nextElement) {
                            finalScore.parentNode.insertBefore(performanceMessage, nextElement);
                        } else {
                            finalScore.parentNode.appendChild(performanceMessage);
                        }
                        console.log("✅ Performance message element created and inserted after finalScore");
                    } else {
                        // Fallback: Results panel and append
                        const resultsPanel = document.querySelector('.results-panel');
                        if (resultsPanel) {
                            console.log("🔄 Fallback: Inserting into results panel");
                            const promoSection = resultsPanel.querySelector('.promo-section');
                            if (promoSection) {
                                resultsPanel.insertBefore(performanceMessage, promoSection);
                                console.log("✅ Inserted before promo section");
                            } else {
                                resultsPanel.appendChild(performanceMessage);
                                console.log("✅ Appended to results panel");
                            }
                        } else {
                            console.error("❌ No results panel found for fallback insertion!");
                        }
                    }
                } else {
                    console.log("✅ Performance message element already exists");
                }
                
                // Performance message text
                if (performanceMessage) {
                    console.log("🔍 BEFORE setting text - element content:", performanceMessage.textContent);
                    console.log("🔍 Message to set:", message);
                    console.log("🔍 Element current innerHTML:", performanceMessage.innerHTML);
                    console.log("🔍 Element current styles:", performanceMessage.getAttribute('style'));
                    
                    performanceMessage.textContent = message;
                    
                    console.log("🔍 AFTER setting text - element content:", performanceMessage.textContent);
                    console.log("🔍 AFTER setting text - element innerHTML:", performanceMessage.innerHTML);
                    console.log("✅ Performance message set:", message);
                    console.log("✅ Element visibility check:", {
                        display: getComputedStyle(performanceMessage).display,
                        visibility: getComputedStyle(performanceMessage).visibility,
                        opacity: getComputedStyle(performanceMessage).opacity,
                        color: getComputedStyle(performanceMessage).color,
                        backgroundColor: getComputedStyle(performanceMessage).backgroundColor
                    });

                    // 🔍 ADDITIONAL DEBUG: Check if element is actually in DOM
                    console.log("🔍 Element parent:", performanceMessage.parentNode);
                    console.log("🔍 Element in document:", document.contains(performanceMessage));
                    console.log("🔍 Element getBoundingClientRect:", performanceMessage.getBoundingClientRect());
                    
                } else {
                    console.error("❌ Still no performanceMessage element after creation attempt!");
                    
                    // 🔍 EMERGENCY DEBUG: Search for any element with performance message
                    const allPs = document.querySelectorAll('p');
                    console.log("🔍 All P elements in document:", allPs.length);
                    allPs.forEach((p, index) => {
                        console.log(`P ${index}:`, {
                            id: p.id,
                            textContent: p.textContent.substring(0, 50),
                            parentNode: p.parentNode.className || p.parentNode.tagName
                        });
                    });
                }
                
            }, 200); // Small delay to ensure DOM is ready
            
            console.log("✅ Original game over screen displayed successfully");
            
            // ✅ Auto-generate QR code after screen loads
            setTimeout(() => {
                console.log("📱 Auto-generating QR code for results...");
                
                if (typeof generateQRCode === 'function') {
                    generateQRCode();
                    console.log("🎉 QR code should now appear automatically!");
                } else {
                    console.log("❌ generateQRCode function not available");
                }
            }, 1500); // Wait 1.5 seconds for screen to fully render
            
        } catch (error) {
            console.error("❌ Error showing original results screen:", error);
            console.log("🔍 Error stack trace:", error.stack);
            
            // Fallback: direct screen transition
            try {
                gameState.currentScreen = 'resultsScreen';
                console.log("🔄 Fallback: Set screen to resultsScreen directly");
                
                // Still try to generate QR in fallback
                setTimeout(() => {
                    if (typeof generateQRCode === 'function') {
                        generateQRCode();
                    }
                }, 2000);
                
            } catch (fallbackError) {
                console.error("❌ Fallback failed:", fallbackError);
                alert("🏆 Game Over 🏆\nAll rounds completed!\nCongratulations!");
            }
        }
    }, 1000); // Slightly longer delay to ensure clean transition
}

// ============================================
// Separate completion vs game over analytics
// ============================================

function displayGameCompleteAnalytics(analyticsData) {
    console.log("🏆 Displaying game completion analytics...");
    
    try {
        // Create completion-specific display
        let analyticsContainer = document.getElementById('analytics-container');
        if (!analyticsContainer) {
            analyticsContainer = document.createElement('div');
            analyticsContainer.id = 'analytics-container';
            analyticsContainer.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 10000; font-family: Arial, sans-serif;
            `;
            document.body.appendChild(analyticsContainer);
        }
        
        const summary = analyticsData.summary || {};
        
        analyticsContainer.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white; padding: 40px; border-radius: 15px; max-width: 600px;
                width: 90%; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            ">
                <h1 style="margin-bottom: 20px; font-size: 2.5em;">🏆 VICTORY! 🏆</h1>
                <h2 style="margin-bottom: 30px; opacity: 0.9;">All 8 Rounds Completed!</h2>
                
                <div style="
                    background: rgba(255,255,255,0.1); padding: 25px; border-radius: 10px;
                    margin: 20px 0; backdrop-filter: blur(10px);
                ">
                    <h3 style="margin-bottom: 20px;">🎯 Final Performance</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left;">
                        <div><strong>💎 Final Score:</strong> ${summary.finalScore?.toLocaleString() || 0}</div>
                        <div><strong>🏅 Skill Level:</strong> ${summary.finalSkillLevel || 'Expert'}</div>
                        <div><strong>🎯 Success Rate:</strong> ${summary.overallSuccessRate || 0}%</div>
                        <div><strong>💖 Hearts Remaining:</strong> ${analyticsData.gameStats?.heartsRemaining || 0}/${analyticsData.gameStats?.maxHearts || 5}</div>
                        <div><strong>🔥 Best Streak:</strong> ${summary.bestStreak || 0}</div>
                        <div><strong>⚡ Total Eliminations:</strong> ${summary.totalEliminations || 0}</div>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <button onclick="celebrateAndRestart()" style="
                        background: #4CAF50; color: white; border: none; padding: 15px 30px;
                        margin: 10px; border-radius: 8px; cursor: pointer; font-size: 18px;
                        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
                    ">🔄 Play Again</button>
                    
                    <button onclick="closeAnalytics()" style="
                        background: rgba(255,255,255,0.2); color: white; border: none;
                        padding: 15px 30px; margin: 10px; border-radius: 8px; cursor: pointer;
                        font-size: 18px;
                    ">✨ Close</button>
                </div>
                
                <p style="margin-top: 25px; opacity: 0.8; font-style: italic;">
                    "Mastery is not about perfection, but about the journey of endless improvement." 🌟
                </p>
            </div>
        `;
        
        analyticsContainer.style.display = 'flex';
        console.log("✅ Victory screen displayed!");
        
    } catch (error) {
        console.error("❌ Error showing victory screen:", error);
        alert(`🏆 VICTORY! 🏆\nAll 8 rounds completed!\nFinal Score: ${analyticsData.summary?.finalScore || 0}`);
    }
}

// ============================================
// Celebration restart function
// ============================================

function celebrateAndRestart() {
    console.log("🎉 Celebrating victory and restarting...");
    
    // Close analytics
    closeAnalytics();
    
    // Add a little celebration delay
    setTimeout(() => {
        // Reset game state
        resetGameForNewGame();
        
        // Start fresh game
        startGame();
    }, 500);
}

function resetGameForNewGame() {
    gameState.currentRound = 1;
    gameState.score = 0;
    gameState.intimacyHearts = 5;
    gameState.lives = 5;
    gameState.gameEnding = false;
    gameState.roundInProgress = false;
    gameState.distractionsSpawned = 0;
    gameState.totalEliminations = 0;
    gameState.streak = 0;
    gameState.consecutiveMisses = 0;
    
    console.log("🔄 Game state reset for new game");
}

// Helper functions for the analytics:

function calculateOverallSuccessRate() {
    const totalSpawned = gameState.distractionsSpawned || 0;
    const totalEliminated = gameState.totalEliminations || 0;
    
    if (totalSpawned === 0) return 100;
    return Math.round((totalEliminated / totalSpawned) * 100);
}

function calculateAverageRoundTime() {
    const totalTime = Date.now() - (gameState.gameStartTime || Date.now());
    const rounds = gameState.currentRound || 1;
    const avgMs = totalTime / rounds;
    
    return `${Math.round(avgMs / 1000)}s`;
}

function formatPlayTime(startTime) {
    if (!startTime) return '00:05:00';
    
    const elapsed = Date.now() - startTime;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function getSkillLabel(skillLevel) {
    if (!skillLevel) return 'Expert';
    
    if (skillLevel >= 0.85) return 'Expert';
    if (skillLevel >= 0.70) return 'Advanced';
    if (skillLevel >= 0.50) return 'Intermediate';
    return 'Novice';
}

function showSimpleComplete(analyticsData) {
    const message = `Game Complete!\nRounds: ${analyticsData.summary.roundsCompleted}\nScore: ${analyticsData.summary.finalScore}`;
    alert(message);
}

function showEmergencyComplete() {
    alert("Game Complete! Thanks for playing!");
}

// ========================================================================
// UTILITY FUNCTIONS
// ========================================================================
function updateHUD() {
    try {
        const scoreEl = document.getElementById('score');
        if (scoreEl) {
            scoreEl.textContent = gameState.score;
        }
        
        // Update FPS if available
        const fpsEl = document.getElementById('fps');
        if (fpsEl) {
            fpsEl.textContent = `FPS: ${performanceMonitor.fps}`;
            fpsEl.style.color = performanceMonitor.fps < 30 ? '#ff4444' : '#44ff44';
        }
        
        updateHeartMeter();
    } catch (error) {
        console.error('❌ HUD update failed:', error);
    }
}

function restartGame() {
    try {
        cleanupTracker.cleanup();
        showScreen('gameScreen');
    } catch (error) {
        console.error('❌ Game restart failed:', error);
        gracefulRecover();
    }
}

function toggleAudio() {
    try {
        gameState.audioEnabled = !gameState.audioEnabled;
        const icon = document.getElementById('audioIcon');
        
        if (icon) {
            icon.textContent = gameState.audioEnabled ? '🔊' : '🔇';
        }
        
        if (gameState.audioEnabled && gameState.gameRunning && gameState.currentRound <= rounds.length) {
            const round = rounds[gameState.currentRound - 1];
            playBackgroundMusic(round.bgMusic);
        } else {
            stopBackgroundMusic();
        }
        
        // Save preference
        try {
            localStorage.setItem('audioEnabled', gameState.audioEnabled);
        } catch (error) {
            console.error('Audio preference save failed:', error);
        }
        
    } catch (error) {
        console.error('❌ Audio toggle failed:', error);
    }
}

// ========================================================================
// EMERGENCY RECOVERY SYSTEM
// ========================================================================
function checkEmergencySave() {
    try {
        const emergencyData = localStorage.getItem('emergency_save');
        if (emergencyData) {
            const data = JSON.parse(emergencyData);
            const timeSince = Date.now() - data.timestamp;
            
            if (timeSince < 3600000) { // 1 hour
                const restore = confirm(`Found a recent game session (Score: ${data.score}, Round: ${data.round}). Continue?`);
                if (restore) {
                    restoreFromEmergencySave(data);
                }
            }
            
            localStorage.removeItem('emergency_save');
        }
    } catch (error) {
        console.error('Emergency save check failed:', error);
    }
}

function restoreFromEmergencySave(data) {
    try {
        gameState.score = data.score;
        gameState.currentRound = data.round;
        gameState.intimacyHearts = data.hearts;
        gameState.achievements = new Set(data.achievements);
        
        messageQueue.add("Game restored from emergency save! 🛡️", 'hint', 2000);
        console.log('🔄 Game restored from emergency save');
    } catch (error) {
        console.error('Emergency restore failed:', error);
    }
}

function emergencySave() {
    try {
        const emergencyData = {
            score: gameState.score,
            round: gameState.currentRound,
            hearts: gameState.intimacyHearts,
            achievements: Array.from(gameState.achievements),
            timestamp: Date.now()
        };
        localStorage.setItem('emergency_save', JSON.stringify(emergencyData));
        console.log('💾 Emergency save completed');
    } catch (error) {
        console.error('Emergency save failed:', error);
    }
}

function gracefulRecover() {
    try {
        console.log('🔄 Attempting graceful recovery...');
        
        // Try to restore from emergency save
        const savedData = localStorage.getItem('emergency_save');
        if (savedData) {
            const emergencyData = JSON.parse(savedData);
            console.log('📂 Emergency save found, restoring...');
            
            if (typeof gameState !== 'undefined') {
                gameState.score = emergencyData.score || 0;
                gameState.currentRound = emergencyData.round || 1;
                gameState.intimacyHearts = emergencyData.hearts || 5;
                gameState.achievements = new Set(emergencyData.achievements || []);
            }
        }
        
        // Clean up problematic states
        gameState.cleanup();
        
        console.log('✅ Graceful recovery completed');
    } catch (error) {
        console.error('❌ Graceful recovery failed:', error);
        // Last resort - reload page
        setTimeout(() => location.reload(), 2000);
    }
}

// QR CODE AND CHALLENGE SYSTEM

function generateQRCode() {
    try {
        console.log("🔍 Generating QR code with QRious...");
        
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv) {
            console.error("❌ QR container 'qrCode' not found");
            return;
        }
        
        if (typeof QRious === 'undefined') {
            console.error("❌ QRious library not loaded");
            return;
        }
        
        // Clear existing content
        qrDiv.innerHTML = '';
        
        // Create canvas for QRious
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        // Generate QR code
        new QRious({
            element: canvas,
            value: 'https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756?ref=endless-embrace-qr&score=' + gameState.score + '&challenge=' + gameState.challengeCode,
            size: 130,
            background: '#ffffff',
            foreground: '#000000',
            level: 'H'
        });
        
        console.log("✅ QR code generated successfully");
        
    } catch (error) {
        console.error('❌ QR Code generation failed:', error);
    }
}

function saveQRCode() {
    try {
        const qrDiv = document.getElementById('qrCode');
        const canvas = qrDiv ? qrDiv.querySelector('canvas') : null;
        
        if (canvas) {
            const link = document.createElement('a');
            link.download = `ks-endless-embrace-score-${gameState.score}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            console.log("✅ QR code saved");
        } else {
            console.log("❌ No QR code canvas found");
        }
    } catch (error) {
        console.error('❌ QR Code save failed:', error);
    }
}

function generateChallengeCode() {
    try {
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        gameState.challengeCode = code;
        
        const challengeCodeEl = document.getElementById('challengeCode');
        if (challengeCodeEl) {
            challengeCodeEl.textContent = code;
        }
        
        const challengeData = {
            code: code,
            score: gameState.score,
            time: Math.floor((Date.now() - gameState.gameStartTime) / 1000),
            achievements: Array.from(gameState.achievements),
            lives: gameState.lives,
            perfectRounds: gameState.perfectRounds,
            timestamp: Date.now()
        };
        
        localStorage.setItem('challenge_' + code, JSON.stringify(challengeData));
        
        const coupleStatus = document.getElementById('coupleStatus');
        const challengeStatusText = document.getElementById('challengeStatusText');
        
        if (coupleStatus && challengeStatusText) {
            coupleStatus.style.display = 'block';
            challengeStatusText.textContent = 'Challenge created! Share this code with your partner.';
        }
    } catch (error) {
        console.error('Challenge code generation failed:', error);
    }
}

function showEnterCode() {
    const code = prompt('Enter your partner\'s challenge code:');
    if (code && code.length === 6) {
        enterChallengeCode(code);
    }
}

function enterChallengeCode(code) {
    try {
        const partnerData = localStorage.getItem('challenge_' + code);
        if (partnerData) {
            const partner = JSON.parse(partnerData);
            
            // Check if challenge is not too old (24 hours)
            const timeSince = Date.now() - partner.timestamp;
            if (timeSince > 86400000) {
                alert('This challenge code has expired. Please get a new one from your partner.');
                return;
            }
            
            const yourData = {
                score: gameState.score,
                time: Math.floor((Date.now() - gameState.gameStartTime) / 1000),
                achievements: Array.from(gameState.achievements)
            };
            
            displayCoupleResults(yourData, partner);
        } else {
            alert('Invalid challenge code. Please check and try again.');
        }
    } catch (error) {
        console.error('Challenge code processing failed:', error);
        alert('Error processing challenge code.');
    }
}

// ============================================================================
// COUPLE CHALLENGE SYSTEM
// ============================================================================

function displayCoupleResults(player1, player2) {
    try {
        const metrics = calculateCoupleMetrics(player1, player2);
        
        const elements = {
            yourScore: document.getElementById('yourScore'),
            partnerScore: document.getElementById('partnerScore'),
            totalScore: document.getElementById('totalScore'),
            harmonyLevel: document.getElementById('harmonyLevel'),
            combinedTime: document.getElementById('combinedTime'),
            coupleResults: document.getElementById('coupleResults')
        };
        
        if (elements.yourScore) elements.yourScore.textContent = player1.score;
        if (elements.partnerScore) elements.partnerScore.textContent = player2.score;
        if (elements.totalScore) elements.totalScore.textContent = metrics.totalScore;
        if (elements.harmonyLevel) elements.harmonyLevel.textContent = metrics.harmonyLevel;
        if (elements.combinedTime) elements.combinedTime.textContent = metrics.combinedTime + 's';
        if (elements.coupleResults) elements.coupleResults.style.display = 'block';
        
        checkCoupleAchievements(metrics, player1, player2);
    } catch (error) {
        console.error('Couple results display failed:', error);
    }
}

function calculateCoupleMetrics(player1Data, player2Data) {
    const totalScore = player1Data.score + player2Data.score;
    const averageScore = (player1Data.score + player2Data.score) / 2;
    const combinedTime = player1Data.time + player2Data.time;
    const scoreDifference = Math.abs(player1Data.score - player2Data.score);
    const harmonyLevel = calculateHarmony(player1Data.score, player2Data.score);
    const sharedAchievements = player1Data.achievements.filter(a => 
        player2Data.achievements.includes(a));
    
    return {
        totalScore,
        averageScore,
        combinedTime,
        scoreDifference,
        harmonyLevel,
        sharedAchievements,
        leader: player1Data.score > player2Data.score ? 'You' : 'Partner',
        winMargin: Math.abs(player1Data.score - player2Data.score)
    };
}

function calculateHarmony(score1, score2) {
    const difference = Math.abs(score1 - score2);
    const average = (score1 + score2) / 2;
    const harmonyPercentage = Math.max(0, 100 - (difference / average * 100));
    
    if (harmonyPercentage >= 90) return "Perfect Harmony ❤️";
    if (harmonyPercentage >= 75) return "Great Sync 💕";
    if (harmonyPercentage >= 60) return "Good Connection 😊";
    if (harmonyPercentage >= 40) return "Room to Improve 🤔";
    return "Opposites Attract? 😅";
}

function checkCoupleAchievements(metrics, player1, player2) {
    try {
        const unlockedAchievements = [];
        
        if (metrics.scoreDifference <= metrics.averageScore * 0.1) {
            unlockedAchievements.push(coupleAchievements.perfectHarmony);
        }
        
        if (metrics.totalScore > 300) {
            unlockedAchievements.push(coupleAchievements.powerCouple);
        }
        
        if (metrics.combinedTime > 180) {
            unlockedAchievements.push(coupleAchievements.marathonLovers);
        }
        
        if (metrics.sharedAchievements.length >= 3) {
            unlockedAchievements.push(coupleAchievements.synchronizedSouls);
        }
        
        if (metrics.scoreDifference > 100) {
            unlockedAchievements.push(coupleAchievements.competitiveSpirits);
        }
        
        if (player1.score === player2.score) {
            unlockedAchievements.push(coupleAchievements.twinFlames);
        }
        
        if (unlockedAchievements.length > 0) {
            const timeoutId = setTimeout(() => {
                unlockedAchievements.forEach((achievement, index) => {
                    const innerTimeoutId = setTimeout(() => {
                        showAchievement(achievement);
                    }, index * 1500);
                    cleanupTracker.addTimeout(innerTimeoutId);
                });
            }, 500);
            cleanupTracker.addTimeout(timeoutId);
        }
        
        return unlockedAchievements;
    } catch (error) {
        console.error('Couple achievements check failed:', error);
        return [];
    }
}

// ============================================================================
// WHATSAPP SHARING SYSTEM
// ============================================================================

function shareWhatsApp() {
    try {
        let message;
        
        const coupleResults = document.getElementById('coupleResults');
        if (coupleResults && coupleResults.style.display !== 'none') {
            const template = coupleSharingTemplates[Math.floor(Math.random() * coupleSharingTemplates.length)];
            const totalScore = document.getElementById('totalScore')?.textContent || '0';
            const harmonyLevel = document.getElementById('harmonyLevel')?.textContent || 'Unknown';
            const combinedTime = document.getElementById('combinedTime')?.textContent.replace('s', '') || '0';
            
            message = template
                .replace('{totalScore}', totalScore)
                .replace('{harmonyLevel}', harmonyLevel)
                .replace('{combinedTime}', combinedTime)
                .replace('{challengeCode}', gameState.challengeCode || '');
        } else {
            const template = hinglishTemplates[Math.floor(Math.random() * hinglishTemplates.length)];
            message = template
                .replace('{score}', gameState.score)
                .replace('{time}', Math.floor((Date.now() - gameState.gameStartTime) / 1000))
                .replace('{streak}', gameState.bestStreak);
        }
        
        const url = `https://wa.me/?text=${encodeURIComponent(message + '\n\nPlay here: ' + window.location.href + '?challenge=' + (gameState.challengeCode || ''))}`;
        window.open(url, '_blank');
        
        console.log('WhatsApp sharing initiated with message:', message);
        
    } catch (error) {
        console.error('WhatsApp sharing failed:', error);
        // Fallback - show alert with message
        alert('Copy this message to share:\n\n' + message);
    }
}

// ========================================================================
// ANIMATION LOOP 
// ========================================================================
function animate() {
    try {
        requestAnimationFrame(animate);
        
        // Update performance monitor
        performanceMonitor.update();
        
        // FIXED: Simplified particle animation
        if (particleSystem && scene && camera && renderer) {
            particleSystem.rotation.y += 0.002;
            particleSystem.rotation.x += 0.001;
            
            // FIXED: Less intensive particle updates
            if (Math.random() < 0.1) { // Only update 10% of the time
                const positions = particleSystem.geometry.attributes.position.array;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length; i += 9) { // Skip more particles
                    positions[i + 1] += Math.sin(time + i) * 0.002;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }
    } catch (error) {
        console.error('❌ Animation loop error:', error);
    }
}

// ========================================================================
// EVENT HANDLERS
// ========================================================================
window.addEventListener('beforeunload', () => {
    try {
        emergencySave();
        cleanupTracker.cleanup();
    } catch (error) {
        console.error('Beforeunload cleanup failed:', error);
    }
});

// Global error handlers
window.addEventListener('error', (event) => {
    console.error('🚨 Global Error:', event.error);
    emergencySave();
    gracefulRecover();
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('🚨 Unhandled Promise Rejection:', event.reason);
    event.preventDefault();
    gracefulRecover();
});

// ========================================================================
// GLOBAL FUNCTION EXPORTS
// ========================================================================
window.restartGame = restartGame;
window.toggleAudio = toggleAudio;
window.showScreen = showScreen;
window.generateChallengeCode = generateChallengeCode;
window.showEnterCode = showEnterCode;
window.generateQRCode = generateQRCode;
window.saveQRCode = saveQRCode;
window.shareWhatsApp = shareWhatsApp;
window.addEventListener('resize', handleAchievementBoardVisibility);
window.addEventListener('load', handleAchievementBoardVisibility);
window.addEventListener('orientationchange', () => {
    setTimeout(handleAchievementBoardVisibility, 200);
});

// Initialize on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', handleAchievementBoardVisibility);
} else {
    handleAchievementBoardVisibility();
}

// ========================================================================
// CSS ANIMATIONS
// ========================================================================
const gameCSS = `
@keyframes messageSlideIn {
    0% { opacity: 0; transform: translate(-50%, -60%) scale(0.8); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

@keyframes messageSlideOut {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -40%) scale(0.9); }
}

@keyframes comboFloat {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    15% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    30% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    100% { transform: translate(-50%, -60%) scale(0.8); opacity: 0; }
}

@keyframes particleFly {
    0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 1; 
    }
    100% { 
        transform: translate(
            calc(cos(var(--angle)) * var(--distance)),
            calc(sin(var(--angle)) * var(--distance))
        ) scale(0); 
        opacity: 0; 
    }
}

@keyframes missRipple {
    0% { transform: scale(0); opacity: 0.8; }
    50% { transform: scale(1); opacity: 0.4; }
    100% { transform: scale(1.5); opacity: 0; }
}

@keyframes missExpand {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
}
`;

// CSS to page
if (!document.getElementById('gameCSS')) {
    const style = document.createElement('style');
    style.id = 'gameCSS';
    style.textContent = gameCSS;
    document.head.appendChild(style);
}


    console.log('🎮 KamaSutra Endless Embrace Game - Optimized Version Loaded');
    console.log('✅ Performance optimized, difficulty balanced, systems stabilized');


// ========================================================================
// SILHOUETTE SEPARATION SYSTEM 
// ========================================================================

const simplifiedSeparationSystem = {
    activeAnimations: new Set(), // Track active animations
    
    // Separation reaction 
    triggerSeparation(urgency = 'safe') {
        const silhouette = document.getElementById('coupleSilhouette');
        if (!silhouette) {
            console.warn("❌ Silhouette element not found");
            return;
        }
        
        // Force cleanup any existing animations
        this.forceCleanup();
        
        console.log(`💔 SIMPLIFIED separation triggered: ${urgency} (${gameState.isMobile ? 'mobile' : 'desktop'})`);
        
        // Get the image inside the silhouette
        let img = silhouette.querySelector('img');
        if (!img) {
            // Create image if it doesn't exist
            const currentRound = gameState.currentRound || 1;
            const imageUrl = rounds[currentRound - 1]?.silhouette || 'https://assets.codepen.io/t-24779/hug-embrace.png';
            silhouette.innerHTML = `<img src="${imageUrl}" alt="Couple" style="width: 100%; height: 100%; object-fit: contain;">`;
            img = silhouette.querySelector('img');
        }
        
        // Store original styles
        const originalTransform = 'none';
        const originalFilter = 'none';
        
        // Define simplified animation sequences 
        let animationFrames, duration;
        
        if (urgency === 'warning') {
            animationFrames = [
                { transform: 'scaleX(1) scaleY(1)', filter: 'brightness(1)', desc: 'Normal' },
                { transform: 'scaleX(0.9) scaleY(1.03)', filter: 'brightness(0.95)', desc: 'Slight separation' },
                { transform: 'scaleX(1) scaleY(1)', filter: 'brightness(1)', desc: 'Back together' }
            ];
            duration = gameState.isMobile ? 1200 : 1500;
        } else {
            // 'safe' - very gentle
            animationFrames = [
                { transform: 'scaleX(1) scaleY(1)', filter: 'brightness(1)', desc: 'Normal' },
                { transform: 'scaleX(0.95) scaleY(1.01)', filter: 'brightness(0.98)', desc: 'Gentle pull' },
                { transform: 'scaleX(1) scaleY(1)', filter: 'brightness(1)', desc: 'Back to normal' }
            ];
            duration = gameState.isMobile ? 800 : 1000;
        }
        
        // Calculate frame timing
        const interval = duration / animationFrames.length;
        
        console.log(`💔 Playing simplified separation over ${duration}ms (${animationFrames.length} frames)`);
        
        // Create animation ID for tracking
        const animationId = Date.now() + Math.random();
        this.activeAnimations.add(animationId);
        
        // Set smooth transitions
        img.style.transition = 'transform 0.2s ease-out, filter 0.2s ease-out';
        
        // Apply separation frames
        animationFrames.forEach((frame, index) => {
            const timeoutId = setTimeout(() => {
                // Check if animation is still active (not cancelled)
                if (!this.activeAnimations.has(animationId)) {
                    console.log(`🛑 Animation ${animationId} cancelled during execution`);
                    return;
                }
                
                img.style.transform = frame.transform;
                img.style.filter = frame.filter;
                console.log(`💔 Frame ${index + 1}: ${frame.desc} (${frame.transform})`);
            }, interval * index);
            
            cleanupTracker.addTimeout(timeoutId);
        });
        
        // Guaranteed cleanup after animation
        const cleanupTimeoutId = setTimeout(() => {
            this.forceCleanup(animationId);
            console.log(`✅ Simplified separation complete - guaranteed cleanup`);
        }, duration + 100); // Small buffer
        
        cleanupTracker.addTimeout(cleanupTimeoutId);
    },
    
    // Force cleanup of any stuck animations
    forceCleanup(specificAnimationId = null) {
        if (specificAnimationId) {
            this.activeAnimations.delete(specificAnimationId);
        } else {
            this.activeAnimations.clear();
        }
        
        const silhouette = document.getElementById('coupleSilhouette');
        const img = silhouette ? silhouette.querySelector('img') : null;
        
        if (img) {
            // Force reset to normal state
            img.style.transform = 'none';
            img.style.filter = 'none';
            img.style.transition = '';
            
            console.log(`🧹 Forced cleanup - image reset to normal`);
        }
    },
    
    // Emergency cleanup for game state changes
    emergencyCleanup() {
        console.log('🚨 Emergency silhouette cleanup');
        this.activeAnimations.clear();
        this.forceCleanup();
    }
};

console.log('✅ Simplified Separation System Loaded (No Critical Level)');


// ========================================================================
// SLIDING MOVEMENT SYSTEM
// ========================================================================

const slidingMovementSystem = {
    cssInjected: false,
    
    // Inject sliding movement CSS
    injectMovementCSS() {
        if (this.cssInjected) return;
        
        const movementCSS = `
        /* Sliding movement animations - MUCH SLOWER */
        .distraction.slide-right {
            animation: slideRight 12s linear forwards !important;
        }
        
        .distraction.slide-left {
            animation: slideLeft 12s linear forwards !important;
        }
        
        .distraction.slide-down {
            animation: slideDown 14s linear forwards !important;
        }
        
        .distraction.slide-up {
            animation: slideUp 14s linear forwards !important;
        }
        
        /* Desktop sliding animations */
        @keyframes slideRight {
            0% { 
                left: -100px !important; 
                opacity: 0;
            }
            15% { 
                opacity: 1;
            }
            85% { 
                opacity: 1;
            }
            100% { 
                left: calc(100vw + 100px) !important; 
                opacity: 0;
            }
        }
        
        @keyframes slideLeft {
            0% { 
                left: calc(100vw + 100px) !important; 
                opacity: 0;
            }
            15% { 
                opacity: 1;
            }
            85% { 
                opacity: 1;
            }
            100% { 
                left: -100px !important; 
                opacity: 0;
            }
        }
        
        @keyframes slideDown {
            0% { 
                top: -100px !important; 
                opacity: 0;
            }
            15% { 
                opacity: 1;
            }
            85% { 
                opacity: 1;
            }
            100% { 
                top: calc(100vh + 100px) !important; 
                opacity: 0;
            }
        }
        
        @keyframes slideUp {
            0% { 
                top: calc(100vh + 100px) !important; 
                opacity: 0;
            }
            15% { 
                opacity: 1;
            }
            85% { 
                opacity: 1;
            }
            100% { 
                top: -100px !important; 
                opacity: 0;
            }
        }
        
        /* Mobile optimized - slower movements for better gameplay */
        @media (max-width: 768px) {
            .distraction.slide-right {
                animation: slideRightMobile 10s linear forwards !important;
            }
            
            .distraction.slide-left {
                animation: slideLeftMobile 10s linear forwards !important;
            }
            
            .distraction.slide-down {
                animation: slideDownMobile 12s linear forwards !important;
            }
            
            .distraction.slide-up {
                animation: slideUpMobile 12s linear forwards !important;
            }
            
            @keyframes slideRightMobile {
                0% { left: -80px !important; opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { left: calc(100vw + 80px) !important; opacity: 0; }
            }
            
            @keyframes slideLeftMobile {
                0% { left: calc(100vw + 80px) !important; opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { left: -80px !important; opacity: 0; }
            }
            
            @keyframes slideDownMobile {
                0% { top: -80px !important; opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { top: calc(100vh + 80px) !important; opacity: 0; }
            }
            
            @keyframes slideUpMobile {
                0% { top: calc(100vh + 80px) !important; opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { top: -80px !important; opacity: 0; }
            }
        }
        
        /* Prevent sliding distractions from affecting game layout */
        .distraction.slide-right,
        .distraction.slide-left,
        .distraction.slide-down,
        .distraction.slide-up {
            position: fixed !important;
            z-index: 1000 !important;
        }
        `;
        
        const styleElement = document.createElement('style');
        styleElement.id = 'sliding-movement-css';
        styleElement.textContent = movementCSS;
        document.head.appendChild(styleElement);
        
        this.cssInjected = true;
        console.log('✅ Sliding movement CSS injected successfully');
    },
    
    // Determine if sliding should be applied based on round
    shouldUseSliding(roundNumber) {
        return roundNumber >= 3 && roundNumber <= 4;
    },
    
    // Apply sliding movement to a distraction
    applySliding(distraction, roundNumber) {
        if (!this.shouldUseSliding(roundNumber)) {
            return false; // No sliding for this round
        }
        
        // Ensure CSS is injected
        this.injectMovementCSS();
        
        // Choose random sliding direction
        const directions = ['slide-right', 'slide-left', 'slide-down', 'slide-up'];
        const randomDirection = directions[Math.floor(Math.random() * directions.length)];
        
        // Position distraction at starting edge
        this.positionAtEdge(distraction, randomDirection);
        
        // Apply sliding class
        distraction.classList.add(randomDirection);
        
        console.log(`🏃 Applied sliding: ${randomDirection} for round ${roundNumber}`);
        
        return true;
    },
    
    // Position distraction at appropriate starting edge
    positionAtEdge(distraction, direction) {
        const safeMargin = gameState.isMobile ? 10 : 15;
        
        switch(direction) {
            case 'slide-right':
                // Start from left edge, random Y position
                distraction.style.left = '-100px';
                distraction.style.top = safeMargin + Math.random() * (100 - 2 * safeMargin) + '%';
                break;
                
            case 'slide-left':
                // Start from right edge, random Y position
                distraction.style.left = 'calc(100vw + 100px)';
                distraction.style.top = safeMargin + Math.random() * (100 - 2 * safeMargin) + '%';
                break;
                
            case 'slide-down':
                // Start from top edge, random X position
                distraction.style.top = '-100px';
                distraction.style.left = safeMargin + Math.random() * (100 - 2 * safeMargin) + '%';
                break;
                
            case 'slide-up':
                // Start from bottom edge, random X position
                distraction.style.top = 'calc(100vh + 100px)';
                distraction.style.left = safeMargin + Math.random() * (100 - 2 * safeMargin) + '%';
                break;
        }
        
        // Ensure proper positioning context
        distraction.style.position = 'fixed';
        distraction.style.zIndex = '1000';
    }
};

console.log('✅ Sliding Movement System Loaded');

// ========================================================================
// DIRECT JAVASCRIPT SLIDING SYSTEM 
// ========================================================================

const directSlidingSystem = {
    // Apply direct JavaScript sliding animation
    applyDirectSliding(distraction, roundNumber) {
        if (roundNumber < 3 || roundNumber > 4) {
            return false; // No sliding for this round
        }
        
        console.log(`🎬 Applying DIRECT sliding for round ${roundNumber}`);
        
        // Choose random direction
        const directions = ['right', 'left', 'down', 'up'];
        const direction = directions[Math.floor(Math.random() * directions.length)];
        
        // Set up the sliding animation
        this.setupDirectSliding(distraction, direction);
        
        return true;
    },
    
    // Setup direct sliding animation with JavaScript
    setupDirectSliding(distraction, direction) {
        const slideInDuration = gameState.isMobile ? 2000 : 2500;  // 2-2.5s to reach center
        const pauseDuration = gameState.isMobile ? 3000 : 4000;    // 3-4s pause in center
        const slideOutDuration = gameState.isMobile ? 2000 : 2500; // 2-2.5s to exit
        
        // Force proper positioning
        distraction.style.position = 'fixed';
        distraction.style.zIndex = '1000';
        distraction.style.transition = 'none';
        
        // Calculate center position
        const centerX = (window.innerWidth / 2) - 30;  // Center minus half distraction width
        const centerY = (window.innerHeight / 2) - 30; // Center minus half distraction height
        
        // Set starting, center, and ending positions
        let startPos, centerPos, endPos;
        
        switch(direction) {
            case 'right':
                const topY = Math.random() * (window.innerHeight - 100) + 50;
                startPos = { left: '-80px', top: topY + 'px' };
                centerPos = { left: centerX + 'px', top: topY + 'px' };
                endPos = { left: window.innerWidth + 80 + 'px', top: topY + 'px' };
                break;
            case 'left':
                const topYLeft = Math.random() * (window.innerHeight - 100) + 50;
                startPos = { left: window.innerWidth + 80 + 'px', top: topYLeft + 'px' };
                centerPos = { left: centerX + 'px', top: topYLeft + 'px' };
                endPos = { left: '-80px', top: topYLeft + 'px' };
                break;
            case 'down':
                const leftX = Math.random() * (window.innerWidth - 100) + 50;
                startPos = { left: leftX + 'px', top: '-80px' };
                centerPos = { left: leftX + 'px', top: centerY + 'px' };
                endPos = { left: leftX + 'px', top: window.innerHeight + 80 + 'px' };
                break;
            case 'up':
                const leftXUp = Math.random() * (window.innerWidth - 100) + 50;
                startPos = { left: leftXUp + 'px', top: window.innerHeight + 80 + 'px' };
                centerPos = { left: leftXUp + 'px', top: centerY + 'px' };
                endPos = { left: leftXUp + 'px', top: '-80px' };
                break;
        }
        
        // Set starting position
        distraction.style.left = startPos.left;
        distraction.style.top = startPos.top;
        distraction.style.opacity = '0';
        
        console.log(`🎬 Starting slide-${direction}: Edge → Center → Edge with ${pauseDuration}ms pause`);
        
        // Fade in
        setTimeout(() => {
            distraction.style.opacity = '1';
        }, 200);
        
        // Phase 1: Slide to center
        this.animateSlidingPhase(distraction, startPos, centerPos, slideInDuration, () => {
            console.log(`🎯 Reached center - pausing for ${pauseDuration}ms`);
            
            // Phase 2: Pause in center for interaction
            setTimeout(() => {
                // Check if still exists (not tapped)
                if (distraction.parentNode) {
                    console.log(`⏰ Pause complete - sliding out`);
                    
                    // Phase 3: Slide out
                    this.animateSlidingPhase(distraction, centerPos, endPos, slideOutDuration, () => {
                        if (distraction.parentNode) {
                            distraction.remove();
                            console.log(`✅ Sliding sequence complete - distraction removed`);
                        }
                    });
                }
            }, pauseDuration);
        });
    },
    
    // Animate sliding phase with callback when complete
    animateSlidingPhase(element, startPos, endPos, duration, onComplete) {
        const startTime = performance.now();
        const startLeft = parseFloat(startPos.left);
        const startTop = parseFloat(startPos.top);
        const endLeft = parseFloat(endPos.left);
        const endTop = parseFloat(endPos.top);
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Calculate current position
            const currentLeft = startLeft + (endLeft - startLeft) * progress;
            const currentTop = startTop + (endTop - startTop) * progress;
            
            // Apply position
            element.style.left = currentLeft + 'px';
            element.style.top = currentTop + 'px';
            
            // Continue animation or call completion callback
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Phase complete
                if (onComplete) onComplete();
            }
        };
        
        // Start animation
        requestAnimationFrame(animate);
    }
};

console.log('✅ Direct JavaScript Sliding System Loaded');

// ========================================================================
// BOUNCING MOVEMENT SYSTEM (ROUNDS 5-6)
// ========================================================================

const bouncingMovementSystem = {
    // Apply bouncing movement to distraction
    applyBouncing(distraction, roundNumber) {
        if (roundNumber < 5 || roundNumber > 6) {
            return false; // No bouncing for this round
        }
        
        console.log(`🏀 Applying BOUNCING movement for round ${roundNumber}`);
        
        // Choose random bouncing pattern
        const patterns = ['horizontal-bounce', 'vertical-bounce', 'diagonal-bounce'];
        const pattern = patterns[Math.floor(Math.random() * patterns.length)];
        
        // Setup bouncing animation
        this.setupBouncingAnimation(distraction, pattern);
        
        return true;
    },
    
    // Setup bouncing animation with physics
    setupBouncingAnimation(distraction, pattern) {
        const slideInDuration = gameState.isMobile ? 2500 : 3000;   // Slower for bouncing
        const pauseDuration = gameState.isMobile ? 3500 : 4500;     // Longer pause
        const slideOutDuration = gameState.isMobile ? 2500 : 3000;  // Slower exit
        
        // Force proper positioning
        distraction.style.position = 'fixed';
        distraction.style.zIndex = '1000';
        distraction.style.transition = 'none';
        
        // Calculate positions based on pattern
        const centerX = (window.innerWidth / 2) - 30;
        const centerY = (window.innerHeight / 2) - 30;
        
        let startPos, centerPos, endPos, bounceSettings;
        
        switch(pattern) {
            case 'horizontal-bounce':
                const bounceY = Math.random() * (window.innerHeight - 200) + 100;
                startPos = { left: '-80px', top: bounceY + 'px' };
                centerPos = { left: centerX + 'px', top: bounceY + 'px' };
                endPos = { left: window.innerWidth + 80 + 'px', top: bounceY + 'px' };
                bounceSettings = {
                    axis: 'vertical',
                    amplitude: 40,  // Bounce height
                    frequency: 0.8  // Bounce speed
                };
                break;
                
            case 'vertical-bounce':
                const bounceX = Math.random() * (window.innerWidth - 200) + 100;
                startPos = { left: bounceX + 'px', top: '-80px' };
                centerPos = { left: bounceX + 'px', top: centerY + 'px' };
                endPos = { left: bounceX + 'px', top: window.innerHeight + 80 + 'px' };
                bounceSettings = {
                    axis: 'horizontal',
                    amplitude: 30,  // Bounce width
                    frequency: 0.6  // Bounce speed
                };
                break;
                
            case 'diagonal-bounce':
                // Start from random corner
                const corners = [
                    { start: { left: '-80px', top: '-80px' }, end: { left: window.innerWidth + 80 + 'px', top: window.innerHeight + 80 + 'px' } },
                    { start: { left: window.innerWidth + 80 + 'px', top: '-80px' }, end: { left: '-80px', top: window.innerHeight + 80 + 'px' } }
                ];
                const corner = corners[Math.floor(Math.random() * corners.length)];
                startPos = corner.start;
                centerPos = { left: centerX + 'px', top: centerY + 'px' };
                endPos = corner.end;
                bounceSettings = {
                    axis: 'both',
                    amplitude: 25,  // Smaller bounces for diagonal
                    frequency: 0.7
                };
                break;
        }
        
        // Set starting position
        distraction.style.left = startPos.left;
        distraction.style.top = startPos.top;
        distraction.style.opacity = '0';
        
        console.log(`🏀 Starting ${pattern}: Edge → Center → Edge with bouncing`);
        
        // Fade in
        setTimeout(() => {
            distraction.style.opacity = '1';
        }, 200);
        
        // Phase 1: Bounce to center
        this.animateBouncingPhase(distraction, startPos, centerPos, slideInDuration, bounceSettings, () => {
            console.log(`🎯 Reached center with bouncing - pausing for ${pauseDuration}ms`);
            
            // Phase 2: Gentle bounce while paused in center
            this.animateCenterBounce(distraction, centerPos, pauseDuration, () => {
                // Check if still exists (not tapped)
                if (distraction.parentNode) {
                    console.log(`⏰ Bounce pause complete - bouncing out`);
                    
                    // Phase 3: Bounce out
                    this.animateBouncingPhase(distraction, centerPos, endPos, slideOutDuration, bounceSettings, () => {
                        if (distraction.parentNode) {
                            distraction.remove();
                            console.log(`✅ Bouncing sequence complete`);
                        }
                    });
                }
            });
        });
    },
    
    // Animate bouncing phase with physics
    animateBouncingPhase(element, startPos, endPos, duration, bounceSettings, onComplete) {
        const startTime = performance.now();
        const startLeft = parseFloat(startPos.left);
        const startTop = parseFloat(startPos.top);
        const endLeft = parseFloat(endPos.left);
        const endTop = parseFloat(endPos.top);
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Calculate base position
            const baseLeft = startLeft + (endLeft - startLeft) * progress;
            const baseTop = startTop + (endTop - startTop) * progress;
            
            // Add bouncing motion
            const bounceTime = (elapsed / 1000) * bounceSettings.frequency;
            let bounceOffsetX = 0, bounceOffsetY = 0;
            
            if (bounceSettings.axis === 'vertical' || bounceSettings.axis === 'both') {
                bounceOffsetY = Math.sin(bounceTime * Math.PI * 2) * bounceSettings.amplitude * (1 - progress * 0.3);
            }
            
            if (bounceSettings.axis === 'horizontal' || bounceSettings.axis === 'both') {
                bounceOffsetX = Math.cos(bounceTime * Math.PI * 2) * bounceSettings.amplitude * (1 - progress * 0.3);
            }
            
            // Apply position with bounce
            element.style.left = (baseLeft + bounceOffsetX) + 'px';
            element.style.top = (baseTop + bounceOffsetY) + 'px';
            
            // Continue animation or complete
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                if (onComplete) onComplete();
            }
        };
        
        requestAnimationFrame(animate);
    },
    
    // Gentle bounce while paused in center
    animateCenterBounce(element, centerPos, duration, onComplete) {
        const startTime = performance.now();
        const centerLeft = parseFloat(centerPos.left);
        const centerTop = parseFloat(centerPos.top);
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Gentle floating motion in center
            const bounceTime = (elapsed / 1000) * 0.5; // Slow, gentle bounce
            const floatY = Math.sin(bounceTime * Math.PI * 2) * 15; // Small float amplitude
            const floatX = Math.cos(bounceTime * Math.PI * 3) * 8;   // Subtle horizontal drift
            
            element.style.left = (centerLeft + floatX) + 'px';
            element.style.top = (centerTop + floatY) + 'px';
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                if (onComplete) onComplete();
            }
        };
        
        requestAnimationFrame(animate);
    }
};

console.log('✅ Bouncing Movement System Loaded');

// ========================================================================
// ORBITAL MOVEMENT SYSTEM (ROUNDS 7-8)
// ========================================================================

const orbitalMovementSystem = {
    // Apply orbital movement to distraction
    applyOrbital(distraction, roundNumber) {
        if (roundNumber < 7 || roundNumber > 8) {
            return false; // No orbital for this round
        }
        
        console.log(`🌀 Applying ORBITAL movement for round ${roundNumber}`);
        
        // Choose random orbital pattern
        const patterns = ['spiral-in', 'circular-orbit', 'figure-eight', 'spiral-out'];
        const pattern = patterns[Math.floor(Math.random() * patterns.length)];
        
        // Setup orbital animation
        this.setupOrbitalAnimation(distraction, pattern);
        
        return true;
    },
    
    // Setup orbital animation with curved paths
    setupOrbitalAnimation(distraction, pattern) {
        const totalDuration = gameState.isMobile ? 8000 : 10000;  // Longer for complex paths
        const centerPauseDuration = gameState.isMobile ? 3000 : 4000;
        
        // Force proper positioning
        distraction.style.position = 'fixed';
        distraction.style.zIndex = '1000';
        distraction.style.transition = 'none';
        
        // Screen center
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        // Set starting position and path based on pattern
        let pathSettings;
        
        switch(pattern) {
            case 'spiral-in':
                pathSettings = {
                    startRadius: Math.min(window.innerWidth, window.innerHeight) * 0.6,
                    endRadius: 50,
                    turns: 2.5,
                    direction: 1, // Clockwise
                    startAngle: Math.random() * Math.PI * 2
                };
                break;
                
            case 'circular-orbit':
                const orbitRadius = Math.min(window.innerWidth, window.innerHeight) * 0.3;
                pathSettings = {
                    startRadius: orbitRadius,
                    endRadius: orbitRadius,
                    turns: 1.5,
                    direction: Math.random() > 0.5 ? 1 : -1, // Random direction
                    startAngle: Math.random() * Math.PI * 2
                };
                break;
                
            case 'figure-eight':
                pathSettings = {
                    width: Math.min(window.innerWidth, window.innerHeight) * 0.4,
                    height: Math.min(window.innerWidth, window.innerHeight) * 0.3,
                    turns: 1,
                    direction: 1,
                    startAngle: 0
                };
                break;
                
            case 'spiral-out':
                pathSettings = {
                    startRadius: 30,
                    endRadius: Math.min(window.innerWidth, window.innerHeight) * 0.6,
                    turns: 2,
                    direction: -1, // Counter-clockwise
                    startAngle: Math.random() * Math.PI * 2
                };
                break;
        }
        
        // Calculate starting position
        const startPos = this.calculatePathPosition(centerX, centerY, pathSettings, 0, pattern);
        
        // Set starting position
        distraction.style.left = startPos.x + 'px';
        distraction.style.top = startPos.y + 'px';
        distraction.style.opacity = '0';
        
        console.log(`🌀 Starting ${pattern}: Complex path to center`);
        
        // Fade in
        setTimeout(() => {
            distraction.style.opacity = '1';
        }, 200);
        
        // Execute orbital animation
        this.animateOrbitalPath(distraction, centerX, centerY, pathSettings, pattern, totalDuration, () => {
            console.log(`🎯 Orbital path complete - pausing in center for ${centerPauseDuration}ms`);
            
            // Pause in center with gentle rotation
            this.animateCenterRotation(distraction, centerX, centerY, centerPauseDuration, () => {
                // Check if still exists (not tapped)
                if (distraction.parentNode) {
                    console.log(`⏰ Center pause complete - spiraling out`);
                    
                    // Spiral out and remove
                    this.animateExitSpiral(distraction, centerX, centerY, 2000, () => {
                        if (distraction.parentNode) {
                            distraction.remove();
                            console.log(`✅ Orbital sequence complete`);
                        }
                    });
                }
            });
        });
    },
    
    // Calculate position on orbital path
    calculatePathPosition(centerX, centerY, pathSettings, progress, pattern) {
        let x, y;
        
        if (pattern === 'figure-eight') {
            // Figure-8 path using parametric equations
            const t = progress * Math.PI * 2 * pathSettings.turns;
            const scale = 1 - progress * 0.3; // Shrink toward center
            
            x = centerX + (pathSettings.width * scale * Math.sin(t)) / 2;
            y = centerY + (pathSettings.height * scale * Math.sin(2 * t)) / 2;
        } else {
            // Spiral patterns
            const angle = pathSettings.startAngle + (progress * Math.PI * 2 * pathSettings.turns * pathSettings.direction);
            const radius = pathSettings.startRadius + ((pathSettings.endRadius - pathSettings.startRadius) * progress);
            
            x = centerX + radius * Math.cos(angle);
            y = centerY + radius * Math.sin(angle);
        }
        
        return { x, y };
    },
    
    // Animate along orbital path
    animateOrbitalPath(element, centerX, centerY, pathSettings, pattern, duration, onComplete) {
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Calculate position on path
            const pos = this.calculatePathPosition(centerX, centerY, pathSettings, progress, pattern);
            
            // Apply position
            element.style.left = pos.x + 'px';
            element.style.top = pos.y + 'px';
            
            // Add slight rotation for visual interest
            const rotation = progress * 360 * pathSettings.turns;
            element.style.transform = `rotate(${rotation}deg)`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                element.style.transform = ''; // Reset rotation
                if (onComplete) onComplete();
            }
        };
        
        requestAnimationFrame(animate);
    },
    
    // Gentle rotation while paused in center
    animateCenterRotation(element, centerX, centerY, duration, onComplete) {
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Gentle floating with slow rotation
            const floatTime = (elapsed / 1000) * 0.3;
            const floatRadius = 20;
            const floatX = Math.cos(floatTime * Math.PI * 2) * floatRadius;
            const floatY = Math.sin(floatTime * Math.PI * 2) * floatRadius;
            const rotation = floatTime * 60; // Slow rotation
            
            element.style.left = (centerX - 30 + floatX) + 'px';
            element.style.top = (centerY - 30 + floatY) + 'px';
            element.style.transform = `rotate(${rotation}deg)`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                if (onComplete) onComplete();
            }
        };
        
        requestAnimationFrame(animate);
    },
    
    // Spiral out exit animation
    animateExitSpiral(element, centerX, centerY, duration, onComplete) {
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Spiral outward
            const angle = progress * Math.PI * 4; // 2 full rotations
            const radius = progress * 400; // Expand outward
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            
            element.style.left = x + 'px';
            element.style.top = y + 'px';
            element.style.opacity = 1 - progress; // Fade out
            element.style.transform = `rotate(${progress * 720}deg) scale(${1 - progress * 0.5})`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                if (onComplete) onComplete();
            }
        };
        
        requestAnimationFrame(animate);
    }
};

console.log('✅ Orbital Movement System Loaded');

// ========================================================================
// MOBILE FEEDBACK SYSTEM
// ========================================================================
window.enhancedFeedback = {
    // Enhanced elimination with layered sounds + vibration + shake
    elimination: function(distractionType = 'normal', comboCount = 0) {
        // Keep original success sound but add layers
        setTimeout(() => playSound('pop', 0.3), 80);
        setTimeout(() => playSound('ding', 0.2), 160);
        
        // Add combo enhancement
        if (comboCount >= 3) {
            setTimeout(() => playSound('achievement', 0.4), 240);
        }
        
        // Screen shake
        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen) {
            gameScreen.style.animation = 'shake 0.25s ease-out';
            setTimeout(() => gameScreen.style.animation = '', 250);
        }
        
        // Mobile vibration
        if ('vibrate' in navigator && gameState.isMobile) {
            const vibPattern = comboCount >= 3 ? [30, 10, 30] : [25];
            navigator.vibrate(vibPattern);
        }
    },
    
    // Failure with dramatic effects
    failure: function(urgency = 'normal') {
        // Add dramatic failure sounds after original
        if (urgency === 'critical') {
            setTimeout(() => playSound('buzz', 0.5), 200);
            setTimeout(() => playSound('buzz', 0.3), 400);
        } else {
            setTimeout(() => playSound('buzz', 0.3), 150);
        }
        
        // Shake silhouette
        const silhouette = document.getElementById('coupleSilhouette');
        if (silhouette) {
            const shakeClass = urgency === 'critical' ? 'critical-miss' : 'safe-miss';
            silhouette.classList.add(shakeClass);
            setTimeout(() => silhouette.classList.remove(shakeClass), 600);
        }
        
        // Failure vibration
        if ('vibrate' in navigator && gameState.isMobile) {
            const vibLength = urgency === 'critical' ? 150 : 80;
            navigator.vibrate(vibLength);
        }
    },
    
    // Enhanced heart loss with emotional impact
    heartLoss: function(heartsRemaining) {
        // Dramatic heart loss sounds
        setTimeout(() => playSound('buzz', 0.6), 200);
        if (heartsRemaining <= 1) {
            setTimeout(() => playSound('buzz', 0.4), 400);
            setTimeout(() => playSound('fail', 0.5), 600);
        }
        
        // Screen flash for dramatic effect
        const flashOverlay = document.createElement('div');
        flashOverlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.2); pointer-events: none; z-index: 9998;
            animation: screenFlash 0.4s ease-out;
        `;
        document.body.appendChild(flashOverlay);
        setTimeout(() => flashOverlay.remove(), 400);
        
        // Heart loss vibration
        if ('vibrate' in navigator && gameState.isMobile) {
            const pattern = heartsRemaining <= 1 ? [100, 50, 100] : [80];
            navigator.vibrate(pattern);
        }
    },
    
    // Special combo celebration
    combo: function(comboCount) {
        if (comboCount >= 5) {
            playSound('achievement', 0.6);
            setTimeout(() => playSound('ding', 0.4), 100);
            setTimeout(() => playSound('pop', 0.3), 200);
            setTimeout(() => playSound('ding', 0.4), 300);
            
            // Big combo vibration
            if ('vibrate' in navigator && gameState.isMobile) {
                navigator.vibrate([50, 30, 50, 30, 80]);
            }
            
            // Screen celebration shake
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen) {
                gameScreen.style.animation = 'shake 0.4s ease-out';
                setTimeout(() => gameScreen.style.animation = '', 400);
            }
        }
    },

// Silhouette reaction with urgency levels
silhouetteReaction: function(urgency = 'safe') {
    console.log(`💔 Silhouette reaction triggered: ${urgency} (${gameState.isMobile ? 'mobile' : 'desktop'})`);
    
    // Map critical to warning to avoid dramatic animations
    const mappedUrgency = urgency === 'critical' ? 'warning' : urgency;
    
    simplifiedSeparationSystem.triggerSeparation(mappedUrgency);
}
};

console.log('✅ Enhanced Feedback System Loaded');

</script>
</body>
</html>