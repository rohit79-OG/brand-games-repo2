<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>KS Endless Embrace - Embrace Up 3X</title>
    
    <style>
  /* =================================
   BASE STYLES
   ================================= */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

body {
    font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    color: #fff;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    position: relative;
}

/* =================================
   GLASS MORPHISM COMPONENTS
   ================================= */

.glass {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
}

/* =================================
   SCREEN MANAGEMENT
   ================================= */

.screen {
    position: fixed;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    z-index: 10;
    top: 0;
    left: 0;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
}

.screen.active {
    display: flex;
    z-index: 100;
}

/* Desktop Screen Rules */
@media (min-width: 769px) {
    .screen {
        position: fixed !important;
        padding: 20px !important;
    }
    
    .screen:not(.active) {
        display: none !important;
    }
    
    .screen.active {
        display: flex !important;
        z-index: 100 !important;
    }
}

/* Mobile Screen Rules */
@media (max-width: 768px) {
    .screen:not(.active) {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
    }
    
    .screen.active {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        z-index: 1000 !important;
    }
}

/* =================================
   START SCREEN
   ================================= */

.start-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px auto;
    justify-content: center;
    min-height: auto;
}

/* Desktop Start Screen */
@media (min-width: 769px) {
    #startScreen {
        padding: 30px 20px !important;
        box-sizing: border-box;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
    }

    .start-panel {
        padding: 30px;
        max-width: 400px;
        width: 85%;
        margin: 20px auto;
    }

    .start-panel .btn {
        min-width: 200px;
        width: auto;
        padding: 12px 30px !important;
        margin: 8px 0;
    }

    .start-panel h1 {
        font-size: clamp(2rem, 8vw, 3rem);
    }

    .start-panel .brand-logo {
        margin-bottom: 20px;
    }

    .start-panel .game-logo {
        margin-bottom: 8px;
    }
}

/* Mobile Start Screen */
@media (max-width: 768px) {
    .start-panel {
        padding: 30px 20px 35px 20px;
        max-width: 92vw;
        width: 90%;
        margin: 0 auto;
    }

    #startScreen {
        padding: 0 !important;
        margin: 0 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-height: 100vh !important;
    }

    .start-panel h1 {
        font-size: 2rem !important;
    }

    .start-panel .brand-logo {
        margin-bottom: 15px !important;
    }

    .start-panel .game-logo {
        margin-bottom: 10px !important;
    }

    .start-panel .btn {
        min-width: 150px;
        padding: 12px 25px !important;
        margin: 6px 0;
    }
}

/* =================================
   RESULTS SCREEN
   ================================= */

.results-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-height: 90vh;
    overflow-y: auto;
}

.results-panel h1 {
    margin-top: 20px !important;
    margin-bottom: 10px !important;
}

.results-panel .btn {
    padding: 12px 30px !important;
    font-size: clamp(0.9rem, 3.5vw, 1.1rem) !important;
    min-height: 48px !important;
    max-height: 55px !important;
}

.results-panel .btn-promo {
    padding: 12px 25px !important;
    font-size: clamp(0.85rem, 3vw, 1rem) !important;
    min-height: 48px !important;
    max-height: 55px !important;
}

/* Desktop Results */
@media (min-width: 769px) {
    .results-panel {
        padding: 25px 30px !important;
        max-height: 85vh !important;
    }

    .results-panel h1 {
        margin-top: 10px !important;
        margin-bottom: 8px !important;
    }

    .results-panel p {
        margin-bottom: 15px !important;
    }

    .challenge-section {
        margin: 10px 0 !important;
        padding: 12px !important;
    }
}

/* Mobile Results */
@media (max-width: 768px) {
    .results-panel {
        padding: 30px 15px 35px 15px;
        max-width: 98%;
    }

    #resultsScreen {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 20px 5px !important;
    }

    .results-panel h1 {
        margin-top: 25px !important;
        font-size: 2rem !important;
    }

    .button-row {
        gap: 10px !important;
        margin: 20px 0 !important;
    }

    .image-row {
        gap: 20px !important;
        margin: 20px 0 !important;
    }

    .promo-section {
        margin: 25px 0 !important;
    }

    .results-panel > p {
        margin-bottom: 20px !important;
    }
}

/* =================================
   TYPOGRAPHY
   ================================= */

h1 {
    font-size: clamp(2rem, 8vw, 3rem);
    text-align: center;
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

h2 {
    font-size: clamp(1.5rem, 6vw, 2rem);
    text-align: center;
    margin-bottom: 15px;
    color: #FFD700;
}

p {
    font-size: clamp(1rem, 4vw, 1.2rem);
    text-align: center;
    margin-bottom: 20px;
    line-height: 1.5;
}

/* =================================
   LOGOS
   ================================= */

.brand-logo {
    width: 150px;
    height: auto;
    margin-bottom: 20px;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.game-logo {
    width: 80px;
    height: auto;
    margin-bottom: 10px;
    animation: pulse 2s ease-in-out infinite;
}

/* =================================
   BUTTONS
   ================================= */

.btn {
    background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%);
    color: #fff;
    padding: 12px 30px !important;
    border: none;
    border-radius: 30px;
    font-size: clamp(1rem, 4vw, 1.2rem);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(213, 54, 90, 0.4);
    position: relative;
    overflow: hidden;
    margin: 10px auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    min-width: 140px !important;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

.btn:before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

.btn:active:before {
    width: 300px;
    height: 300px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(213, 54, 90, 0.5);
}

.btn-secondary {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.btn-gold {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 12px 25px;
    font-size: 0.9rem;
}

.btn-small {
    padding: 10px 20px;
    font-size: 0.9rem;
}

.btn-promo {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    font-weight: bold;
    padding: 10px 25px;
    font-size: 0.95rem;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 215, 0, 0.3);
    box-shadow: 0 8px 32px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
    animation: promoGlow 2s ease-in-out infinite;
}

/* =================================
   GAME CANVAS & SCREEN
   ================================= */

#gameCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#gameScreen {
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    position: relative;
}

/* Desktop Game Screen */
@media (min-width: 769px) {
    #gameScreen {
        position: relative !important;
        z-index: 10 !important;
    }
}

/* Mobile Game Screen */
@media (max-width: 768px) {
    #gameScreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 1000 !important;
        padding: 0 !important;
        margin: 0 !important;
    }
}

/* =================================
   GAME HUD
   ================================= */

.game-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 20px;
    z-index: 1100;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-direction: column;
    pointer-events: none;
}

.hud-top {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: auto;
}

/* Desktop HUD */
@media (min-width: 769px) {
    .game-hud {
        position: absolute !important;
        padding: 20px !important;
    }

    .score-display, .intimacy-meter {
        font-size: 1.2rem !important;
        padding: 10px 20px !important;
    }
}

/* Mobile HUD */
@media (max-width: 768px) {
    .game-hud {
        position: fixed !important;
        padding: 15px 10px !important;
    }
    
    .score-display, .intimacy-meter {
        font-size: 1rem !important;
        padding: 8px 15px !important;
    }
}

/* =================================
   SCORE & INTIMACY METER
   ================================= */

.score-display, .intimacy-meter {
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1.2rem;
    font-weight: 600;
}

.score-display {
    color: #FFD700;
}

.intimacy-meter {
    display: flex;
    gap: 5px;
    align-items: center;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* =================================
   HEARTS SYSTEM
   ================================= */

.heart {
    font-size: 1.5rem;
    transition: all 0.3s ease;
    position: relative;
    display: inline-block;
    cursor: default;
    color: #d5365a;
    text-shadow: 0 0 10px rgba(213, 54, 90, 0.5);
    margin: 0 2px;
}

.heart.active {
    color: #d5365a !important;
    text-shadow: 0 0 15px rgba(213, 54, 90, 0.8) !important;
    animation: heartBeat 1.5s ease-in-out infinite;
    transform-origin: center;
    opacity: 1 !important;
    filter: none !important;
}

.heart.active::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 30px;
    height: 30px;
    background: radial-gradient(circle, rgba(213, 54, 90, 0.4) 0%, transparent 70%);
    border-radius: 50%;
    z-index: -1;
    animation: heartGlow 1.5s ease-in-out infinite;
}

.heart.inactive {
    color: #444 !important;
    opacity: 0.3 !important;
    animation: none !important;
    text-shadow: none !important;
    filter: grayscale(100%) !important;
}

.heart.inactive::before {
    display: none !important;
}

.heart.breaking {
    animation: heartBreak 0.8s ease-out forwards !important;
    color: #d5365a !important;
}

.heart.gaining {
    animation: heartGain 0.6s ease-out !important;
    filter: drop-shadow(0 0 10px #d5365a) !important;
    color: #d5365a !important;
}

/* Game HUD Heart Meter Specific */
.game-hud .intimacy-meter .heart {
    font-size: 1.5rem !important;
    color: #d5365a !important;
    text-shadow: 0 0 10px rgba(213, 54, 90, 0.5) !important;
    margin: 0 2px !important;
    transition: all 0.3s ease !important;
    position: relative !important;
    display: inline-block !important;
}

.game-hud .intimacy-meter .heart.active {
    color: #d5365a !important;
    text-shadow: 0 0 15px rgba(213, 54, 90, 0.8) !important;
    animation: heartBeat 1.5s ease-in-out infinite !important;
    opacity: 1 !important;
    filter: none !important;
}

.game-hud .intimacy-meter .heart.inactive {
    color: #444 !important;
    opacity: 0.3 !important;
    filter: grayscale(100%) !important;
    animation: none !important;
    text-shadow: none !important;
}

/* =================================
   DISTRACTIONS
   ================================= */

.distraction {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 1000 !important;
    animation: appearPop 0.3s ease-out;
    pointer-events: auto;
}

.distraction-icon {
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 3px solid #FFD700;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    position: relative;
    overflow: visible;
}

.distraction-icon.booster {
    background: rgba(255, 215, 0, 0.3);
    border: 2px solid #FFD700;
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
    animation: glowPulse 1s ease-in-out infinite;
}

/* Mobile Distractions */
@media (max-width: 768px) {
    .distraction {
        z-index: 1000 !important;
    }
    
    .distraction-icon {
        width: 70px !important;
        height: 70px !important;
        font-size: 2rem !important;
    }
    
    .distraction.behind-message {
        z-index: 900 !important;
        opacity: 0.7 !important;
    }
}

/* =================================
   PRIORITY RING SYSTEM
   ================================= */

.priority-ring {
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    border-radius: 50%;
    border: 4px solid transparent;
    pointer-events: none;
    z-index: 5;
}

.priority-ring.critical {
    border: 6px solid #FF4444;
    animation: criticalRingIntense 0.4s ease-in-out infinite;
    box-shadow: 0 0 25px rgba(255, 68, 68, 1);
}

.priority-ring.warning {
    border: 4px solid #FFA500;
    animation: warningRingMedium 0.8s ease-in-out infinite;
    box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
}

.priority-ring.safe {
    border: 3px solid #32CD32;
    animation: safeRingGentle 1.5s ease-in-out infinite;
    box-shadow: 0 0 15px rgba(50, 205, 50, 0.6);
}

/* =================================
   TROPHY DISTRACTION
   ================================= */

.distraction-icon.trophy {
    background: linear-gradient(45deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%) !important;
    border: 3px solid #FFFF00 !important;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
    animation: trophyPulse 1.5s ease-in-out infinite !important;
    position: relative;
}

.trophy-bonus {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    background: #FFD700;
    color: #000;
    font-size: 0.7rem;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid #FFA500;
    white-space: nowrap;
    z-index: 15;
    pointer-events: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* =================================
   STICKY NOTES
   ================================= */

.sticky-note {
    width: 100px;
    height: 80px;
    background: #ffeb3b;
    position: relative;
    transform: rotate(-5deg);
    box-shadow: 2px 2px 10px rgba(0,0,0,0.3);
    padding: 10px;
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 14px;
    color: #333;
    cursor: pointer;
}

.sticky-note div {
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 12px !important;
    line-height: 1.2 !important;
}

.sticky-note:before {
    content: '';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 20px;
    background: rgba(0,0,0,0.1);
    clip-path: polygon(0 0, 100% 0, 50% 100%);
}

/* Mobile Sticky Notes */
@media (max-width: 768px) {
    .sticky-note {
        font-family: 'Comic Sans MS', 'Chalkduster', 'Marker Felt', cursive !important;
        font-size: 12px !important;
    }
    
    .sticky-note div {
        font-family: 'Comic Sans MS', 'Chalkduster', 'Marker Felt', cursive !important;
        font-size: 10px !important;
    }
}

/* =================================
   ACHIEVEMENT POPUPS
   ================================= */

.achievement-popup {
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 15px 20px;
    border-radius: 15px;
    text-align: center;
    z-index: 2000;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
    max-width: 70vw;
    font-size: 0.9rem;
    display: block;
}

.mobile-achievement-notification {
    position: fixed;
    top: 80px !important;
    left: 20px;
    right: 20px;
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 8px 12px;
    border-radius: 15px;
    font-size: 0.75rem;
    font-weight: bold;
    z-index: 2500 !important;
    animation: slideInFromTop 0.5s ease-out;
    max-width: none;
    text-align: center;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    display: none;
    border: 2px solid #fff;
}

.achievement-popup.show {
    animation: achievementPop 0.6s ease-out forwards;
}

.achievement-icon {
    font-size: 2rem !important;
    margin-bottom: 8px !important;
}

.achievement-title {
    font-size: 1.1rem !important;
    margin-bottom: 4px !important;
}

.achievement-desc {
    font-size: 0.8rem !important;
}

/* Round Complete Popup */
.round-complete-popup {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) scale(0) !important;
    background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%) !important;
    color: #fff !important;
    padding: 15px 25px !important;
    border-radius: 15px !important;
    text-align: center !important;
    z-index: 2000 !important;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5) !important;
    max-width: 250px !important;
    font-size: 0.9rem !important;
    border: 2px solid #FFD700 !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
}

.round-complete-popup.show {
    animation: achievementPop 0.6s ease-out forwards !important;
}

/* Mobile Achievement Rules */
@media (max-width: 768px) {
    .achievement-popup {
        display: none !important;
        z-index: 2000 !important;
    }
    
    .mobile-achievement-notification {
        display: block !important;
        z-index: 2500 !important;
    }
    
    .round-complete-popup {
        display: none !important;
    }
    
    .mobile-round-notification {
        position: fixed;
        top: 20px;
        left: 20px;
        background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%);
        color: #fff;
        padding: 8px 12px;
        border-radius: 15px;
        font-size: 0.75rem;
        font-weight: bold;
        z-index: 2500 !important;
        animation: slideInLeft 0.5s ease-out;
        max-width: 180px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(213, 54, 90, 0.4);
        border: 1px solid #FFD700;
    }
}

@media (min-width: 769px) {
    .mobile-achievement-notification {
        display: none !important;
    }
    
    .mobile-round-notification {
        display: none !important;
    }
    
    .achievement-popup {
        display: block !important;
    }
}

/* =================================
   ACHIEVEMENT BOARD
   ================================= */

.achievement-board {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    padding: 10px;
    z-index: 50;
    max-width: 200px;
    font-size: 0.7rem;
    transition: opacity 0.3s ease;
    opacity: 0.8;
    margin-top: 10px;
    position: absolute;
    top: 80px;
    left: 20px;
}

.achievement-board:hover {
    opacity: 1;
}

.achievement-board h4 {
    color: #FFD700;
    font-size: 0.8rem;
    margin-bottom: 5px;
    text-align: center;
}

.achievement-board ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.achievement-board li {
    color: #fff;
    margin: 3px 0;
    font-size: 0.65rem;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: all 0.5s ease;
    opacity: 0.4;
    transform: scale(1);
    position: relative;
    overflow: hidden;
}

.achievement-board li.unlocked {
    opacity: 1 !important;
    color: #FFD700 !important;
    font-weight: bold;
    text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    animation: achievementPulse 3s ease-in-out infinite;
}

.achievement-board li.just-unlocked {
    animation: achievementUnlock 1.5s ease-out forwards !important;
}

.achievement-board .icon {
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.achievement-board li.unlocked .icon {
    filter: drop-shadow(0 0 5px #FFD700);
}

/* Desktop Achievement Board */
@media (min-width: 769px) {
    .achievement-board {
        position: absolute !important;
        top: 80px !important;
        left: 20px !important;
        max-width: 200px !important;
        font-size: 0.7rem !important;
        opacity: 0.8 !important;
    }
}

/* Mobile Achievement Board */
@media (max-width: 768px) {
    .achievement-board {
        font-size: 0.6rem !important;
        max-width: 160px !important;
        padding: 8px !important;
        opacity: 0.9 !important;
        position: absolute !important;
        top: 80px !important;
        left: 10px !important;
    }
    
    .achievement-board h4 {
        font-size: 0.7rem !important;
        margin-bottom: 4px !important;
    }
    
    .achievement-board li {
        font-size: 0.55rem !important;
        margin: 2px 0 !important;
    }
    
    .achievement-board .icon {
        font-size: 0.8rem !important;
    }
    
    .achievement-board.gameplay-hidden {
        display: none !important;
    }
}

/* =================================
   LOADING SCREEN
   ================================= */

.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.loading-bar {
    width: 80%;
    max-width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 20px;
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, #d5365a 0%, #FFD700 100%);
    border-radius: 2px;
    transition: width 0.3s ease;
}

.loading-screen .glass {
    padding: 40px 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    margin: 0 auto;
}

@media (max-width: 768px) {
    .loading-screen .glass {
        padding: 30px 25px;
        max-width: 85vw;
        width: 90%;
    }
}

/* =================================
   LOADING TIPS
   ================================= */

.loading-tip {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    padding: 8px 20px;
    max-width: 80vw;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    z-index: 1;
}

.loading-tip.loading-tip-custom {
    padding: 8px 15px !important;
    line-height: 1.3 !important;
    background: rgba(0, 0, 0, 0.4) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 10px !important;
    position: absolute !important;
    bottom: 40px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    text-align: center !important;
    max-width: 85vw !important;
    width: auto !important;
    white-space: nowrap !important;
    z-index: 1 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    min-height: 35px !important;
    font-size: 0.85rem !important;
}

.loading-tip.loading-tip-custom p {
    margin: 0 !important;
    padding: 0 !important;
    text-align: center !important;
    line-height: 1.2 !important;
}

@media (max-width: 768px) {
    .loading-tip {
        padding: 6px 15px;
        max-width: 90vw;
        font-size: 0.9rem;
        bottom: 30px;
    }
    
    .loading-tip.loading-tip-custom {
        padding: 6px 12px !important;
        max-width: 90vw !important;
        font-size: 0.75rem !important;
        bottom: 30px !important;
        min-height: 30px !important;
        white-space: normal !important;
    }
}

/* =================================
   AUDIO TOGGLE
   ================================= */

.audio-toggle {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1200;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.audio-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.audio-toggle.muted {
    opacity: 0.6;
    background: rgba(255, 0, 0, 0.2) !important;
}

/* Mobile Audio Toggle */
@media (max-width: 768px) {
    .audio-toggle {
        position: fixed !important;
        bottom: 15px !important;
        left: 15px !important;
        width: 45px !important;
        height: 45px !important;
        z-index: 2000 !important;
        background: rgba(0, 0, 0, 0.7) !important;
        border: 2px solid rgba(255, 255, 255, 0.8) !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5) !important;
    }

    .audio-toggle span {
        font-size: 1.2rem !important;
    }
}

/* =================================
   COUPLE SILHOUETTE
   ================================= */

.couple-silhouette {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 300px;
    height: 300px;
    z-index: 2;
    opacity: 0.8;
    filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    transition: opacity 0.5s ease, filter 0.5s ease;
}

.couple-silhouette img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transition: all 0.3s ease;
}

/* Silhouette Scaling States */
.silhouette-intro-scale {
    transform: translate(-50%, -50%) scale(0.8) !important;
    transition: all 0.3s ease !important;
}

.silhouette-grow-scale {
    transform: translate(-50%, -50%) scale(1.05) !important;
    transition: all 0.8s ease !important;
}

.silhouette-normal-scale {
    transform: translate(-50%, -50%) scale(1) !important;
    transition: all 0.3s ease !important;
}

/* Mobile Silhouette */
@media (max-width: 768px) {
    .couple-silhouette {
        position: absolute !important;
        top: 50% !important;
        left: 50% !important;
        width: 280px !important;
        height: 280px !important;
        transform-origin: center center !important;
        will-change: transform !important;
    }
    
    /* Mobile-safe animation overrides */
    .couple-silhouette.silhouette-gentle-sway {
        animation: mobileGentleSway 6s ease-in-out infinite !important;
    }
    
    .couple-silhouette.silhouette-intimate-pulse,
    .couple-silhouette.silhouette-passionate-breathe,
    .couple-silhouette.silhouette-tender-rock,
    .couple-silhouette.silhouette-loving-embrace,
    .couple-silhouette.silhouette-romantic-glow,
    .couple-silhouette.silhouette-intense-connection,
    .couple-silhouette.silhouette-ultimate-unity {
        animation: mobileIntimateLevel 4s ease-in-out infinite !important;
    }
    
    .couple-silhouette.silhouette-intro-scale {
        transform: translate(-50%, -50%) scale(0.8) !important;
    }
    
    .couple-silhouette.silhouette-grow-scale {
        transform: translate(-50%, -50%) scale(1.05) !important;
    }
    
    .couple-silhouette.silhouette-normal-scale {
        transform: translate(-50%, -50%) scale(1) !important;
    }
}

/* Silhouette Effects */
.couple-silhouette.critical-miss {
    filter: drop-shadow(0 0 30px rgba(255, 0, 0, 1)) brightness(0.7) !important;
    animation: shake 0.8s ease-out !important;
}

.couple-silhouette.warning-miss {
    filter: drop-shadow(0 0 25px rgba(255, 165, 0, 0.8)) brightness(0.85) !important;
    animation: shake 0.6s ease-out !important;
}

.couple-silhouette.safe-miss {
    filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.4)) !important;
    animation: shake 0.4s ease-out !important;
}

/* =================================
   OTHER UI ELEMENTS
   ================================= */

.hint-popup {
    position: fixed !important;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: #fff;
    padding: 15px 20px;
    border-radius: 15px;
    font-size: 0.85rem;
    z-index: 2000 !important;
    animation: fadeInBounce 0.5s ease-out;
    max-width: 200px;
    text-align: center;
    border: 2px solid #FFD700;
}

.couple-results {
    width: 100%;
    margin-top: 15px;
}

.performance-comparison {
    display: flex;
    justify-content: space-around;
    align-items: center;
    margin: 15px 0;
}

.player-stats {
    text-align: center;
}

.player-stats h4 {
    color: #FFD700;
    margin-bottom: 5px;
}

.vs-indicator {
    font-size: 1.2rem;
    color: #FFD700;
    font-weight: bold;
}

.combined-metrics {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 10px;
    margin: 10px 0;
}

.metric {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    font-size: 0.9rem;
}

.metric .label {
    color: #ccc;
}

.metric .value {
    color: #FFD700;
    font-weight: bold;
}

.product-display {
    width: 150px;
    height: auto;
    margin: 10px;
    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.3));
}

.qr-code {
    width: 150px;
    height: 150px;
    background: #fff;
    padding: 1px;
    border-radius: 8px;
    margin: 10px;
}

.image-row {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin: 25px 0;
}

.button-row {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin: 25px 0;
}

.share-buttons {
    display: flex;
    gap: 15px;
    margin-top: 30px;
    flex-wrap: wrap;
    justify-content: center;
}

.share-btn {
    background: rgba(255, 255, 255, 0.2);
    padding: 10px 20px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.share-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}

.challenge-section {
    background: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 15px;
    margin: 10px 0;
    width: 100%;
}

.challenge-code {
    font-size: 1.5rem;
    font-weight: bold;
    color: #FFD700;
    letter-spacing: 2px;
    margin: 10px 0;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.show {
    display: flex;
}

.modal-content {
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 100%);
    padding: 30px;
    border-radius: 20px;
    max-width: 90vw;
    max-height: 90vh;
    overflow-y: auto;
    text-align: center;
}

.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #FFD700;
    border-radius: 50%;
    pointer-events: none;
    animation: particleFly 1s ease-out forwards;
}

/* Urgency Particles */
.urgency-particle {
    transform-origin: center;
    will-change: transform, opacity;
}

.urgency-particle.critical {
    animation-duration: 0.8s !important;
    box-shadow: 0 0 8px rgba(255, 68, 68, 0.8) !important;
}

.urgency-particle.warning {
    animation-duration: 0.9s !important;
    box-shadow: 0 0 6px rgba(255, 165, 0, 0.7) !important;
}

.urgency-particle.safe {
    animation-duration: 1.0s !important;
    box-shadow: 0 0 4px rgba(50, 205, 50, 0.6) !important;
}

/* Mobile Urgency Particles */
@media (max-width: 768px) {
    .urgency-particle {
        width: 3px !important;
        height: 3px !important;
    }
}

/* Hidden problematic elements */
.round-intro {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
}

/* =================================
   ANIMATIONS
   ================================= */

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes promoGlow {
    0%, 100% { 
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2); 
    }
    50% { 
        box-shadow: 0 8px 32px rgba(255, 215, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.3); 
    }
}

@keyframes appearPop {
    0% { transform: scale(0); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes achievementPop {
    0% { transform: translate(-50%, -50%) scale(0); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

@keyframes slideInFromTop {
    0% {
        transform: translateY(-100%);
        opacity: 0;
    }
    100% {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes slideInLeft {
    0% {
        transform: translateX(-100%);
        opacity: 0;
    }
    100% {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutLeft {
    0% {
        transform: translateX(0);
        opacity: 1;
    }
    100% {
        transform: translateX(-100%);
        opacity: 0;
    }
}

@keyframes particleFly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

@keyframes urgencyParticleFly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    70% {
        transform: translate(calc(var(--tx) * 0.8), calc(var(--ty) * 0.8)) scale(1.2);
        opacity: 0.8;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

@keyframes fadeInBounce {
    0% { opacity: 0; transform: translateY(-20px); }
    100% { opacity: 1; transform: translateY(0); }
}

@keyframes heartBeat {
    0%, 100% { 
        transform: scale(1);
    }
    14% { 
        transform: scale(1.1);
    }
    28% { 
        transform: scale(1);
    }
    42% { 
        transform: scale(1.1);
    }
    70% { 
        transform: scale(1);
    }
}

@keyframes heartBreak {
    0% { 
        transform: scale(1); 
        opacity: 1; 
        filter: hue-rotate(0deg);
        color: #d5365a;
    }
    25% { 
        transform: scale(1.2) rotate(5deg); 
        filter: hue-rotate(90deg);
        color: #ff6b6b;
    }
    50% { 
        transform: scale(1.3) rotate(-5deg); 
        filter: hue-rotate(180deg);
        color: #666;
    }
    75% { 
        transform: scale(0.9) rotate(3deg); 
        filter: hue-rotate(270deg);
        color: #333;
    }
    100% { 
        transform: scale(0.8); 
        opacity: 0.3; 
        filter: grayscale(100%);
        color: #444;
    }
}

@keyframes heartGain {
    0% { 
        transform: scale(0.8); 
        opacity: 0.5;
        filter: brightness(0.5);
    }
    25% { 
        transform: scale(1.2); 
        opacity: 0.8;
        filter: brightness(1.2);
    }
    50% { 
        transform: scale(1.4); 
        opacity: 1;
        filter: brightness(1.5) drop-shadow(0 0 15px #d5365a);
    }
    75% { 
        transform: scale(1.1); 
        opacity: 1;
        filter: brightness(1.2);
    }
    100% { 
        transform: scale(1); 
        opacity: 1;
        filter: brightness(1);
    }
}

@keyframes heartGlow {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.6;
        background: radial-gradient(circle, rgba(213, 54, 90, 0.4) 0%, transparent 70%);
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0.9;
        background: radial-gradient(circle, rgba(213, 54, 90, 0.8) 0%, transparent 70%);
    }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10% { transform: translateX(-2px) translateY(-1px); }
    20% { transform: translateX(2px) translateY(1px); }
    30% { transform: translateX(-3px) translateY(-2px); }
    40% { transform: translateX(3px) translateY(2px); }
    50% { transform: translateX(-2px) translateY(-1px); }
    60% { transform: translateX(2px) translateY(1px); }
    70% { transform: translateX(-1px) translateY(-1px); }
    80% { transform: translateX(1px) translateY(1px); }
    90% { transform: translateX(-1px) translateY(0); }
}

/* Mobile Shake Animation */
@media (max-width: 768px) {
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10% { transform: translateX(-1px) translateY(-0.5px); }
        20% { transform: translateX(1px) translateY(0.5px); }
        30% { transform: translateX(-1.5px) translateY(-1px); }
        40% { transform: translateX(1.5px) translateY(1px); }
        50% { transform: translateX(-1px) translateY(-0.5px); }
        60% { transform: translateX(1px) translateY(0.5px); }
        70% { transform: translateX(-0.5px) translateY(-0.5px); }
        80% { transform: translateX(0.5px) translateY(0.5px); }
        90% { transform: translateX(-0.5px) translateY(0); }
    }
}

@keyframes achievementUnlock {
    0% { 
        transform: scale(0.9); 
        opacity: 0.4; 
        color: #fff;
        background: transparent;
    }
    25% { 
        transform: scale(1.1); 
        opacity: 0.8; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.1);
        text-shadow: 0 0 10px #FFD700;
    }
    50% { 
        transform: scale(1.15); 
        opacity: 1; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.2);
        text-shadow: 0 0 15px #FFD700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    75% { 
        transform: scale(1.05); 
        opacity: 1; 
        color: #FFD700;
        background: rgba(255, 215, 0, 0.1);
        text-shadow: 0 0 12px #FFD700;
    }
    100% { 
        transform: scale(1); 
        opacity: 1; 
        color: #FFD700;
        background: transparent;
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    }
}

@keyframes achievementPulse {
    0%, 100% { 
        transform: scale(1); 
        text-shadow: 0 0 5px #FFD700;
    }
    50% { 
        transform: scale(1.03); 
        text-shadow: 0 0 12px #FFD700;
    }
}

@keyframes criticalRingIntense {
    0%, 100% { 
        transform: scale(1);
        border-width: 6px;
        opacity: 1;
        box-shadow: 0 0 25px rgba(255, 68, 68, 1);
    }
    25% { 
        transform: scale(1.15);
        border-width: 8px;
        opacity: 0.9;
        box-shadow: 0 0 35px rgba(255, 68, 68, 1);
    }
    50% { 
        transform: scale(1.25);
        border-width: 10px;
        opacity: 0.8;
        box-shadow: 0 0 45px rgba(255, 68, 68, 1);
    }
    75% { 
        transform: scale(1.15);
        border-width: 8px;
        opacity: 0.9;
        box-shadow: 0 0 35px rgba(255, 68, 68, 1);
    }
}

@keyframes warningRingMedium {
    0%, 100% { 
        transform: scale(1);
        border-width: 4px;
        opacity: 0.9;
        box-shadow: 0 0 20px rgba(255, 165, 0, 0.8);
    }
    33% { 
        transform: scale(1.08);
        border-width: 5px;
        opacity: 1;
        box-shadow: 0 0 25px rgba(255, 165, 0, 1);
    }
    66% { 
        transform: scale(1.12);
        border-width: 6px;
        opacity: 0.95;
        box-shadow: 0 0 30px rgba(255, 165, 0, 0.9);
    }
}

@keyframes safeRingGentle {
    0%, 100% { 
        transform: scale(1);
        border-width: 3px;
        opacity: 0.7;
        box-shadow: 0 0 15px rgba(50, 205, 50, 0.6);
    }
    50% { 
        transform: scale(1.04);
        border-width: 4px;
        opacity: 0.9;
        box-shadow: 0 0 20px rgba(50, 205, 50, 0.8);
    }
}

@keyframes trophyPulse {
    0%, 100% { 
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        transform: scale(1);
    }
    25% { 
        box-shadow: 0 0 35px rgba(255, 215, 0, 0.9);
        transform: scale(1.02);
    }
    50% { 
        box-shadow: 0 0 45px rgba(255, 215, 0, 1);
        transform: scale(1.05);
    }
    75% { 
        box-shadow: 0 0 40px rgba(255, 215, 0, 0.95);
        transform: scale(1.03);
    }
}

@keyframes trophySparkle {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
    }
    20% {
        transform: scale(1.2) rotate(180deg);
        opacity: 1;
    }
    80% {
        transform: scale(1) rotate(360deg);
        opacity: 1;
    }
    100% {
        transform: scale(0) rotate(540deg);
        opacity: 0;
    }
}

@keyframes boosterRingExpand {
    0% {
        transform: scale(0.5);
        opacity: 1;
        border-width: 3px;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.8;
        border-width: 2px;
    }
    100% {
        transform: scale(2);
        opacity: 0;
        border-width: 1px;
    }
}

@keyframes screenFlash {
    0% {
        opacity: var(--flash-opacity, 0.3);
    }
    50% {
        opacity: calc(var(--flash-opacity, 0.3) * 0.6);
    }
    100% {
        opacity: 0;
    }
}

@keyframes sparkleFloat {
    0% {
        transform: translateY(0) scale(0);
        opacity: 1;
    }
    50% {
        transform: translateY(-15px) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-25px) scale(0);
        opacity: 0;
    }
}

@keyframes comboFloat {
    0% {
        transform: scale(0.5) translateY(0);
        opacity: 1;
    }
    50% {
        transform: scale(1.2) translateY(-20px);
        opacity: 1;
    }
    100% {
        transform: scale(1) translateY(-40px);
        opacity: 0;
    }
}

/* =================================
   SILHOUETTE ANIMATIONS
   ================================= */

@keyframes gentleSway {
    0%, 100% { 
        transform: translate(-50%, -50%) rotate(-1deg) scale(1);
    }
    50% { 
        transform: translate(-50%, -50%) rotate(1deg) scale(1.02);
    }
}

@keyframes intimatePulse {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.05);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.8));
    }
}

@keyframes passionateBreathe {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.8;
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.03);
        opacity: 0.9;
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.06);
        opacity: 1;
    }
}

@keyframes tenderRock {
    0%, 100% { 
        transform: translate(-50%, -50%) rotate(-0.5deg);
    }
    25% { 
        transform: translate(-50%, -50%) rotate(0.5deg) scale(1.01);
    }
    50% { 
        transform: translate(-50%, -50%) rotate(-0.3deg);
    }
    75% { 
        transform: translate(-50%, -50%) rotate(0.3deg) scale(1.01);
    }
}

@keyframes lovingEmbrace {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) hue-rotate(0deg);
    }
    33% { 
        transform: translate(-50%, -50%) scale(1.02);
        filter: drop-shadow(0 0 25px rgba(213, 54, 90, 0.6)) hue-rotate(10deg);
    }
    66% { 
        transform: translate(-50%, -50%) scale(1.04);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.7)) hue-rotate(-10deg);
    }
}

@keyframes romanticGlow {
    0%, 100% { 
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) brightness(1);
    }
    50% { 
        filter: drop-shadow(0 0 40px rgba(255, 215, 0, 0.6)) brightness(1.2);
    }
}

@keyframes intenseConnection {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.03);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.7));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.06);
        filter: drop-shadow(0 0 40px rgba(213, 54, 90, 0.9));
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.03);
        filter: drop-shadow(0 0 35px rgba(213, 54, 90, 0.8));
    }
}

@keyframes ultimateUnity {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.8)) 
                drop-shadow(0 0 60px rgba(255, 215, 0, 0.4));
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.02) rotate(0.5deg);
        filter: drop-shadow(0 0 40px rgba(213, 54, 90, 0.9)) 
                drop-shadow(0 0 80px rgba(255, 215, 0, 0.6));
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.05) rotate(0deg);
        filter: drop-shadow(0 0 50px rgba(213, 54, 90, 1)) 
                drop-shadow(0 0 100px rgba(255, 215, 0, 0.8));
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.02) rotate(-0.5deg);
        filter: drop-shadow(0 0 45px rgba(213, 54, 90, 0.95)) 
                drop-shadow(0 0 90px rgba(255, 215, 0, 0.7));
    }
}

/* Mobile-Safe Silhouette Animations */
@keyframes mobileGentleSway {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.01) rotate(0deg);
    }
}

@keyframes mobileIntimateLevel {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
        opacity: 0.8;
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.02);
        filter: drop-shadow(0 0 25px rgba(213, 54, 90, 0.7));
        opacity: 0.9;
    }
}

/* Silhouette Animation Classes */
.silhouette-gentle-sway {
    animation: gentleSway 6s ease-in-out infinite;
}

.silhouette-intimate-pulse {
    animation: intimatePulse 4s ease-in-out infinite;
}

.silhouette-passionate-breathe {
    animation: passionateBreathe 3s ease-in-out infinite;
}

.silhouette-tender-rock {
    animation: tenderRock 8s ease-in-out infinite;
}

.silhouette-loving-embrace {
    animation: lovingEmbrace 5s ease-in-out infinite;
}

.silhouette-romantic-glow {
    animation: romanticGlow 7s ease-in-out infinite;
}

.silhouette-intense-connection {
    animation: intenseConnection 4s ease-in-out infinite;
}

.silhouette-ultimate-unity {
    animation: ultimateUnity 6s ease-in-out infinite;

</style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
       <div class="glass" style="padding: 40px; max-width: 500px; width: 90%; text-align: center;">
        <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
        <h2>Loading Endless Embrace...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>
    <div class="loading-tip loading-tip-custom" id="loadingTip">
        <p>💡 Pro tip: Lasting longer starts with the right preparation... 😉</p>
    </div>
   </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <div class="glass start-panel">
            <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
            <h1>Endless Embrace</h1>
            <img src="https://assets.codepen.io/t-24779/bg-seated-embrace-pose.png" alt="Endless Embrace" class="game-logo">
            <p style="color: #FFD700; font-size: 1.2rem; margin: 20px 0;">Kill the mood killers. Last Longer</p>
            <button class="btn" onclick="showScreen('gameScreen')">Play Game</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        <div class="couple-silhouette" id="coupleSilhouette" style="display: none;">
            <img id="silhouetteImage" src="" alt="Couple">
        </div>
        <div class="game-hud">
            <div class="hud-top">
                <div class="score-display">
                    Score: <span id="score">0</span>
                </div>
                <div class="intimacy-meter" id="intimacyMeter">
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                    <span class="heart active">❤️</span>
                </div>
            </div>
            <!-- Achievement Board positioned below score -->
            <div class="achievement-board" id="achievementBoard" style="display: none;">
                <h4>🏆 Achievements</h4>
                <ul>
                    <li><span class="icon">🎯</span> Quick Draw: &lt;0.8s</li>
                    <li><span class="icon">🔥</span> Perfect Round</li>
                    <li><span class="icon">💪</span> Multi-Position: 3 in 2s</li>
                    <li><span class="icon">🌡️</span> Heat Wave: 7+ streak</li>
                    <li><span class="icon">⚡</span> 3X Warrior: 150+ pts</li>
                    <li><span class="icon">⏰</span> Speed Demon: R1 &lt;30s</li>
                </ul>
            </div>
        </div>
        <div class="audio-toggle" id="audioToggle" onclick="toggleAudio()">
            <span id="audioIcon">🔊</span>
        </div>
    </div>

    <!-- Results Screen -->
    <div id="resultsScreen" class="screen">
        <div class="glass results-panel">
            <h1 style="color: #d5365a; margin-bottom: 10px; font-size: 2.5rem;">GAME OVER</h1>
            <p style="font-size: 2rem; color: #FFD700; margin-bottom: 20px;">
                Score: <span id="finalScore">0</span>
            </p>
            <p id="performanceMessage" style="margin-bottom: 20px;"></p>

        <div class="promo-section" style="margin: 20px 0;">
            <button class="btn btn-promo" onclick="window.open('https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756','_blank')">
             🎉 20% OFF
            </button>
           </div>
            
            <div class="image-row">
                <div class="qr-code" id="qrCode" style="background: #fff; padding: 10px;">
                    <!-- QR Code will be generated here -->
                </div>
                <img src="https://assets.codepen.io/t-24779/KamaSutra-longlast-product.png" alt="KamaSutra LongLast" class="product-display" style="height: 150px; width: auto;">
            </div>
            
            <div class="button-row">
                <button class="btn btn-gold btn-small" onclick="saveQRCode()">Save Code</button>
                <a href="https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756" target="_blank" class="btn btn-gold btn-small" style="text-decoration: none;">
                    Passion 3X  
                </a>
            </div>
            
            <p style="font-size: 1rem; margin: 15px 0;">
                For longer lasting moments, choose KamaSutra LongLast.<br>
                <span style="color: #FFD700; font-weight: bold;">3X Longer Lasting!</span>
            </p>
            
            <!-- Challenge Section -->
            <div class="challenge-section">
                <p style="font-size: 0.9rem; margin-bottom: 10px;">🔥 Couple Challenge Mode 🔥</p>
                <div class="challenge-code" id="challengeCode">------</div>
                <div id="coupleStatus" style="margin: 10px 0; display: none;">
                    <p style="font-size: 0.8rem;" id="challengeStatusText"></p>
                </div>
                <button class="btn btn-secondary btn-small" onclick="generateChallengeCode()">Generate Challenge Code</button>
                <button class="btn btn-secondary btn-small" onclick="showEnterCode()" style="margin-top: 5px;">Enter Partner's Code</button>
            </div>
            
            <!-- Couple Results Display -->
            <div class="couple-results" id="coupleResults" style="display: none;">
                <h3 style="color: #FFD700;">💕 Couple Challenge Results</h3>
                <div class="performance-comparison">
                    <div class="player-stats">
                        <h4>You</h4>
                        <div class="score" id="yourScore">0</div>
                    </div>
                    <div class="vs-indicator">VS</div>
                    <div class="partner-stats">
                        <h4>Partner</h4>
                        <div class="score" id="partnerScore">0</div>
                    </div>
                </div>
                <div class="combined-metrics">
                    <h4>Together You Achieved:</h4>
                    <div class="metric">
                        <span class="label">Total Score:</span>
                        <span class="value" id="totalScore">0</span>
                    </div>
                    <div class="metric">
                        <span class="label">Harmony Level:</span>
                        <span class="value" id="harmonyLevel">-</span>
                    </div>
                    <div class="metric">
                        <span class="label">Combined Time:</span>
                        <span class="value" id="combinedTime">0s</span>
                    </div>
                </div>
            </div>
            
            <div class="share-buttons">
                <div class="share-btn" onclick="shareWhatsApp()">
                    <span>📱</span>
                    <span>WhatsApp</span>
                </div>
            </div>
            
            <button class="btn" style="margin-top: 20px;" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <!-- Achievement Popup - Desktop Only -->
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon" id="achievementIcon">🏆</div>
        <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
        <div class="achievement-desc" id="achievementDesc">Description</div>
    </div>

    <!-- Round Complete Popup - Desktop Only -->
    <div id="roundCompletePopup" class="round-complete-popup">
        <div style="font-size: 1.5rem;">✨</div>
        <div style="font-weight: bold; margin: 5px 0;">Round <span id="roundNumber"></span> Complete!</div>
        <div style="font-size: 0.85rem;">Your embrace deepens...</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    
   <script>

// Performance monitoring
const performanceMonitor = {
    fps: 0,
    frameCount: 0,
    lastTime: performance.now(),
    memoryWarning: false,
    
    update() {
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
            this.frameCount = 0;
            this.lastTime = now;
            
            // Performance warnings
            if (this.fps < 30 && !this.memoryWarning) {
                console.warn('⚠️ Low FPS detected:', this.fps);
                this.optimizePerformance();
            }
        }
    },
    
    optimizePerformance() {
        // Reduce particle count on low-performance devices
        if (particleSystem && this.fps < 20) {
            const positions = particleSystem.geometry.attributes.position.array;
            particleSystem.geometry.attributes.position.count = Math.floor(positions.length / 6);
            console.log('🔧 Reduced particle count for better performance');
        }
        this.memoryWarning = true;
    }
};

// Global error handler
window.addEventListener('error', (event) => {
    console.error('🚨 Global Error:', event.error);
    emergencySave();
    gracefulRecover();
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('🚨 Unhandled Promise Rejection:', event.reason);
    event.preventDefault();
    gracefulRecover();
});

// Emergency save functionality
function emergencySave() {
    try {
        const emergencyData = {
            score: gameState.score,
            round: gameState.currentRound,
            hearts: gameState.intimacyHearts,
            achievements: Array.from(gameState.achievements),
            timestamp: Date.now()
        };
        localStorage.setItem('emergency_save', JSON.stringify(emergencyData));
        console.log('💾 Emergency save completed');
    } catch (error) {
        console.error('Emergency save failed:', error);
    }
}

// Graceful error recovery
function gracefulRecover() {
    try {
        // Stop all active processes
        if (gameState.spawnTimeout) clearTimeout(gameState.spawnTimeout);
        if (gameState.multiKillTimer) clearTimeout(gameState.multiKillTimer);
        
        // Clean up distractions
        gameState.distractions.forEach(d => {
            if (d.timerInterval) clearInterval(d.timerInterval);
            if (d.parentNode) d.remove();
        });
        
        // Reset critical states
        gameState.gameRunning = false;
        gameState.roundInProgress = false;
        
        // Show recovery message
        showHint("Game recovered from error. Continue playing! 🛡️");
        
        console.log('🔧 Graceful recovery completed');
    } catch (error) {
        console.error('Recovery failed:', error);
        // Last resort - reload page
        setTimeout(() => location.reload(), 2000);
    }
}

// Enhanced Game State with better management
const gameState = {
    currentScreen: 'loading',
    currentRound: 1,
    score: 0,
    lives: 5,
    intimacyHearts: 5,
    maxHearts: 5,
    consecutiveMisses: 0,
    lastMissTime: 0,
    streak: 0,
    bestStreak: 0,
    achievements: new Set(),
    distractions: [],
    lastDistraction: 0,
    gameRunning: false,
    audioEnabled: true,
    roundScore: 0,
    totalEliminations: 0,
    perfectRounds: 0,
    gameStartTime: 0,
    tipIndex: 0,
    lastScore: 0,
    roundMissed: 0,
    comboCount: 0,
    comboMultiplier: 1,
    lastEliminationTime: 0,
    comboTimeWindow: 2000, 
    multiKillTimer: null,
    multiKillCount: 0,
    challengeCode: null,
    distractionsSpawned: 0,
    distractionsRequired: 5,
    roundStartTime: 0,
    spawnTimeout: null,
    roundInProgress: false,
    achievementShown: new Set(),
    heartUpdateInProgress: false,
    isMobile: window.innerWidth <= 768,
    gameplayStarted: false,
    comboTutorialShown: false,
    lastShakeTime: 0,
    shakeIntensity: 1,
    trophyBonusShown: false,
    totalTrophiesCollected: 0,
    priorityTutorialShown: false,
    gameEnding: false,
    
    // State management
    cleanup() {
        if (this.spawnTimeout) clearTimeout(this.spawnTimeout);
        if (this.multiKillTimer) clearTimeout(this.multiKillTimer);
        this.distractions.forEach(d => {
            if (d.timerInterval) clearInterval(d.timerInterval);
            if (d.parentNode) d.remove();
        });
        this.distractions = [];
        this.gameRunning = false;
        this.roundInProgress = false;
    },
    
    reset() {
        this.cleanup();
        Object.assign(this, {
            currentRound: 1,
            score: 0,
            lives: 5,
            intimacyHearts: 5,
            consecutiveMisses: 0,
            streak: 0,
            roundScore: 0,
            totalEliminations: 0,
            perfectRounds: 0,
            roundMissed: 0,
            multiKillCount: 0,
            distractionsSpawned: 0,
            gameplayStarted: false,
            gameEnding: false,
            heartUpdateInProgress: false
        });
        this.achievements.clear();
        this.achievementShown.clear();
    }
};

 // Message queues
    const messageQueue = {
    queue: [],
    isShowing: false,
    
    add(message, type = 'hint', duration = 2000) {
        this.queue.push({ message, type, duration });
        this.processQueue();
    },
    
    processQueue() {
        if (this.isShowing || this.queue.length === 0) return;
        
        this.isShowing = true;
        const { message, type, duration } = this.queue.shift();
        
        this.showMessage(message, type, duration);
    },
    
    showMessage(message, type, duration) {
        try {
            const messageEl = document.createElement('div');
            
            // Always center the message properly
            messageEl.style.cssText = `
                position: fixed;
                top: 35%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 12px 20px;
                border-radius: 15px;
                font-size: 0.9rem;
                font-weight: bold;
                z-index: 1500;
                max-width: 280px;
                text-align: center;
                border: 2px solid ${type === 'combo' ? '#FFD700' : '#FF4444'};
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
                animation: messageSlideIn 0.4s ease-out forwards;
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            `;
            
            messageEl.textContent = message;
            document.body.appendChild(messageEl);
            
            // Fade out and remove
            const timeoutId = setTimeout(() => {
                messageEl.style.animation = 'messageSlideOut 0.4s ease-out forwards';
                
                const removeTimeoutId = setTimeout(() => {
                    if (messageEl.parentNode) {
                        messageEl.remove();
                    }
                    this.isShowing = false;
                    
                    // Process next message in queue
                    setTimeout(() => this.processQueue(), 200);
                }, 400);
                cleanupTracker.addTimeout(removeTimeoutId);
            }, duration);
            cleanupTracker.addTimeout(timeoutId);
            
        } catch (error) {
            console.error('Message display failed:', error);
            this.isShowing = false;
            setTimeout(() => this.processQueue(), 200);
        }
    }
};

// ========================================================================
// MOBILE SYSTEM Set Up
// ========================================================================

// 1. ENHANCED MOBILE DETECTION AND STATE MANAGEMENT
const mobileState = {
    isMobile: window.innerWidth <= 768,
    isTouch: 'ontouchstart' in window,
    devicePixelRatio: window.devicePixelRatio || 1,
    orientation: window.innerHeight > window.innerWidth ? 'portrait' : 'landscape',
    lastTouchTime: 0,
    touchStartPosition: { x: 0, y: 0 },
    touchMoveThreshold: 10,
    vibrationSupported: 'vibrate' in navigator,
    
    // Performance tracking for mobile
    performance: {
        frameDrops: 0,
        averageFPS: 60,
        lowFPSCount: 0
    },
    
    // Update mobile state
    update() {
        this.isMobile = window.innerWidth <= 768;
        this.orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    }
};

// 2. ENHANCED TOUCH FEEDBACK SYSTEM
class TouchFeedbackManager {
    constructor() {
        this.feedbackQueue = [];
        this.isProcessing = false;
        this.lastFeedbackTime = 0;
        this.feedbackCooldown = 50; // Prevent feedback spam
    }
    
    // Enhanced haptic feedback with patterns
    haptic(pattern = 'light', force = false) {
        if (!mobileState.vibrationSupported && !force) return;
        
        const now = Date.now();
        if (now - this.lastFeedbackTime < this.feedbackCooldown && !force) return;
        
        let vibrationPattern;
        switch (pattern) {
            case 'light':
                vibrationPattern = [20];
                break;
            case 'medium':
                vibrationPattern = [50];
                break;
            case 'heavy':
                vibrationPattern = [80];
                break;
            case 'double':
                vibrationPattern = [30, 20, 30];
                break;
            case 'triple':
                vibrationPattern = [20, 15, 20, 15, 20];
                break;
            case 'success':
                vibrationPattern = [10, 10, 10];
                break;
            case 'error':
                vibrationPattern = [100, 50, 100];
                break;
            case 'combo':
                vibrationPattern = [15, 10, 25, 10, 35];
                break;
            default:
                vibrationPattern = [30];
        }
        
        try {
            if (gameState.audioEnabled && navigator.vibrate) {
                navigator.vibrate(vibrationPattern);
                this.lastFeedbackTime = now;
            }
        } catch (error) {
            console.log('Haptic feedback failed:', error);
        }
    }
    
    // Visual touch feedback
    showTouchRipple(x, y, color = '#FFD700') {
        const ripple = document.createElement('div');
        ripple.style.cssText = `
            position: fixed;
            left: ${x - 25}px;
            top: ${y - 25}px;
            width: 50px;
            height: 50px;
            border: 2px solid ${color};
            border-radius: 50%;
            pointer-events: none;
            z-index: 3000;
            animation: touchRipple 0.4s ease-out forwards;
            opacity: 0.8;
        `;
        
        document.body.appendChild(ripple);
        
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.remove();
            }
        }, 400);
    }
    
    // Enhanced button press feedback
    buttonPress(element, intensity = 'medium') {
        if (!element) return;
        
        // Visual feedback
        element.style.transform = 'scale(0.95)';
        element.style.transition = 'transform 0.1s ease-out';
        
        // Haptic feedback
        this.haptic(intensity);
        
        // Reset visual state
        setTimeout(() => {
            element.style.transform = '';
            element.style.transition = '';
        }, 100);
    }
    
    // Distraction touch feedback
    distractionHit(element, urgency = 'safe') {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        // Color based on urgency
        let color = '#32CD32'; // Safe - green
        let hapticPattern = 'light';
        
        if (urgency === 'critical') {
            color = '#FF4444';
            hapticPattern = 'heavy';
        } else if (urgency === 'warning') {
            color = '#FFA500';
            hapticPattern = 'medium';
        }
        
        // Show visual ripple
        this.showTouchRipple(x, y, color);
        
        // Enhanced haptic feedback
        this.haptic(hapticPattern);
    }
}

// 3. MOBILE-OPTIMIZED EVENT HANDLING
class MobileEventHandler {
    constructor() {
        this.lastTouchEnd = 0;
        this.touchStartTime = 0;
        this.touchStartPos = { x: 0, y: 0 };
        this.preventNextClick = false;
        this.touchMoveDistance = 0;
        
        this.setupMobileEvents();
    }
    
    setupMobileEvents() {
        // Enhanced touch start handling
        document.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e);
        }, { passive: false });
        
        // Enhanced touch move handling  
        document.addEventListener('touchmove', (e) => {
            this.handleTouchMove(e);
        }, { passive: false });
        
        // Enhanced touch end handling
        document.addEventListener('touchend', (e) => {
            this.handleTouchEnd(e);
        }, { passive: false });
        
        // Prevent double-tap zoom
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
        
        // Handle orientation change with better timing
        window.addEventListener('orientationchange', () => {
            this.handleOrientationChange();
        });
        
        // Handle visibility changes for mobile power management
        document.addEventListener('visibilitychange', () => {
            this.handleVisibilityChange();
        });
    }
    
    handleTouchStart(e) {
        const touch = e.touches[0];
        this.touchStartTime = Date.now();
        this.touchStartPos = { x: touch.clientX, y: touch.clientY };
        this.touchMoveDistance = 0;
        
        // Immediate haptic feedback for responsive feel
        if (this.isInteractiveElement(e.target)) {
            touchFeedback.haptic('light');
        }
        
        // Prevent scrolling on game screen
        if (e.target.closest('#gameScreen') && gameState.gameRunning) {
            e.preventDefault();
        }
    }
    
    handleTouchMove(e) {
        if (!e.touches[0]) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - this.touchStartPos.x;
        const deltaY = touch.clientY - this.touchStartPos.y;
        this.touchMoveDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Prevent scrolling during gameplay
        if (gameState.gameRunning && e.target.closest('#gameScreen')) {
            e.preventDefault();
        }
        
        // Allow scrolling in results screen
        if (e.target.closest('.results-panel, .modal-content')) {
            return; // Let natural scrolling happen
        }
    }
    
    handleTouchEnd(e) {
        const touchDuration = Date.now() - this.touchStartTime;
        const now = Date.now();
        
        // Prevent double-tap zoom
        if (now - this.lastTouchEnd <= 300) {
            e.preventDefault();
            this.preventNextClick = true;
            setTimeout(() => {
                this.preventNextClick = false;
            }, 100);
        }
        this.lastTouchEnd = now;
        
        // Only trigger interaction if it's a tap (not a drag)
        if (this.touchMoveDistance < mobileState.touchMoveThreshold) {
            // This was a tap, not a drag
            if (gameState.gameRunning) {
                this.handleGameTap(e);
            } else {
                this.handleMenuTap(e);
            }
        }
    }
    
    handleGameTap(e) {
        if (!gameState.gameRunning || this.preventNextClick) return;
        
        const touch = e.changedTouches[0];
        const x = touch.clientX;
        const y = touch.clientY;
        
        // Find distraction at touch point with improved hit detection
        const distractions = document.querySelectorAll('.distraction');
        let hitDetected = false;
        
        distractions.forEach(distraction => {
            if (!distraction.parentNode) return;
            
            const rect = distraction.getBoundingClientRect();
            
            // Expand hit area for mobile (easier to tap)
            const padding = 10;
            const expandedRect = {
                left: rect.left - padding,
                top: rect.top - padding,
                right: rect.right + padding,
                bottom: rect.bottom + padding
            };
            
            if (x >= expandedRect.left && x <= expandedRect.right && 
                y >= expandedRect.top && y <= expandedRect.bottom) {
                
                hitDetected = true;
                const urgency = distraction.dataset.urgency || 'safe';
                
                // Enhanced mobile feedback
                touchFeedback.distractionHit(distraction, urgency);
                
                // Eliminate with enhanced feedback
                eliminateDistraction(distraction);
            }
        });
        
        // Miss feedback
        if (!hitDetected && distractions.length > 0) {
            touchFeedback.haptic('light');
            touchFeedback.showTouchRipple(x, y, '#FF6666');
        }
    }
    
    handleMenuTap(e) {
        if (this.preventNextClick) return;
        
        const touch = e.changedTouches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (element && element.closest('.btn')) {
            const button = element.closest('.btn');
            touchFeedback.buttonPress(button, 'medium');
        }
    }
    
    handleOrientationChange() {
        // Delay to allow orientation to settle
        setTimeout(() => {
            mobileState.update();
            
            // Trigger resize handling
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Update mobile-specific UI
            this.updateMobileUI();
            
            // Show orientation hint if needed
            if (mobileState.isMobile && gameState.gameRunning) {
                const orientationHint = mobileState.orientation === 'portrait' ? 
                    "💡 Try landscape mode for better gameplay!" : 
                    "👍 Landscape mode is perfect for this game!";
                
                messageQueue.add(orientationHint, 'hint', 2000);
            }
        }, 200);
    }
    
    handleVisibilityChange() {
        if (document.hidden) {
            // Pause/reduce activity when tab is hidden (mobile power saving)
            if (gameState.gameRunning) {
                emergencySave();
            }
            
            // Reduce particle count for performance
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                particleSystem.geometry.attributes.position.count = Math.floor(positions.length / 3);
            }
        } else {
            // Resume when visible
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                particleSystem.geometry.attributes.position.count = positions.length / 3;
            }
        }
    }
    
    updateMobileUI() {
        // Update achievement board visibility
        if (gameState.gameRunning) {
            updateAchievementBoardVisibility();
        }
        
        // Adjust UI scaling based on device pixel ratio
        if (mobileState.devicePixelRatio > 2) {
            document.documentElement.style.setProperty('--mobile-scale', '0.9');
        } else {
            document.documentElement.style.setProperty('--mobile-scale', '1');
        }
    }
    
    isInteractiveElement(element) {
        return element.closest('.btn, .distraction, .heart, .audio-toggle');
    }
}

// 4. MOBILE PERFORMANCE OPTIMIZATION
class MobilePerformanceManager {
    constructor() {
        this.frameCount = 0;
        this.lastFPSTime = performance.now();
        this.performanceMode = 'normal'; // normal, performance, potato
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        const checkPerformance = () => {
            this.frameCount++;
            const now = performance.now();
            
            if (now - this.lastFPSTime >= 1000) {
                const fps = Math.round((this.frameCount * 1000) / (now - this.lastFPSTime));
                mobileState.performance.averageFPS = fps;
                
                if (fps < 25) {
                    mobileState.performance.lowFPSCount++;
                    if (mobileState.performance.lowFPSCount > 3) {
                        this.optimizeForPerformance();
                    }
                } else {
                    mobileState.performance.lowFPSCount = Math.max(0, mobileState.performance.lowFPSCount - 1);
                }
                
                this.frameCount = 0;
                this.lastFPSTime = now;
            }
            
            requestAnimationFrame(checkPerformance);
        };
        
        checkPerformance();
    }
    
    optimizeForPerformance() {
        if (this.performanceMode === 'potato') return;
        
        console.log('📱 Optimizing for mobile performance...');
        
        // Reduce particle count
        if (particleSystem) {
            const positions = particleSystem.geometry.attributes.position.array;
            particleSystem.geometry.attributes.position.count = Math.floor(positions.length / 2);
        }
        
        // Reduce animation complexity
        document.documentElement.style.setProperty('--animation-scale', '0.7');
        
        // Lower renderer pixel ratio
        if (renderer && mobileState.devicePixelRatio > 1) {
            renderer.setPixelRatio(Math.min(mobileState.devicePixelRatio, 1.5));
        }
        
        this.performanceMode = 'performance';
        
        // Show performance optimization message
        if (mobileState.isMobile && gameState.gameRunning) {
            messageQueue.add("🚀 Performance optimized for your device!", 'hint', 2000);
        }
    }
}

// 5. MOBILE-SPECIFIC UI IMPROVEMENTS
function initMobileUI() {
    // Add mobile-specific CSS variables
    const mobileCSS = `
        :root {
            --mobile-scale: 1;
            --animation-scale: 1;
        }
        
        @media (max-width: 768px) {
            .distraction-icon {
                width: calc(70px * var(--mobile-scale)) !important;
                height: calc(70px * var(--mobile-scale)) !important;
                font-size: calc(2rem * var(--mobile-scale)) !important;
            }
            
            .btn {
                min-height: 48px !important;
                padding: 12px 20px !important;
                font-size: calc(1rem * var(--mobile-scale)) !important;
                transform: scale(var(--mobile-scale));
            }
            
            .hint-popup, .mobile-achievement-notification {
                font-size: calc(0.85rem * var(--mobile-scale)) !important;
                transform: scale(var(--animation-scale));
            }
        }
    `;
    
    // Add touch ripple animation
    const touchRippleCSS = `
        @keyframes touchRipple {
            0% {
                transform: scale(0);
                opacity: 0.8;
            }
            50% {
                transform: scale(1);
                opacity: 0.4;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
    `;
    
    // Add CSS to page
    if (!document.getElementById('mobileEnhancementCSS')) {
        const style = document.createElement('style');
        style.id = 'mobileEnhancementCSS';
        style.textContent = mobileCSS + touchRippleCSS;
        document.head.appendChild(style);
    }
}

// 6. INITIALIZE MOBILE SYSTEMS
const touchFeedback = new TouchFeedbackManager();
const mobileEventHandler = new MobileEventHandler();
const mobilePerformanceManager = new MobilePerformanceManager();

// Initialize mobile UI on page load
document.addEventListener('DOMContentLoaded', () => {
    initMobileUI();
    mobileState.update();
});

// 7. MOBILE-OPTIMIZED UTILITY FUNCTIONS
function mobileVibrate(pattern = [50], force = false) {
    if (mobileState.isMobile || force) {
        touchFeedback.haptic(Array.isArray(pattern) ? 'medium' : pattern, force);
    }
}

function showMobileOptimizedHint(message, duration = 2000) {
    if (mobileState.isMobile) {
        messageQueue.add(message, 'hint', duration);
    } else {
        showHint(message, duration);
    }
}

// Export mobile utilities for use in other functions
window.mobileUtils = {
    state: mobileState,
    touchFeedback: touchFeedback,
    vibrate: mobileVibrate,
    showHint: showMobileOptimizedHint
};

// MESSAGE ANIMATIONS CSS
const messageAnimationCSS = `
@keyframes messageSlideIn {
    0% {
        opacity: 0;
        transform: translate(-50%, -60%) scale(0.8);
    }
    100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes messageSlideOut {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -40%) scale(0.9);
    }
}
`;

// ========================================================================
// PROGRESSIVE DIFFICULTY SYSTEM Set up
// ========================================================================

// 1. DIFFICULTY TRACKING STATE
const difficultyState = {
    // Player performance metrics
    playerSkill: 0.5, // 0 = beginner, 1 = expert
    recentPerformance: [], // Last 10 eliminations
    currentDifficultyLevel: 'normal', // easy, normal, hard, expert
    
    // Performance tracking
    totalEliminations: 0,
    totalMisses: 0,
    averageReactionTime: 1000,
    recentReactionTimes: [],
    perfectRoundsStreak: 0,
    
    // Difficulty modifiers
    spawnRateMultiplier: 1.0,
    reactionTimeMultiplier: 1.0,
    criticalChance: 0.1, // 10% base critical chance
    urgencyDistribution: { critical: 0.1, warning: 0.3, safe: 0.6 },
    
    // Adaptation settings
    adaptationRate: 0.1, // How quickly difficulty adapts
    minDifficulty: 0.2,
    maxDifficulty: 2.0,
    
    // Update player skill based on performance
    updateSkill(reactionTime, success, urgency) {
        // Track reaction time
        this.recentReactionTimes.push(reactionTime);
        if (this.recentReactionTimes.length > 20) {
            this.recentReactionTimes.shift();
        }
        
        // Calculate average reaction time
        this.averageReactionTime = this.recentReactionTimes.reduce((a, b) => a + b, 0) / this.recentReactionTimes.length;
        
        // Track recent performance (1 = success, 0 = miss)
        this.recentPerformance.push(success ? 1 : 0);
        if (this.recentPerformance.length > 10) {
            this.recentPerformance.shift();
        }
        
        // Calculate skill based on multiple factors
        const successRate = this.recentPerformance.reduce((a, b) => a + b, 0) / this.recentPerformance.length;
        const reactionScore = Math.max(0, (2000 - this.averageReactionTime) / 2000);
        const urgencyBonus = urgency === 'critical' ? 0.2 : urgency === 'warning' ? 0.1 : 0;
        
        // Calculate new skill level
        const targetSkill = (successRate * 0.6) + (reactionScore * 0.3) + (urgencyBonus * 0.1);
        
        // Smoothly adjust skill level
        this.playerSkill += (targetSkill - this.playerSkill) * this.adaptationRate;
        this.playerSkill = Math.max(0, Math.min(1, this.playerSkill));
        
        // Update difficulty level
        this.updateDifficultyLevel();
        
        // Log for debugging
        console.log(`🎯 Skill: ${this.playerSkill.toFixed(2)}, Success: ${(successRate * 100).toFixed(0)}%, Avg Time: ${this.averageReactionTime.toFixed(0)}ms, Level: ${this.currentDifficultyLevel}`);
    },
    
    updateDifficultyLevel() {
        if (this.playerSkill < 0.25) {
            this.currentDifficultyLevel = 'easy';
            this.spawnRateMultiplier = 1.3; // Slower spawning
            this.reactionTimeMultiplier = 1.4; // More time to react
            this.criticalChance = 0.05; // Fewer critical distractions
            this.urgencyDistribution = { critical: 0.05, warning: 0.2, safe: 0.75 };
        } else if (this.playerSkill < 0.5) {
            this.currentDifficultyLevel = 'normal';
            this.spawnRateMultiplier = 1.0; // Normal spawning
            this.reactionTimeMultiplier = 1.0; // Normal reaction time
            this.criticalChance = 0.1; // Normal critical chance
            this.urgencyDistribution = { critical: 0.1, warning: 0.3, safe: 0.6 };
        } else if (this.playerSkill < 0.75) {
            this.currentDifficultyLevel = 'hard';
            this.spawnRateMultiplier = 0.85; // Faster spawning
            this.reactionTimeMultiplier = 0.85; // Less time to react
            this.criticalChance = 0.18; // More critical distractions
            this.urgencyDistribution = { critical: 0.18, warning: 0.4, safe: 0.42 };
        } else {
            this.currentDifficultyLevel = 'expert';
            this.spawnRateMultiplier = 0.7; // Much faster spawning
            this.reactionTimeMultiplier = 0.7; // Much less time to react
            this.criticalChance = 0.25; // Many critical distractions
            this.urgencyDistribution = { critical: 0.25, warning: 0.45, safe: 0.3 };
        }
    },
    
    reset() {
        this.recentPerformance = [];
        this.recentReactionTimes = [];
        this.perfectRoundsStreak = 0;
        // Don't reset playerSkill - keep learning across games
    }
};

// 2. ENHANCED DISTRACTION CREATION WITH ADAPTIVE DIFFICULTY
function createAdaptiveDistraction(baseDistractionData, baseReactionTime) {
    try {
        const distraction = document.createElement('div');
        distraction.className = 'distraction'; 
        distraction.dataset.type = baseDistractionData.name;
        distraction.dataset.spawnTime = Date.now();
        distraction.dataset.booster = baseDistractionData.booster || false;

        const isTrophy = Math.random() < 0.05;
        if (isTrophy) {
            distraction.dataset.trophy = 'true';
            distraction.dataset.bonusPoints = '100';
        }

        // ADAPTIVE URGENCY ASSIGNMENT
        const adaptiveUrgency = assignAdaptiveUrgency(baseReactionTime);
        distraction.dataset.urgency = adaptiveUrgency;
        
        // ADAPTIVE REACTION TIME
        const adaptiveReactionTime = Math.floor(baseReactionTime * difficultyState.reactionTimeMultiplier);
        
        // Create distraction HTML (same as before)
        if (baseDistractionData.special === 'sticky') {
            const stickyTexts = [
                "Don't<br>forget<br>milk!",
                "Buy<br>eggs<br>today",
                "Call<br>mom<br>❤️",
                "Meeting<br>at 3pm",
                "Gym<br>tonight!",
                "Pay<br>bills!",
                "Date<br>night<br>8pm",
                "Doctor<br>appt<br>2pm"
            ];
            const randomText = stickyTexts[Math.floor(Math.random() * stickyTexts.length)];
            distraction.innerHTML = `
                <div class="sticky-note">
                    <div style="transform: rotate(${-10 + Math.random() * 20}deg); font-size: 12px;">
                        ${randomText}
                    </div>
                </div>
            `;
        } else {
            const isTrophy = distraction.dataset.trophy === 'true';
            
            if (isTrophy) {
                distraction.innerHTML = `
                    <div class="distraction-icon glass trophy">
                        🏆
                        <div class="trophy-bonus">BONUS!</div>
                        <div class="priority-ring ${adaptiveUrgency}"></div>
                    </div>
                `;
            } else {
                const iconClass = baseDistractionData.booster ? 'distraction-icon glass booster' : 'distraction-icon glass';
                distraction.innerHTML = `
                    <div class="${iconClass}">
                        ${baseDistractionData.icon}
                        <div class="priority-ring ${adaptiveUrgency}"></div>
                    </div>
                `;
            }
        }

        // Positioning with better collision detection
           const safeMargin = gameState.isMobile ? 12 : 8;
           const safeWidth = 100 - (safeMargin * 2);
           const safeHeight = gameState.isMobile ? 50 : 65; // Reduced height on mobile

           let x, y;
           let attempts = 0;
           let validPosition = false;

       do {
           x = safeMargin + Math.random() * safeWidth;
           y = (gameState.isMobile ? 30 : 25) + Math.random() * safeHeight;
           attempts++;
    
         // Check if position conflicts with visible messages
            validPosition = !isPositionOccupiedByMessage(x, y);
    
        } while (!validPosition && attempts < 15);

        // If still no valid position, force to bottom area
          if (!validPosition) {
          x = 20 + Math.random() * 60; // Center area
          y = gameState.isMobile ? 75 : 70; // Bottom area
        }

        distraction.style.left = x + '%';
        distraction.style.top = y + '%';

        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen) {
            gameScreen.appendChild(distraction);
        }
        
        // Tutorial for priority rings
        if (gameState.totalEliminations === 0 && !gameState.priorityTutorialShown) {
            const timeoutId = setTimeout(() => {
                messageQueue.add("🔴 Thick rings = URGENT! 🟠 Medium = Soon! 🟢 Thin = Safe!", 'hint', 3000);
                gameState.priorityTutorialShown = true;
            }, 1000);
            cleanupTracker.addTimeout(timeoutId);
        }

        playSound(baseDistractionData.sound || 'pop', 0.3);
        
        // Play priority ring audio cue
        const timeoutId = setTimeout(() => {
            playPriorityRingCue(adaptiveUrgency);
        }, 200);
        cleanupTracker.addTimeout(timeoutId);
        
        gameState.distractions.push(distraction);

        // ADAPTIVE TIMER LOGIC
        let timeLeft = adaptiveReactionTime;
        const timerInterval = setInterval(() => {
            timeLeft -= 100;
            const timerEl = distraction.querySelector('.distraction-timer');
            if (timerEl) {
                timerEl.textContent = (timeLeft / 1000).toFixed(1);
            }
            
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                cleanupTracker.intervals.delete(timerInterval);
                if (distraction.parentNode && gameState.distractions.includes(distraction)) {
                    failDistraction(distraction);
                }
            }
        }, 100);

        distraction.timerInterval = timerInterval;
        cleanupTracker.addInterval(timerInterval);

    } catch (error) {
        console.error('Adaptive distraction creation failed:', error);
    }
}

    // 3. Collision detection for message areas
function isPositionOccupiedByMessage(x, y) {
    // Check for visible message elements
    const messageSelectors = [
        '.mobile-achievement-notification',
        '.mobile-round-notification', 
        '.hint-popup',
        '.achievement-popup',
        '.round-complete-popup'
    ];
    
    for (let selector of messageSelectors) {
        const messageElements = document.querySelectorAll(selector);
        
        for (let msg of messageElements) {
            // Only check visible elements
            const computedStyle = window.getComputedStyle(msg);
            if (computedStyle.display === 'none' || 
                computedStyle.visibility === 'hidden' || 
                computedStyle.opacity === '0') {
                continue;
            }
            
            const rect = msg.getBoundingClientRect();
            
            // Skip if message is not actually visible on screen
            if (rect.width === 0 || rect.height === 0) continue;
            
            // Convert percentage position to screen coordinates
            const screenX = (x / 100) * window.innerWidth;
            const screenY = (y / 100) * window.innerHeight;
            
            // Larger buffer zone to prevent overlap
            const buffer = gameState.isMobile ? 80 : 60;
            
            if (screenX >= (rect.left - buffer) && 
                screenX <= (rect.right + buffer) &&
                screenY >= (rect.top - buffer) && 
                screenY <= (rect.bottom + buffer)) {
                return true; // Position is occupied
            }
        }
    }
    
    return false; // Position is clear
}

// 4. ADAPTIVE URGENCY ASSIGNMENT
function assignAdaptiveUrgency(baseReactionTime) {
    const distribution = difficultyState.urgencyDistribution;
    const rand = Math.random();
    
    if (rand < distribution.critical) {
        return 'critical';
    } else if (rand < distribution.critical + distribution.warning) {
        return 'warning';
    } else {
        return 'safe';
    }
}

// 5. ADAPTIVE SPAWN RATE SYSTEM
function spawnAdaptiveDistractions() {
    if (!gameState.gameRunning || !gameState.roundInProgress || 
        gameState.distractionsSpawned >= gameState.distractionsRequired) {
        return;
    }
    
    try {
        const round = rounds[gameState.currentRound - 1];
        const distraction = round.distractions[Math.floor(Math.random() * round.distractions.length)];
        
        // Use adaptive distraction creation
        createAdaptiveDistraction(distraction, round.reactionTime);
        gameState.distractionsSpawned++;
        
        console.log(`📍 Spawned adaptive distraction ${gameState.distractionsSpawned}/${gameState.distractionsRequired} (Difficulty: ${difficultyState.currentDifficultyLevel})`);
        
        if (gameState.distractionsSpawned < gameState.distractionsRequired) {
            // ADAPTIVE SPAWN RATE
            const adaptiveSpawnRate = Math.floor(round.spawnRate * difficultyState.spawnRateMultiplier * (0.8 + Math.random() * 0.4));
            
            gameState.spawnTimeout = setTimeout(() => {
                spawnAdaptiveDistractions();
            }, adaptiveSpawnRate);
            cleanupTracker.addTimeout(gameState.spawnTimeout);
        }
    } catch (error) {
        console.error('Adaptive distraction spawning failed:', error);
        gracefulRecover();
    }
}

// 6. DIFFICULTY FEEDBACK SYSTEM
function showDifficultyFeedback() {
    const messages = {
        easy: "🌱 Taking it easy! The game is adapting to help you learn.",
        normal: "⚖️ Perfect balance! You're getting the hang of this.",
        hard: "🔥 Challenge mode activated! You're doing great.",
        expert: "⚡ EXPERT LEVEL! You're a distraction-elimination master!"
    };
    
    const currentLevel = difficultyState.currentDifficultyLevel;
    if (messages[currentLevel]) {
        messageQueue.add(messages[currentLevel], 'hint', 3000);
    }
}

// 7. DIFFICULTY ANALYTICS
function getDifficultyAnalytics() {
    return {
        playerSkill: difficultyState.playerSkill,
        currentLevel: difficultyState.currentDifficultyLevel,
        averageReactionTime: difficultyState.averageReactionTime,
        successRate: difficultyState.recentPerformance.length > 0 ? 
            difficultyState.recentPerformance.reduce((a, b) => a + b, 0) / difficultyState.recentPerformance.length : 0,
        spawnRateMultiplier: difficultyState.spawnRateMultiplier,
        reactionTimeMultiplier: difficultyState.reactionTimeMultiplier
    };
}


// Add CSS animations to page
if (!document.getElementById('messageAnimationCSS')) {
    const style = document.createElement('style');
    style.id = 'messageAnimationCSS';
    style.textContent = messageAnimationCSS;
    document.head.appendChild(style);
}

// Static Data Arrays (keeping existing arrays as they are good)
const loadingTips = [
    "💡 Pro tip: Lasting longer starts with the right preparation... 😉",
    "🎯 Focus is everything - in games and in life! #LongLast3X",
    "🔥 Some moments deserve to last 3X longer... just saying",
    "💪 Protect your moments. Embrace Up 3X.",
    "⚡ The best performances require the right preparation",
    "🎨 Uninterrupted intimacy is an art form... master it!",
    "🏆 Champions know: timing is everything",
    "💯 Stamina isn't just physical, it's mental too",
    "🎪 Every distraction eliminated = longer lasting pleasure",
    "🌟 Practice makes perfect... and lasts 3X longer",
    "🚀 Ready to prove your endurance? Let's go!",
    "💕 Great lovers protect their intimate moments"
];

const hinglishTemplates = [
    "Yaar, maine {score} points banaye! 💪 Tera stamina kitna hai? 😏 #LongLast3X",
    "Boss, {time} seconds tak tika raha! 🔥 Tu kitna der chalega? 😎 #EndlessEmbrace",
    "Mera score dekh: {score}! 🏆 Teri baari ab... himmat hai? 😈 #3XPower",
    "Bhai, streak toh dekh: {streak} 🔥🔥 Beat kar sake toh kar! 💯 #StaminaKing",
    "Distraction ka baap hun main! 🎯 Score: {score} - tera kya scene? 🤔",
    "3X warrior ban gaya! ⚡ {score} points! Chal competition karte hai 😏",
    "Mast game hai yaar! 🎮 {time} seconds survive kiya... tu try kar! 💪",
    "Kya focus hai mera! 🧘‍♂️ Score {score}! Tere paas hai dum? 🔥",
    "Endless embrace mein {score} banaye! 💕 Partner ke saath khelo, maza aayega 😉",
    "Stamina check kar apna! 💯 Mera score: {score} - challenge accept? 🎯",
    "Power packed performance! 💥 {time} seconds! Teri turn ab 😎 #3XLonger",
    "Distraction destroyer! 🔥 Score {score}! Aa jaa ring mein 🥊 #EndlessEmbrace"
];

const coupleSharingTemplates = [
    "We just crushed the Endless Embrace challenge together! 💪 Our combined score: {totalScore} | Think you and your partner can beat us? 😏",
    "Relationship goals unlocked! 💕 We achieved '{harmonyLevel}' in the KS Endless Embrace challenge. Can you match our connection?",
    "Date night just got interesting! 🔥 We lasted {combinedTime} seconds in perfect sync. Challenge us: {challengeCode}",
    "Just earned 'Power Couple' status! ⚡ Our endurance game is strong. Think you've got what it takes? #CoupleGoals",
    "My partner and I just proved we're unstoppable! 💯 Beat our Endless Embrace score if you can: {challengeCode}",
    "Some moments are worth protecting together 💖 We just mastered the art of focus. Join the challenge!",
    "Challenge accepted and dominated! 🏆 Our combined stamina: {totalScore} points. Who's next? #LongLast3X",
    "Uninterrupted for {combinedTime} seconds straight! ⏰ That's what we call staying power. Can you last longer?",
    "We just unlocked '{sharedAchievement}' together! 🎯 Couples who play together, stay together. Try it: {challengeCode}",
    "Plot twist: {winnerName} won by {winMargin} points! 😂 But we're both winners in the game of love. Challenge code: {challengeCode}"
];

const coupleAchievements = {
    perfectHarmony: { name: "Perfect Harmony", desc: "Both players scored within 10% of each other", icon: "❤️" },
    powerCouple: { name: "Power Couple", desc: "Combined score exceeded 300 points", icon: "⚡" },
    marathonLovers: { name: "Marathon Lovers", desc: "Combined play time exceeded 3 minutes", icon: "⏰" },
    synchronizedSouls: { name: "Synchronized Souls", desc: "Both unlocked the same 3+ achievements", icon: "🔗" },
    competitiveSpirits: { name: "Competitive Spirits", desc: "Score difference exceeded 100 points", icon: "🔥" },
    enduranceChampions: { name: "Endurance Champions", desc: "Both completed without losing all intimacy", icon: "💪" },
    twinFlames: { name: "Twin Flames", desc: "Both achieved identical scores (rare bonus)", icon: "✨" },
    coupleGoals: { name: "Couple Goals", desc: "Both achieved 'Perfect Round' achievement", icon: "💕" }
};

const achievements = {
    quickDraw: {
        id: 'quickDraw',
        name: 'Quick Draw McGraw',
        desc: 'Eliminate distractions within 0.8 seconds',
        icon: '🎯'
    },
    penetratingFocus: {
        id: 'penetratingFocus',
        name: 'Penetrating Focus',
        desc: 'Complete a round without missing any distractions',
        icon: '🔥'
    },
    multiPosition: {
        id: 'multiPosition',
        name: 'Multi-Position Master',
        desc: 'Eliminate 3 distractions within 2 seconds',
        icon: '💪'
    },
    climaxControl: {
        id: 'climaxControl',
        name: 'Climax Control Expert',
        desc: 'Complete game without losing any intimacy points',
        icon: '🧘‍♂️'
    },
    speedDemon: {
        id: 'speedDemon',
        name: 'Speed Demon',
        desc: 'Complete Round 1 in under 30 seconds',
        icon: '⚡'
    },
    heatWave: {
        id: 'heatWave',
        name: 'Heat Wave',
        desc: '7+ consecutive eliminations',
        icon: '🌡️'
    },
    staminaSupreme: {
        id: 'staminaSupreme',
        name: 'Stamina Supreme',
        desc: 'Complete 2 perfect rounds',
        icon: '💯'
    },
    warrior3x: {
        id: 'warrior3x',
        name: '3X Warrior',
        desc: 'Achieve 150+ score',
        icon: '⚡'
    }
};

// Rounds data 
const rounds = [
    {
        name: "The First Spark",
        setting: "Home: Morning Rush",
        silhouette: "https://assets.codepen.io/t-24779/hug-embrace.png",
        bgMusic: 'romantic',
        distractions: [
            { icon: '⏰', name: 'alarm', sound: 'ring' },
            { icon: '📱', name: 'notification', sound: 'ding' },
            { icon: '📝', name: 'reminder', sound: 'pop', special: 'sticky' },
            { icon: '☕', name: 'coffee', sound: 'bubble' },
            { icon: '🗞️', name: 'newspaper', sound: 'rustle', booster: true },
            { icon: '🥞', name: 'breakfast', sound: 'sizzle' },
            { icon: '🚿', name: 'shower', sound: 'water' },
            { icon: '👔', name: 'clothes', sound: 'zipper' },
            { icon: '🐕', name: 'dog', sound: 'bark' },
            { icon: '🚪', name: 'doorbell', sound: 'ring', booster: true }
        ],
        spawnRate: 1900,
        reactionTime: 1800,
        distractionsRequired: 10
    },
    {
        name: "Sneaking Moments",
        setting: "On the Way: Public Transport",
        silhouette: "https://assets.codepen.io/t-24779/romantic-embrace.png",
        bgMusic: 'upbeat',
        distractions: [
            { icon: '🚗', name: 'horn', sound: 'honk' },
            { icon: '💬', name: 'chatter', sound: 'talk' },
            { icon: '📢', name: 'announcement', sound: 'announce' },
            { icon: '🚍', name: 'bus', sound: 'brake' },
            { icon: '📻', name: 'radio', sound: 'static' },
            { icon: '🚶', name: 'passenger', sound: 'cough' },
            { icon: '🎵', name: 'music', sound: 'loud', booster: true },
            { icon: '🚊', name: 'metro', sound: 'whoosh' },
            { icon: '👮', name: 'conductor', sound: 'ticket' },
            { icon: '💨', name: 'wind', sound: 'blow' },
            { icon: '🎒', name: 'backpack', sound: 'bump' },
            { icon: '☂️', name: 'umbrella', sound: 'poke' }
        ],
        spawnRate: 1800,
        reactionTime: 1600,
        distractionsRequired: 12
    },
    {
        name: "Hidden Desires",
        setting: "At Work: Office Desk",
        silhouette: "https://assets.codepen.io/t-24779/standing-embrace.png",
        bgMusic: 'electronic',
        distractions: [
            { icon: '✉️', name: 'email', sound: 'ding' },
            { icon: '👤', name: 'boss', sound: 'footstep', booster: true },
            { icon: '☎️', name: 'phone', sound: 'ring' },
            { icon: '💻', name: 'computer', sound: 'beep' },
            { icon: '🖨️', name: 'printer', sound: 'print' },
            { icon: '📊', name: 'deadline', sound: 'alert' },
            { icon: '🗂️', name: 'files', sound: 'shuffle' },
            { icon: '☕', name: 'coffeebreak', sound: 'sip' },
            { icon: '👥', name: 'colleague', sound: 'knock' },
            { icon: '🚪', name: 'door', sound: 'open' },
            { icon: '📅', name: 'meeting', sound: 'remind' },
            { icon: '💡', name: 'idea', sound: 'ping', booster: true },
            { icon: '🎯', name: 'target', sound: 'whoosh' },
            { icon: '📈', name: 'report', sound: 'urgent' },
            { icon: '🔔', name: 'notification', sound: 'buzz' },
            { icon: '📋', name: 'clipboard', sound: 'clip', special: 'sticky' },
            { icon: '🖊️', name: 'pen', sound: 'click' },
            { icon: '📌', name: 'pin', sound: 'tack', special: 'sticky' }
        ],
        spawnRate: 1400,
        reactionTime: 1500,
        distractionsRequired: 18
    },
    {
        name: "A Quick Escape",
        setting: "Coffee Break: Cafe Nook",
        silhouette: "https://assets.codepen.io/t-24779/stand-kiss-embrace.png",
        bgMusic: 'jazz',
        distractions: [
            { icon: '☕', name: 'grinder', sound: 'whir' },
            { icon: '🗣️', name: 'calling', sound: 'call' },
            { icon: '📢', name: 'ad', sound: 'pop', swipe: true },
            { icon: '🍰', name: 'cake', sound: 'ding' },
            { icon: '🪑', name: 'chair', sound: 'scrape' },
            { icon: '🎵', name: 'jukebox', sound: 'music', booster: true },
            { icon: '👨‍🍳', name: 'barista', sound: 'steam' },
            { icon: '📰', name: 'magazine', sound: 'flip' },
            { icon: '🚬', name: 'smoke', sound: 'cough' },
            { icon: '💳', name: 'payment', sound: 'beep' },
            { icon: '🔊', name: 'speaker', sound: 'feedback' },
            { icon: '🌿', name: 'plant', sound: 'water' },
            { icon: '🖼️', name: 'art', sound: 'admire' },
            { icon: '📶', name: 'wifi', sound: 'connect' },
            { icon: '🎭', name: 'performer', sound: 'clap', booster: true },
            { icon: '📸', name: 'tourist', sound: 'click' },
            { icon: '🚶‍♀️', name: 'customer', sound: 'order' },
            { icon: '🍪', name: 'cookie', sound: 'crunch' },
            { icon: '📱', name: 'instagrammer', sound: 'selfie' },
            { icon: '☂️', name: 'umbrella', sound: 'drip' },
            { icon: '🎒', name: 'backpack', sound: 'zip' },
            { icon: '🗞️', name: 'headlines', sound: 'gasp' }
        ],
        spawnRate: 1200,
        reactionTime: 1800,
        distractionsRequired: 22
    },
    {
        name: "Lunchtime Rendezvous",
        setting: "Lunch Break: Park Bench",
        silhouette: "https://assets.codepen.io/t-24779/lap-embrace.png",
        bgMusic: 'warm',
        distractions: [
            { icon: '⚽', name: 'ball', sound: 'bounce', booster: true },
            { icon: '👁️', name: 'passerby', sound: 'look' },
            { icon: '🍦', name: 'icecream', sound: 'jingle' },
            { icon: '🐕', name: 'dog', sound: 'bark' },
            { icon: '🎵', name: 'music', sound: 'loud' },
            { icon: '🌤️', name: 'glare', sound: 'bright' },
            { icon: '🐦', name: 'birds', sound: 'chirp' },
            { icon: '🚴', name: 'cyclist', sound: 'bell' },
            { icon: '🌳', name: 'tree', sound: 'rustle' },
            { icon: '🏃', name: 'jogger', sound: 'pant' },
            { icon: '👶', name: 'baby', sound: 'giggle' },
            { icon: '🎾', name: 'tennis', sound: 'hit', booster: true },
            { icon: '📷', name: 'photographer', sound: 'shutter' },
            { icon: '🛴', name: 'scooter', sound: 'zoom' },
            { icon: '🎨', name: 'artist', sound: 'sketch' },
            { icon: '🥏', name: 'frisbee', sound: 'whizz' },
            { icon: '🎺', name: 'busker', sound: 'trumpet' },
            { icon: '🦆', name: 'duck', sound: 'quack' },
            { icon: '🌻', name: 'flowers', sound: 'sneeze' },
            { icon: '🎈', name: 'balloon', sound: 'pop', booster: true },
            { icon: '🛹', name: 'skateboard', sound: 'roll' },
            { icon: '🎯', name: 'darts', sound: 'thud' },
            { icon: '🪁', name: 'kite', sound: 'flutter' },
            { icon: '🏐', name: 'volleyball', sound: 'spike' },
            { icon: '🎪', name: 'juggler', sound: 'wow' },
            { icon: '🎸', name: 'guitar', sound: 'strum' },
            { icon: '🍕', name: 'foodtruck', sound: 'sizzle' },
            { icon: '📣', name: 'megaphone', sound: 'announce', booster: true }
        ],
        spawnRate: 1100,
        reactionTime: 1600,
        distractionsRequired: 28
    },
    {
        name: "Evening Delight",
        setting: "After Work: Restaurant Dinner",
        silhouette: "https://assets.codepen.io/t-24779/held-up-lap-embrace.png",
        bgMusic: 'sophisticated',
        distractions: [
            { icon: '🗣️', name: 'loudtable', sound: 'chatter' },
            { icon: '🤚', name: 'waiter', sound: 'excuse' },
            { icon: '📳', name: 'vibration', sound: 'buzz', booster: true },
            { icon: '🍽️', name: 'dishes', sound: 'clatter' },
            { icon: '👶', name: 'baby', sound: 'cry' },
            { icon: '📸', name: 'camera', sound: 'flash' },
            { icon: '🎂', name: 'birthday', sound: 'singing' },
            { icon: '💳', name: 'bill', sound: 'receipt' },
            { icon: '🍷', name: 'wine', sound: 'pour' },
            { icon: '🎻', name: 'violin', sound: 'melody' },
            { icon: '🕯️', name: 'candle', sound: 'flicker' },
            { icon: '👨‍🍳', name: 'chef', sound: 'flambe', booster: true },
            { icon: '🥂', name: 'toast', sound: 'clink' },
            { icon: '🎹', name: 'piano', sound: 'notes' },
            { icon: '🍴', name: 'cutlery', sound: 'drop' },
            { icon: '🔥', name: 'fire', sound: 'alarm' },
            { icon: '🎤', name: 'singer', sound: 'croon' },
            { icon: '🍾', name: 'champagne', sound: 'pop', booster: true },
            { icon: '👗', name: 'fashion', sound: 'compliment' },
            { icon: '📞', name: 'reservation', sound: 'ring' },
            { icon: '🎭', name: 'drama', sound: 'gasp' },
            { icon: '🌹', name: 'roses', sound: 'vendor' },
            { icon: '💍', name: 'proposal', sound: 'aww' },
            { icon: '🎨', name: 'painting', sound: 'discuss' },
            { icon: '🪕', name: 'banjo', sound: 'twang' },
            { icon: '🎺', name: 'brass', sound: 'fanfare' },
            { icon: '🥁', name: 'drums', sound: 'beat' },
            { icon: '🎯', name: 'review', sound: 'critic' },
            { icon: '🏆', name: 'award', sound: 'applause', booster: true },
            { icon: '🎪', name: 'magic', sound: 'poof' },
            { icon: '🎨', name: 'art', sound: 'auction' },
            { icon: '🍰', name: 'dessert', sound: 'wheel' }
        ],
        spawnRate: 1200,
        reactionTime: 1500,
        distractionsRequired: 32
    },
    {
        name: "Anticipation",
        setting: "On the Way Back Home: Night Drive",
        silhouette: "https://assets.codepen.io/t-24779/holding-embrace.png",
        bgMusic: 'driving',
        distractions: [
            { icon: '🔊', name: 'roadnoise', sound: 'vroom' },
            { icon: '🗺️', name: 'gps', sound: 'reroute' },
            { icon: '💬', name: 'texts', sound: 'multiple', booster: true },
            { icon: '🚦', name: 'traffic', sound: 'stop' },
            { icon: '🚓', name: 'police', sound: 'siren' },
            { icon: '⛽', name: 'fuel', sound: 'warning' },
            { icon: '🌧️', name: 'rain', sound: 'wiper' },
            { icon: '📻', name: 'radio', sound: 'static' },
            { icon: '🚗', name: 'honk', sound: 'beep' },
            { icon: '🌉', name: 'toll', sound: 'coins' },
            { icon: '🎵', name: 'bass', sound: 'thump', booster: true },
            { icon: '📱', name: 'call', sound: 'ringtone' },
            { icon: '🚧', name: 'construction', sound: 'drill' },
            { icon: '🚑', name: 'ambulance', sound: 'emergency' },
            { icon: '🌃', name: 'lights', sound: 'flash' },
            { icon: '🛣️', name: 'highway', sound: 'merge' },
            { icon: '🚙', name: 'truck', sound: 'horn' },
            { icon: '🎯', name: 'speed', sound: 'camera', booster: true },
            { icon: '🌙', name: 'moon', sound: 'bright' },
            { icon: '📡', name: 'signal', sound: 'lost' },
            { icon: '🚘', name: 'engine', sound: 'sputter' },
            { icon: '🎶', name: 'playlist', sound: 'skip' },
            { icon: '🌡️', name: 'temperature', sound: 'ac' },
            { icon: '🛑', name: 'stop', sound: 'brake' },
            { icon: '🚥', name: 'yellow', sound: 'caution' },
            { icon: '📍', name: 'destination', sound: 'arrive' },
            { icon: '🎭', name: 'billboard', sound: 'distract' },
            { icon: '🚁', name: 'helicopter', sound: 'chopper' },
            { icon: '🏁', name: 'race', sound: 'zoom', booster: true },
            { icon: '💨', name: 'wind', sound: 'howl' },
            { icon: '🌌', name: 'stars', sound: 'gaze' },
            { icon: '🎪', name: 'circus', sound: 'parade' },
            { icon: '🎨', name: 'graffiti', sound: 'spray' },
            { icon: '🚧', name: 'detour', sound: 'redirect' },
            { icon: '📢', name: 'announcement', sound: 'traffic' },
            { icon: '🎯', name: 'exit', sound: 'miss' },
            { icon: '🌆', name: 'skyline', sound: 'view' },
            { icon: '🚤', name: 'boat', sound: 'horn' },
            { icon: '🛤️', name: 'train', sound: 'crossing' },
            { icon: '🎢', name: 'rollercoaster', sound: 'scream' },
            { icon: '🎡', name: 'ferriswheel', sound: 'music' },
            { icon: '🎪', name: 'carnival', sound: 'games' },
            { icon: '🌠', name: 'shooting star', sound: 'wish' },
            { icon: '🚀', name: 'rocket', sound: 'launch', booster: true },
            { icon: '🛸', name: 'ufo', sound: 'alien' }
        ],
        spawnRate: 1200,
        reactionTime: 1500,
        distractionsRequired: 45
    },
    {
        name: "Ultimate Intimacy",
        setting: "Back at Home: Bedroom Night",
        silhouette: "https://assets.codepen.io/t-24779/holding-behind-pose.png",
        bgMusic: 'intimate',
        distractions: [
            { icon: '📧', name: 'latework', sound: 'urgent' },
            { icon: '🐱', name: 'pet', sound: 'meow' },
            { icon: '🏠', name: 'creak', sound: 'creak' },
            { icon: '💭', name: 'thoughts', sound: 'whisper', booster: true },
            { icon: '🚪', name: 'door', sound: 'knock' },
            { icon: '🌡️', name: 'temperature', sound: 'ac' },
            { icon: '💡', name: 'lights', sound: 'switch' },
            { icon: '⏰', name: 'tomorrow', sound: 'worry' },
            { icon: '🪟', name: 'window', sound: 'tap' },
            { icon: '🌙', name: 'moonlight', sound: 'glow' },
            { icon: '📺', name: 'tv', sound: 'remote' },
            { icon: '🔇', name: 'neighbor', sound: 'thump' },
            { icon: '🚿', name: 'shower', sound: 'drip' },
            { icon: '🔑', name: 'keys', sound: 'jingle' },
            { icon: '📚', name: 'book', sound: 'fall' },
            { icon: '🕰️', name: 'clock', sound: 'tick' },
            { icon: '🛏️', name: 'bed', sound: 'squeak', booster: true },
            { icon: '🪞', name: 'mirror', sound: 'reflection' },
            { icon: '🕯️', name: 'candle', sound: 'flicker' },
            { icon: '🎵', name: 'music', sound: 'neighbor' },
            { icon: '🚗', name: 'car', sound: 'outside' },
            { icon: '🦗', name: 'cricket', sound: 'chirp' },
            { icon: '🌬️', name: 'wind', sound: 'whistle' },
            { icon: '📱', name: 'phone', sound: 'vibrate' },
            { icon: '💤', name: 'sleep', sound: 'yawn' },
            { icon: '🎯', name: 'focus', sound: 'break', booster: true },
            { icon: '🔥', name: 'heat', sound: 'intense' },
            { icon: '💕', name: 'heartbeat', sound: 'pulse' },
            { icon: '🌹', name: 'romance', sound: 'petal' },
            { icon: '🍾', name: 'celebration', sound: 'cork' },
            { icon: '🎆', name: 'fireworks', sound: 'boom' },
            { icon: '🌟', name: 'stars', sound: 'twinkle' },
            { icon: '💝', name: 'gift', sound: 'unwrap' },
            { icon: '🎪', name: 'dream', sound: 'surreal' },
            { icon: '🎭', name: 'fantasy', sound: 'imagine' },
            { icon: '🎨', name: 'paint', sound: 'brush' },
            { icon: '🌈', name: 'rainbow', sound: 'colors' },
            { icon: '✨', name: 'magic', sound: 'sparkle', booster: true },
            { icon: '🦋', name: 'butterfly', sound: 'flutter' },
            { icon: '🌺', name: 'flower', sound: 'bloom' },
            { icon: '🍃', name: 'breeze', sound: 'gentle' },
            { icon: '💫', name: 'cosmic', sound: 'universe' },
            { icon: '🌌', name: 'galaxy', sound: 'infinite' },
            { icon: '🔮', name: 'crystal', sound: 'energy' },
            { icon: '🎪', name: 'circus', sound: 'wonder' },
            { icon: '🎯', name: 'target', sound: 'hit' },
            { icon: '🏆', name: 'victory', sound: 'triumph', booster: true },
            { icon: '👑', name: 'crown', sound: 'royal' },
            { icon: '💎', name: 'diamond', sound: 'shine' },
            { icon: '🌸', name: 'cherry', sound: 'blossom' },
            { icon: '🎊', name: 'confetti', sound: 'celebrate' },
            { icon: '🎈', name: 'balloon', sound: 'float' },
            { icon: '🎁', name: 'surprise', sound: 'reveal' },
            { icon: '🌷', name: 'tulip', sound: 'spring' },
            { icon: '🦄', name: 'unicorn', sound: 'magical', booster: true }
        ],
        spawnRate: 1200,
        reactionTime: 1400,
        distractionsRequired: 55
    }
];

// ============================================================================
// GLOBAL VARIABLES - Three.js and Audio
// ============================================================================
let scene, camera, renderer;
let particleSystem;
let audioContext, audioBuffers = {};
let backgroundMusic = null;
let currentBgMusic = null;

// Memory cleanup tracker
const cleanupTracker = {
    timeouts: new Set(),
    intervals: new Set(),
    audioSources: new Set(),
    
    addTimeout(id) { this.timeouts.add(id); },
    addInterval(id) { this.intervals.add(id); },
    addAudioSource(source) { this.audioSources.add(source); },
    
    cleanup() {
        this.timeouts.forEach(id => clearTimeout(id));
        this.intervals.forEach(id => clearInterval(id));
        this.audioSources.forEach(source => {
            try { source.stop(); } catch (e) {}
        });
        this.timeouts.clear();
        this.intervals.clear();
        this.audioSources.clear();
    }
};


// ============================================================================
// ENHANCED EVENT HANDLERS AND STORAGE
// ============================================================================

window.addEventListener('beforeunload', () => {
    try {
        const currentBest = localStorage.getItem('bestScore') || 0;
        if (gameState.score > currentBest) {
            localStorage.setItem('bestScore', gameState.score);
        }
        
        const currentBestStreak = localStorage.getItem('bestStreak') || 0;
        if (gameState.bestStreak > currentBestStreak) {
            localStorage.setItem('bestStreak', gameState.bestStreak);
        }
        
    } catch (error) {
        console.error('Storage save failed:', error);
    }
});


function checkEmergencySave() {
    try {
        const emergencyData = localStorage.getItem('emergency_save');
        if (emergencyData) {
            const data = JSON.parse(emergencyData);
            const timeSince = Date.now() - data.timestamp;
            
            if (timeSince < 3600000) {
                const restore = confirm(`Found a recent game session (Score: ${data.score}, Round: ${data.round}). Would you like to continue?`);
                if (restore) {
                    restoreFromEmergencySave(data);
                }
            }
            
            localStorage.removeItem('emergency_save');
        }
    } catch (error) {
        console.error('Emergency save check failed:', error);
    }
}

function restoreFromEmergencySave(data) {
    try {
        gameState.score = data.score;
        gameState.currentRound = data.round;
        gameState.intimacyHearts = data.hearts;
        gameState.achievements = new Set(data.achievements);
        
        showHint("Game restored from emergency save! 🛡️");
        console.log('🔄 Game restored from emergency save');
    } catch (error) {
        console.error('Emergency restore failed:', error);
    }
}

function gracefulRecover() {
    try {
        if (gameState.spawnTimeout) clearTimeout(gameState.spawnTimeout);
        if (gameState.multiKillTimer) clearTimeout(gameState.multiKillTimer);
        
        gameState.distractions.forEach(d => {
            if (d.timerInterval) clearInterval(d.timerInterval);
            if (d.parentNode) d.remove();
        });
        
        gameState.gameRunning = false;
        gameState.roundInProgress = false;
        
        showHint("Game recovered from error. Continue playing! 🛡️");
        console.log('🔧 Graceful recovery completed');
    } catch (error) {
        console.error('Recovery failed:', error);
        setTimeout(() => location.reload(), 2000);
    }
}

window.addEventListener('load', init);

async function init() {
    try {
        gameState.lastScore = parseInt(localStorage.getItem('lastScore') || '0');
        gameState.isMobile = window.innerWidth <= 768;
        
        updateLoadingProgress(10);
        updateLoadingTip();
        
        setupThreeJS();
        updateLoadingProgress(30);
        
        await preloadAssets();
        updateLoadingProgress(70);
        
        await initAudio();
        updateLoadingProgress(90);
        
        // Check for emergency save
        checkEmergencySave();
        
        setTimeout(() => {
            updateLoadingProgress(100);
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
                showScreen('startScreen');
            }, 500);
        }, 1000);

        setInterval(updateLoadingTip, 4000);
        setupEventListeners();
        
        console.log('🎮 Game initialized successfully');
    } catch (error) {
        console.error('Initialization failed:', error);
        gracefulRecover();
    }
}

function checkEmergencySave() {
    try {
        const emergencyData = localStorage.getItem('emergency_save');
        if (emergencyData) {
            const data = JSON.parse(emergencyData);
            const timeSince = Date.now() - data.timestamp;
            
            // If save is less than 1 hour old, offer to restore
            if (timeSince < 3600000) {
                const restore = confirm(`Found a recent game session (Score: ${data.score}, Round: ${data.round}). Would you like to continue?`);
                if (restore) {
                    restoreFromEmergencySave(data);
                }
            }
            
            // Clean up old emergency save
            localStorage.removeItem('emergency_save');
        }
    } catch (error) {
        console.error('Emergency save check failed:', error);
    }
}

function restoreFromEmergencySave(data) {
    try {
        gameState.score = data.score;
        gameState.currentRound = data.round;
        gameState.intimacyHearts = data.hearts;
        gameState.achievements = new Set(data.achievements);
        
        showHint("Game restored from emergency save! 🛡️");
        console.log('🔄 Game restored from emergency save');
    } catch (error) {
        console.error('Emergency restore failed:', error);
    }
}

function updateLoadingProgress(percent) {
    const progressEl = document.getElementById('loadingProgress');
    if (progressEl) {
        progressEl.style.width = percent + '%';
    }
}

function updateLoadingTip() {
    gameState.tipIndex = Math.floor(Math.random() * loadingTips.length);
    const tipElement = document.getElementById('loadingTip');
    if (tipElement) {
        tipElement.innerHTML = `<p>${loadingTips[gameState.tipIndex]}</p>`;
    }
}

// ============================================================================
// ENHANCED THREE.JS SETUP
// ============================================================================

function setupThreeJS() {
    try {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            console.warn('Game canvas not found, creating fallback');
            return;
        }
        
        renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            alpha: true,
            antialias: !gameState.isMobile, // Disable antialiasing on mobile for performance
            powerPreference: gameState.isMobile ? 'low-power' : 'high-performance'
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, gameState.isMobile ? 1.5 : 2));
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        camera.position.z = 5;
        createParticleSystem();
        
        console.log('🎨 Three.js setup completed');
    } catch (error) {
        console.error('Three.js setup failed:', error);
    }
}

function createParticleSystem() {
    try {
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = gameState.isMobile ? 100 : 150; // Reduce particles on mobile
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            
            if (Math.random() > 0.5) {
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.84;
                colors[i * 3 + 2] = 0.0;
            } else {
                colors[i * 3] = 0.83;
                colors[i * 3 + 1] = 0.21;
                colors[i * 3 + 2] = 0.35;
            }
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: gameState.isMobile ? 0.08 : 0.1,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        
        particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);
    } catch (error) {
        console.error('Particle system creation failed:', error);
    }
}

// ============================================================================
// ASSET PRELOADING
// ============================================================================

async function preloadAssets() {
    try {
        const imagePromises = rounds.map(round => {
            return new Promise((resolve) => {
                const img = new Image();
                const timeoutId = setTimeout(() => resolve(), 5000); // 5s timeout
                img.onload = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    console.warn('Failed to load image:', round.silhouette);
                    resolve();
                };
                img.src = round.silhouette;
            });
        });
        
        const otherImages = [
            'https://assets.codepen.io/t-24779/KS_logo_two.png',
            'https://assets.codepen.io/t-24779/embrace-emoji.png',
            'https://assets.codepen.io/t-24779/KamaSutra-longlast-product.png'
        ];
        
        otherImages.forEach(src => {
            imagePromises.push(new Promise((resolve) => {
                const img = new Image();
                const timeoutId = setTimeout(() => resolve(), 3000);
                img.onload = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                img.src = src;
            }));
        });
        
        await Promise.allSettled(imagePromises); // Use allSettled to continue even if some fail
        console.log('📸 Assets preloaded successfully');
    } catch (error) {
        console.error('Asset preloading failed:', error);
    }
}

// ============================================================================
// ENHANCED AUDIO SYSTEM WITH FALLBACKS
// ============================================================================

// AUDIO INITIALIZATION WITH SOUND TYPES 
async function initAudio() {
    try {
        const savedAudioState = localStorage.getItem('audioEnabled');
        if (savedAudioState !== null) {
            gameState.audioEnabled = savedAudioState === 'true';
        }
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        try {
            // Basic sounds (keep existing ones)
            audioBuffers.success = createTone(880, 0.1);
            audioBuffers.fail = createTone(220, 0.2);
            audioBuffers.achievement = createTone(1320, 0.3);
            audioBuffers.ring = createTone(440, 0.3);
            audioBuffers.ding = createTone(660, 0.1);
            audioBuffers.pop = createTone(550, 0.05);
            audioBuffers.buzz = createNoise(0.1);
            
            // NEW Enhanced sounds
            audioBuffers.eliminateCritical = createUrgencyTone(1100, 0.15, 'critical');
            audioBuffers.eliminateWarning = createUrgencyTone(880, 0.12, 'warning');
            audioBuffers.eliminateSafe = createUrgencyTone(660, 0.1, 'safe');
            
            audioBuffers.missCritical = createUrgencyTone(150, 0.4, 'critical-miss');
            audioBuffers.missWarning = createUrgencyTone(200, 0.3, 'warning-miss');
            audioBuffers.missSafe = createUrgencyTone(250, 0.2, 'safe-miss');
            
            audioBuffers.combo1_5x = createComboTone(1200, 0.2, 1.5);
            audioBuffers.combo2x = createComboTone(1400, 0.25, 2);
            audioBuffers.combo3x = createComboTone(1600, 0.3, 3);
            
            audioBuffers.trophyCollect = createTrophySound();
            audioBuffers.boosterCollect = createBoosterSound();
            audioBuffers.heartLoss = createHeartLossSound();
            audioBuffers.heartGain = createHeartGainSound();
            
            audioBuffers.priorityCritical = createPriorityRingTone('critical');
            audioBuffers.priorityWarning = createPriorityRingTone('warning');
            audioBuffers.prioritySafe = createPriorityRingTone('safe');
        } catch (error) {
            console.warn('Enhanced audio creation failed:', error);
        }
        
        try {
            // FIXED: Use your existing background music creation instead of external function
            createBackgroundMusic();
        } catch (error) {
            console.warn('Background music creation failed:', error);
        }
        
        console.log('🔊 Enhanced audio system initialized');
    } catch (error) {
        console.warn('Audio initialization failed, continuing without audio:', error);
        gameState.audioEnabled = false;
    }
}

function createBackgroundMusic() {
    const musicTracks = {
        romantic: { freq: [440, 550, 660], vol: 0.3, style: 'soft' },
        upbeat: { freq: [523, 659, 784], vol: 0.4, style: 'rhythmic' },
        electronic: { freq: [494, 587, 740], vol: 0.35, style: 'pulsing' },
        jazz: { freq: [466, 554, 698], vol: 0.3, style: 'smooth' },
        warm: { freq: [440, 554, 659], vol: 0.35, style: 'gentle' },
        sophisticated: { freq: [415, 523, 622], vol: 0.3, style: 'elegant' },
        driving: { freq: [494, 622, 740], vol: 0.4, style: 'intense' },
        intimate: { freq: [440, 523, 659], vol: 0.25, style: 'soft' }
    };

    Object.entries(musicTracks).forEach(([name, config]) => {
        try {
            audioBuffers[name] = createMusicTrack(config.freq, config.vol, config.style);
        } catch (error) {
            console.warn(`Failed to create ${name} track:`, error);
        }
    });
}


function playSpatialSound(soundName, x, y, volume = 0.5) {
    if (!gameState.audioEnabled || !audioContext || !audioBuffers[soundName]) return;
    
    try {
        const source = audioContext.createBufferSource();
        const panner = audioContext.createStereoPanner();
        const gainNode = audioContext.createGain();
        
        source.buffer = audioBuffers[soundName];
        
        const screenWidth = window.innerWidth;
        const panPosition = (x / screenWidth) * 2 - 1;
        
        panner.pan.setValueAtTime(Math.max(-1, Math.min(1, panPosition)), audioContext.currentTime);
        gainNode.gain.value = volume;
        
        source.connect(panner);
        panner.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        cleanupTracker.addAudioSource(source);
        source.start();
        
        const timeoutId = setTimeout(() => {
            cleanupTracker.audioSources.delete(source);
        }, (audioBuffers[soundName].duration * 1000) + 100);
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.warn('Spatial sound playback failed:', error);
    }
}

function playComboSound(multiplier, volume = 0.6) {
    if (!gameState.audioEnabled || !audioContext) return;
    
    let soundName;
    if (multiplier >= 3) {
        soundName = 'combo3x';
    } else if (multiplier >= 2) {
        soundName = 'combo2x';
    } else if (multiplier >= 1.5) {
        soundName = 'combo1_5x';
    }
    
    if (soundName) {
        playSound(soundName, volume);
    }
}

function playTrophySound() {
    playSound('trophyCollect', 0.7);
}

function playBoosterSound() {
    playSound('boosterCollect', 0.5);
}

function playHeartLossSound() {
    playSound('heartLoss', 0.6);
}

function playHeartGainSound() {
    playSound('heartGain', 0.6);
}

function playPriorityRingCue(urgency) {
    if (!gameState.audioEnabled || !audioContext) return;
    
    let soundName;
    switch (urgency) {
        case 'critical': soundName = 'priorityCritical'; break;
        case 'warning': soundName = 'priorityWarning'; break;
        case 'safe': soundName = 'prioritySafe'; break;
    }
    
    if (soundName) {
        playSound(soundName, 0.3);
    }
}

// 4. ADD SIMPLE DYNAMIC MUSIC AND AMBIENT FUNCTIONS
let currentMusicState = 'normal';

function updateDynamicMusic() {
    // Simple version - just update music state based on hearts
    try {
        let newState = 'normal';
        if (gameState.intimacyHearts <= 1) {
            newState = 'lowHearts';
        } else if (gameState.comboCount >= 5) {
            newState = 'highCombo';
        }
        
        if (newState !== currentMusicState) {
            currentMusicState = newState;
            // Could add music transitions here later
        }
    } catch (error) {
        console.error('Dynamic music update failed:', error);
    }
}

let ambientAudioTimeout = null;

function startAmbientAudio() {
    // Simple ambient audio - just subtle background sounds occasionally
    const playAmbient = () => {
        if (!gameState.gameRunning || !gameState.audioEnabled) return;
        
        if (Math.random() < 0.2) { // 20% chance
            playSound('pop', 0.05);
        }
        
        ambientAudioTimeout = setTimeout(playAmbient, 8000 + Math.random() * 5000);
        cleanupTracker.addTimeout(ambientAudioTimeout);
    };
    
    playAmbient();
}

function stopAmbientAudio() {
    if (ambientAudioTimeout) {
        clearTimeout(ambientAudioTimeout);
        ambientAudioTimeout = null;
    }
}

function createUrgencyTone(frequency, duration, urgencyType) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            let sample = 0;
            
            switch (urgencyType) {
                case 'critical':
                    sample = Math.sin(2 * Math.PI * frequency * t) * 0.8 +
                            Math.sin(2 * Math.PI * frequency * 2 * t) * 0.3;
                    break;
                case 'warning':
                    const vibrato = 1 + 0.1 * Math.sin(2 * Math.PI * 5 * t);
                    sample = Math.sin(2 * Math.PI * frequency * vibrato * t) * 0.7;
                    break;
                case 'safe':
                    sample = Math.sin(2 * Math.PI * frequency * t) * 0.6;
                    break;
                case 'critical-miss':
                    sample = Math.sin(2 * Math.PI * frequency * t) * 0.9 +
                            (Math.random() - 0.5) * 0.3;
                    break;
                case 'warning-miss':
                    sample = Math.sin(2 * Math.PI * frequency * t) * 0.7;
                    break;
                case 'safe-miss':
                    sample = Math.sin(2 * Math.PI * frequency * t) * 0.5;
                    break;
                default:
                    sample = Math.sin(2 * Math.PI * frequency * t);
            }
            
            const envelope = Math.exp(-i / (length * 0.3));
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createComboTone(frequency, duration, multiplier) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            let sample = 0;
            
            for (let harm = 1; harm <= multiplier; harm++) {
                const harmFreq = frequency * harm * 0.8;
                const harmAmp = 0.8 / harm;
                sample += Math.sin(2 * Math.PI * harmFreq * t) * harmAmp;
            }
            
            if (multiplier >= 2) {
                sample += Math.sin(2 * Math.PI * frequency * 4 * t) * 0.2 * Math.sin(10 * Math.PI * t);
            }
            
            const envelope = Math.exp(-i / (length * 0.4));
            data[i] = sample * envelope * 0.6;
        }
    }
    
    return buffer;
}

function createTrophySound() {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 0.6;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            
            const freq1 = 880 * (1 + t * 0.5);
            const freq2 = 1100 * (1 + t * 0.3);
            const freq3 = 1320 * (1 + t * 0.2);
            
            let sample = Math.sin(2 * Math.PI * freq1 * t) * 0.4 +
                        Math.sin(2 * Math.PI * freq2 * t) * 0.3 +
                        Math.sin(2 * Math.PI * freq3 * t) * 0.2;
            
            sample += Math.sin(2 * Math.PI * 2640 * t) * 0.2 * Math.sin(20 * Math.PI * t);
            
            const envelope = Math.sin(Math.PI * t / duration) * Math.exp(-t / (duration * 0.4));
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createBoosterSound() {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 0.4;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            
            const freq = 660 + 440 * t;
            let sample = Math.sin(2 * Math.PI * freq * t) * 0.7;
            sample += Math.sin(2 * Math.PI * freq * 1.5 * t) * 0.3;
            
            const envelope = Math.exp(-t / (duration * 0.6));
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createHeartLossSound() {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 0.5;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            
            const freq = 440 * (1 - t * 0.7);
            let sample = Math.sin(2 * Math.PI * freq * t) * 0.8;
            sample += Math.sin(2 * Math.PI * freq * 0.75 * t) * 0.4;
            
            const envelope = Math.exp(-t / (duration * 0.4));
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createHeartGainSound() {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 0.4;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            
            const freq = 660 * (1 + t * 0.5);
            let sample = Math.sin(2 * Math.PI * freq * t) * 0.7;
            sample += Math.sin(2 * Math.PI * freq * 1.25 * t) * 0.4;
            
            const envelope = Math.sin(Math.PI * t / duration);
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createPriorityRingTone(urgencyType) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 0.3;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    let frequency, intensity;
    switch (urgencyType) {
        case 'critical':
            frequency = 800; intensity = 0.4; break;
        case 'warning':
            frequency = 600; intensity = 0.3; break;
        case 'safe':
            frequency = 400; intensity = 0.2; break;
        default:
            frequency = 500; intensity = 0.2;
    }
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            
            const pulse = (Math.sin(2 * Math.PI * 4 * t) + 1) / 2;
            let sample = Math.sin(2 * Math.PI * frequency * t) * pulse * intensity;
            
            const envelope = Math.exp(-t / (duration * 0.5));
            data[i] = sample * envelope;
        }
    }
    
    return buffer;
}

function createMusicTrack(frequencies, volume, style) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const duration = 4;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = buffer.getChannelData(channel);
        
        for (let i = 0; i < length; i++) {
            let sample = 0;
            const t = i / sampleRate;
            
            frequencies.forEach((freq) => {
                let envelope = 1;
                
                switch(style) {
                    case 'soft':
                        envelope = Math.sin(Math.PI * t / duration);
                        break;
                    case 'rhythmic':
                        envelope = (Math.sin(8 * Math.PI * t) + 1) / 2;
                        break;
                    case 'pulsing':
                        envelope = Math.abs(Math.sin(4 * Math.PI * t));
                        break;
                    case 'smooth':
                        envelope = 0.8 + 0.2 * Math.sin(2 * Math.PI * t);
                        break;
                    case 'gentle':
                        envelope = Math.pow(Math.sin(Math.PI * t / duration), 2);
                        break;
                    case 'elegant':
                        envelope = 0.7 + 0.3 * Math.cos(3 * Math.PI * t);
                        break;
                    case 'intense':
                        envelope = Math.pow(Math.abs(Math.sin(6 * Math.PI * t)), 0.5);
                        break;
                }
                
                sample += Math.sin(2 * Math.PI * freq * t) * envelope / frequencies.length;
            });
            
            data[i] = sample * volume * (1 - i / length);
        }
    }
    
    return buffer;
}

function createTone(frequency, duration) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        data[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 
                 Math.exp(-i / (length * 0.3));
    }
    
    return buffer;
}

function createNoise(duration) {
    if (!audioContext) return null;
    
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        data[i] = (Math.random() - 0.5) * 0.5 * Math.exp(-i / (length * 0.3));
    }
    
    return buffer;
}

// Enhanced audio playback with error handling
function playSound(soundName, volume = 0.5) {
    if (!gameState.audioEnabled || !audioContext || !audioBuffers[soundName]) return;
    
    try {
        const source = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        
        source.buffer = audioBuffers[soundName];
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = volume;
        
        cleanupTracker.addAudioSource(source);
        source.start();
        
        // Auto-cleanup after sound ends
        const timeoutId = setTimeout(() => {
            cleanupTracker.audioSources.delete(source);
        }, (audioBuffers[soundName].duration * 1000) + 100);
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.warn('Sound playback failed:', error);
    }
}

function playBackgroundMusic(trackName) {
    if (!gameState.audioEnabled || !audioContext || !audioBuffers[trackName]) return;
    
    stopBackgroundMusic();
    
    try {
        backgroundMusic = audioContext.createBufferSource();
        const gainNode = audioContext.createGain();
        
        backgroundMusic.buffer = audioBuffers[trackName];
        backgroundMusic.loop = true;
        backgroundMusic.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.value = 0.2;
        
        backgroundMusic.start();
        currentBgMusic = backgroundMusic;
        cleanupTracker.addAudioSource(backgroundMusic);
    } catch (error) {
        console.warn('Background music playback failed:', error);
    }
}

function stopBackgroundMusic() {
    if (currentBgMusic) {
        try {
            currentBgMusic.stop();
            cleanupTracker.audioSources.delete(currentBgMusic);
        } catch (error) {
            // Already stopped
        }
        currentBgMusic = null;
    }
}

function getEliminationSoundName(urgency) {
    switch (urgency) {
        case 'critical': return 'eliminateCritical';
        case 'warning': return 'eliminateWarning';
        case 'safe': return 'eliminateSafe';
        default: return 'success';
    }
}

function getMissSoundName(urgency) {
    switch (urgency) {
        case 'critical': return 'missCritical';
        case 'warning': return 'missWarning'; 
        case 'safe': return 'missSafe';
        default: return 'fail';
    }
}

// ============================================================================
// ENHANCED HEART METER SYSTEM WITH SAFETY GUARDS
// ============================================================================

function updateHeartMeter() {
    if (gameState.heartUpdateInProgress) return;
    gameState.heartUpdateInProgress = true;
    
    try {
        const hearts = document.querySelectorAll('.game-hud .intimacy-meter .heart');
        console.log('🔍 DEBUG - Updating hearts:', hearts.length, 'Current hearts:', gameState.intimacyHearts);
        
        hearts.forEach((heart, index) => {
            heart.classList.remove('breaking', 'gaining');
            
            if (index < gameState.intimacyHearts) {
                heart.classList.add('active');
                heart.classList.remove('inactive');
                console.log(`❤️ Heart ${index}: ACTIVE - Classes:`, heart.className);
            } else {
                heart.classList.remove('active');
                heart.classList.add('inactive');
                console.log(`🖤 Heart ${index}: INACTIVE - Classes:`, heart.className);
            }
        });
        
        console.log('🎯 Game state:', {
            currentRound: gameState.currentRound,
            intimacyHearts: gameState.intimacyHearts,
            gameRunning: gameState.gameRunning
        });
    } catch (error) {
        console.error('Heart meter update failed:', error);
    } finally {
        const timeoutId = setTimeout(() => {
            gameState.heartUpdateInProgress = false;
        }, 100);
        cleanupTracker.addTimeout(timeoutId);
    }
}

function loseHeart(reason = 'missed') {
    if (gameState.intimacyHearts <= 0 || gameState.heartUpdateInProgress) return;
    
    let heartsToLose = 1;
    
    if (reason === 'consecutive' && gameState.consecutiveMisses >= 2) {
        heartsToLose = 2;
    }
    
    if (reason === 'critical' && gameState.currentRound >= 7) {
        heartsToLose = 2;
    }
    
    const previousHearts = gameState.intimacyHearts;
    gameState.intimacyHearts = Math.max(0, gameState.intimacyHearts - heartsToLose);
    playHeartLossSound();
    playHeartLossEffect(previousHearts, heartsToLose);
    updateHeartMeter();
    
    // Enhanced vibration feedback
    if (mobileState.isMobile) {
    touchFeedback.haptic('error');
    } else {
    vibrate([100, 50, 100]);
    }
    
    if (gameState.intimacyHearts <= 0) {
        const timeoutId = setTimeout(() => {
            endGame();
        }, 1000);
        cleanupTracker.addTimeout(timeoutId);
    }
}

function gainHeart(reason = 'bonus') {
    if (gameState.intimacyHearts >= gameState.maxHearts || gameState.heartUpdateInProgress) return;
    
    const previousHearts = gameState.intimacyHearts;
    gameState.intimacyHearts = Math.min(gameState.maxHearts, gameState.intimacyHearts + 1);
    playHeartGainSound();
    playHeartGainEffect(previousHearts);
    updateHeartMeter();
    
    // Enhanced vibration feedback
    if (mobileState.isMobile) {
    touchFeedback.haptic('success');
    } else {
    vibrate([50, 30, 50]);
    }
    
    if (reason === 'perfectCombo') {
        showHint("Perfect combo! Heart restored! 💕");
    } else if (reason === 'roundCompletion') {
        showHint("Perfect round! Bonus heart! ❤️");
    }
}

function playHeartLossEffect(previousHearts, heartsLost) {
    playSound('fail', 0.3);
    enhancedShakeScreen();
    
    const hearts = document.querySelectorAll('.heart');
    
    for (let i = 0; i < heartsLost; i++) {
        const heartIndex = previousHearts - 1 - i;
        if (hearts[heartIndex] && heartIndex >= 0) {
            const timeoutId = setTimeout(() => {
                hearts[heartIndex].classList.add('breaking');
                hearts[heartIndex].style.animation = 'heartBreak 0.8s ease-out';
                const innerTimeoutId = setTimeout(() => {
                    hearts[heartIndex].style.animation = '';
                    hearts[heartIndex].classList.remove('breaking');
                    updateHeartMeter();
                }, 800);
                cleanupTracker.addTimeout(innerTimeoutId);
            }, i * 200);
            cleanupTracker.addTimeout(timeoutId);
        }
    }
    
    if (heartsLost > 1) {
        const timeoutId = setTimeout(() => {
            showHint("Multiple hearts lost! 💔");
        }, 500);
        cleanupTracker.addTimeout(timeoutId);
    }
}

function playHeartGainEffect(previousHearts) {
    playSound('success', 0.5);
    
    const hearts = document.querySelectorAll('.heart');
    const newHeartIndex = previousHearts;
    
    if (hearts[newHeartIndex]) {
        hearts[newHeartIndex].classList.add('gaining');
        hearts[newHeartIndex].style.animation = 'pulse 0.6s ease-out';
        hearts[newHeartIndex].style.filter = 'drop-shadow(0 0 10px #d5365a)';
        
        const timeoutId = setTimeout(() => {
            hearts[newHeartIndex].style.animation = '';
            hearts[newHeartIndex].style.filter = '';
            hearts[newHeartIndex].classList.remove('gaining');
            updateHeartMeter();
        }, 1000);
        cleanupTracker.addTimeout(timeoutId);
    }
}

// ============================================================================
// ENHANCED EVENT LISTENERS
// ============================================================================

function setupEventListeners() {
    window.addEventListener('resize', handleResize);
    document.addEventListener('click', handleInteraction);
    document.addEventListener('touchstart', handleInteraction);
    
    // Enhanced mobile handling
    // document.addEventListener('touchend', handleTouchEnd, false);
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    // Orientation change with delay
    window.addEventListener('orientationchange', handleOrientationChange);
    
    // Page visibility API for better resource management
    document.addEventListener('visibilitychange', handleVisibilityChange);
}

function handleResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Update mobile detection on resize
    const wasMobile = gameState.isMobile;
    gameState.isMobile = window.innerWidth <= 768;
    
    // Update achievement board visibility if mobile state changed
    if (wasMobile !== gameState.isMobile && gameState.gameRunning) {
        updateAchievementBoardVisibility();
    }
}

function handleInteraction(event) {
    // Skip if mobile event handler is managing touches
    if (mobileState.isMobile && event.type.startsWith('touch')) {
        return; // Let mobile event handler manage this
    }
    
    if (!gameState.gameRunning) return;
    
    // Prevent event bubbling
    event.preventDefault();
    event.stopPropagation();
    
    const x = event.clientX || (event.touches && event.touches[0].clientX);
    const y = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (!x || !y) return; // Safety check
    
    const distractions = document.querySelectorAll('.distraction');
    let hitDetected = false;
    
    distractions.forEach(distraction => {
        if (!distraction.parentNode) return; // Skip removed distractions
        
        const rect = distraction.getBoundingClientRect();
        
        // Enhanced hit detection for desktop
        const padding = mobileState.isMobile ? 15 : 5; // Larger touch targets on mobile
        
        if (x >= (rect.left - padding) && x <= (rect.right + padding) && 
            y >= (rect.top - padding) && y <= (rect.bottom + padding)) {
            hitDetected = true;
            
            // Enhanced feedback for desktop
            if (!mobileState.isMobile) {
                const urgency = distraction.dataset.urgency || 'safe';
                touchFeedback.showTouchRipple(x, y, urgency === 'critical' ? '#FF4444' : 
                                              urgency === 'warning' ? '#FFA500' : '#32CD32');
            }
            
            eliminateDistraction(distraction);
        }
    });
    
    // Add debug logging for desktop misses
    if (!hitDetected && distractions.length > 0 && !mobileState.isMobile) {
        console.log('🖱️ Desktop click missed all distractions:', {x, y, distractionsCount: distractions.length});
        touchFeedback.showTouchRipple(x, y, '#FF6666');
    }
}

function handleTouchMove(e) {
    // Prevent iOS Safari bouncing, but allow scrolling in modals
    if (e.target.closest('.modal-content, .results-panel')) return;
    e.preventDefault();
}

function handleOrientationChange() {
    const timeoutId = setTimeout(() => {
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Update mobile detection
        gameState.isMobile = window.innerWidth <= 768;
        updateAchievementBoardVisibility();
    }, 100);
    cleanupTracker.addTimeout(timeoutId);
}

function handleVisibilityChange() {
    if (document.hidden) {
        // Pause game when tab is hidden
        if (gameState.gameRunning) {
            emergencySave();
        }
        // Pause background music
        if (currentBgMusic) {
            try {
                currentBgMusic.suspend?.();
            } catch (e) {}
        }
    } else {
        // Resume when tab is visible
        if (currentBgMusic && gameState.audioEnabled) {
            try {
                currentBgMusic.resume?.();
            } catch (e) {}
        }
    }
}

// ============================================================================
// SCREEN MANAGEMENT
// ============================================================================

function showScreen(screenId) {
    try {
        // Force hide all screens first
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
            screen.style.display = 'none'; // Force hide
            screen.style.visibility = 'hidden';
            screen.style.opacity = '0';
        });
        
        // Small delay to ensure hiding is complete
        setTimeout(() => {
            const screen = document.getElementById(screenId);
            if (screen) {
                screen.style.display = 'flex';
                screen.style.visibility = 'visible';
                screen.style.opacity = '1';
                screen.classList.add('active');
                gameState.currentScreen = screenId;
                
                console.log('📺 Screen changed to:', screenId);
            }
        }, 50);
        
        if (screenId === 'gameScreen') {
            // Additional delay for game screen
            setTimeout(() => {
                startGame();
            }, 100);
        } else {
            gameState.cleanup();
        }
        
    } catch (error) {
        console.error('Screen change failed:', error);
    }
}

// ============================================================================
// GAME LOGIC - MAIN GAME FUNCTIONS
// ============================================================================

function startGame() {
    try {
        // Clean up any existing game state
        gameState.reset();
        // Reset difficulty tracking 
        difficultyState.reset();
        
        Object.assign(gameState, {
            currentRound: 1,
            score: 0,
            lives: 5,
            intimacyHearts: 5,
            gameStartTime: Date.now(),
            gameRunning: true,
            gameplayStarted: false
        });
        
        const achievementBoard = document.getElementById('achievementBoard');
        if (achievementBoard) {
            achievementBoard.style.display = 'block';
            achievementBoard.classList.remove('gameplay-hidden');
        }
        
        updateHUD();
        updateHeartMeter();
        
        const timeoutId = setTimeout(() => {
            updateHeartMeter();
        }, 100);
        cleanupTracker.addTimeout(timeoutId);
        
        startRound(gameState.currentRound);
        animate();
       if (mobileState.isMobile) {
           mobileState.update();
           console.log('📱 Mobile optimizations active');
       // Show mobile-specific welcome message
       setTimeout(() => {
          messageQueue.add("📱 Tap distractions to eliminate them!", 'hint', 2500);
        }, 1000);
        }
        startAmbientAudio();
        console.log('🎮 Game started successfully');
    } catch (error) {
        console.error('Game start failed:', error);
        gracefulRecover();
    }
}

function startRound(roundNumber) {
    if (roundNumber > rounds.length) {
        console.log('🏁 All rounds completed! Ending game...');
        endGame();
        return;
    }
    
    try {
        // Hide achievement board on mobile during gameplay
        if (!gameState.gameplayStarted) {
            gameState.gameplayStarted = true;
        }
        updateAchievementBoardVisibility();
        
        gameState.roundInProgress = true;
        const round = rounds[roundNumber - 1];
        gameState.roundScore = 0;
        gameState.roundMissed = 0;
        gameState.distractionsSpawned = 0;
        gameState.distractionsRequired = round.distractionsRequired;
        gameState.roundStartTime = Date.now();
        
        console.log(`🚀 Starting Round ${roundNumber}: ${round.name} - Need ${round.distractionsRequired} distractions`);
        
        if (gameState.spawnTimeout) {
            clearTimeout(gameState.spawnTimeout);
        }
        
        updateCoupleSilhouette(round.silhouette);
        playBackgroundMusic(round.bgMusic);
        
        // Show round intro popup
        showRoundIntroPopup(round);
        
        gameState.spawnTimeout = setTimeout(() => {
            spawnDistractions();
        }, 3000);
        cleanupTracker.addTimeout(gameState.spawnTimeout);
        
    } catch (error) {
        console.error('Round start failed:', error);
        gracefulRecover();
    }
}

// Achievement Board Visibility Management
function updateAchievementBoardVisibility() {
    const achievementBoard = document.getElementById('achievementBoard');
    if (!achievementBoard) return;
    
    // Enhanced mobile visibility logic
    if (mobileState.isMobile) {
        if (gameState.gameplayStarted && mobileState.orientation === 'portrait') {
            // Hide in portrait mode during gameplay for more screen space
            achievementBoard.classList.add('gameplay-hidden');
        } else if (gameState.gameplayStarted && mobileState.orientation === 'landscape') {
            // Show in landscape mode if performance is good
            if (mobileState.performance.averageFPS > 40) {
                achievementBoard.classList.remove('gameplay-hidden');
            } else {
                achievementBoard.classList.add('gameplay-hidden');
            }
        } else {
            // Show before gameplay starts
            achievementBoard.classList.remove('gameplay-hidden');
        }
    } else {
        // Always show on desktop
        achievementBoard.classList.remove('gameplay-hidden');
    }
}

function updateCoupleSilhouette(imageSrc) {
    try {
        const silhouetteDiv = document.getElementById('coupleSilhouette');
        const silhouetteImg = document.getElementById('silhouetteImage');
        
        if (silhouetteDiv && silhouetteImg) {
            silhouetteDiv.className = 'couple-silhouette';
            silhouetteDiv.style.opacity = '0';
            silhouetteDiv.classList.add('silhouette-intro-scale');

    const timeoutId = setTimeout(() => {
    silhouetteImg.src = imageSrc;
    
    const animationClass = getSilhouetteAnimationClass(gameState.currentRound);
    silhouetteDiv.classList.add(animationClass);
    
    silhouetteDiv.style.opacity = '0.8';
    silhouetteDiv.style.display = 'block';
    silhouetteDiv.classList.remove('silhouette-intro-scale');
    silhouetteDiv.classList.add('silhouette-normal-scale');
    
    const innerTimeoutId = setTimeout(() => {
        silhouetteDiv.style.opacity = '0.9';
        silhouetteDiv.classList.remove('silhouette-normal-scale');
        silhouetteDiv.classList.add('silhouette-grow-scale');
        
        const finalTimeoutId = setTimeout(() => {
            silhouetteDiv.classList.remove('silhouette-grow-scale');
            silhouetteDiv.classList.add('silhouette-normal-scale');
        }, 300);
        cleanupTracker.addTimeout(finalTimeoutId);
    }, 100);
    cleanupTracker.addTimeout(innerTimeoutId);
    
    }, 300);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Silhouette update failed:', error);
    }
}

function getSilhouetteAnimationClass(roundNumber) {
    const animations = [
        'silhouette-gentle-sway',
        'silhouette-intimate-pulse',
        'silhouette-passionate-breathe',
        'silhouette-tender-rock',
        'silhouette-loving-embrace',
        'silhouette-romantic-glow',
        'silhouette-intense-connection',
        'silhouette-ultimate-unity'
    ];
    
    return animations[roundNumber - 1] || 'silhouette-gentle-sway';
}

// Enhanced round intro popup
function showRoundIntroPopup(round) {
    try {
        if (gameState.isMobile) {
            // Mobile: Show small slide-in notification
            showMobileRoundNotification(round);
        } else {
            // Desktop: Show center popup
            const intro = document.createElement('div');
            intro.className = 'round-complete-popup show';
            intro.style.cssText = `
                position: fixed !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) scale(1) !important;
                background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%) !important;
                color: #fff !important;
                padding: 15px 25px !important;
                border-radius: 15px !important;
                text-align: center !important;
                z-index: 999 !important;
                box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5) !important;
                max-width: 250px !important;
                font-size: 0.9rem !important;
                border: 2px solid #FFD700 !important;
                backdrop-filter: blur(10px) !important;
                -webkit-backdrop-filter: blur(10px) !important;
            `;
            intro.innerHTML = `
                <div style="color: #FFD700; font-weight: bold;">Round ${gameState.currentRound}</div>
                <div>${round.name}</div>
                <div style="font-size: 1rem; margin-top: 10px;">${round.setting}</div>
            `;
            
            const gameScreen = document.getElementById('gameScreen');
            if (gameScreen) {
                gameScreen.appendChild(intro);
                
                const timeoutId = setTimeout(() => {
                    if (intro.parentNode) {
                        intro.remove();
                    }
                }, 3000);
                cleanupTracker.addTimeout(timeoutId);
            }
        }
    } catch (error) {
        console.error('Round intro popup failed:', error);
    }
}

// Enhanced mobile round notification
function showMobileRoundNotification(round) {
    if (window.innerWidth > 768) return;
    
    try {
        const notification = document.createElement('div');
        notification.className = 'mobile-round-notification';
        notification.innerHTML = `Round ${gameState.currentRound}: ${round.name}`;
        
        document.body.appendChild(notification);
        
        const timeoutId = setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutLeft 0.5s ease-out forwards';
                const innerTimeoutId = setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 500);
                cleanupTracker.addTimeout(innerTimeoutId);
            }
        }, 2500);
        cleanupTracker.addTimeout(timeoutId);
    } catch (error) {
        console.error('Mobile notification failed:', error);
    }
}

// ============================================================================
// DISTRACTION SPAWNING AND MANAGEMENT
// ============================================================================

function spawnDistractions() {
    // Delegate to adaptive spawning system
    spawnAdaptiveDistractions();
}

function createDistraction(distractionData, reactionTime) {
    try {
        const distraction = document.createElement('div');
        distraction.className = 'distraction'; 
        distraction.dataset.type = distractionData.name;
        distraction.dataset.spawnTime = Date.now();
        distraction.dataset.booster = distractionData.booster || false;

        const isTrophy = Math.random() < 0.05;
        if (isTrophy) {
            distraction.dataset.trophy = 'true';
            distraction.dataset.bonusPoints = '100';
        }

        // ADD URGENCY CALCULATION HERE - THIS WAS MISSING!
        let urgencyLevel = 'safe';
        if (reactionTime <= 1000) {
            urgencyLevel = 'critical';  // Red - very urgent
        } else if (reactionTime <= 1400) {
            urgencyLevel = 'warning';   // Yellow - moderate urgency
        } else {
            urgencyLevel = 'safe';      // Green - plenty of time
        }
        distraction.dataset.urgency = urgencyLevel;
        
        if (distractionData.special === 'sticky') {
            const stickyTexts = [
                "Don't<br>forget<br>milk!",
                "Buy<br>eggs<br>today",
                "Call<br>mom<br>❤️",
                "Meeting<br>at 3pm",
                "Gym<br>tonight!",
                "Pay<br>bills!",
                "Date<br>night<br>8pm",
                "Doctor<br>appt<br>2pm"
            ];
            const randomText = stickyTexts[Math.floor(Math.random() * stickyTexts.length)];
            distraction.innerHTML = `
                <div class="sticky-note">
                    <div style="transform: rotate(${-10 + Math.random() * 20}deg); font-size: 12px;">
                        ${randomText}
                    </div>
                </div>
            `;
        } else {
            const isTrophy = distraction.dataset.trophy === 'true';
            
            if (isTrophy) {
                // Trophy distraction
                distraction.innerHTML = `
                    <div class="distraction-icon glass trophy">
                        🏆
                        <div class="trophy-bonus">BONUS!</div>
                        <div class="priority-ring ${urgencyLevel}"></div>
                    </div>
                `;
            } else {
                // Regular distraction
                const iconClass = distractionData.booster ? 'distraction-icon glass booster' : 'distraction-icon glass';
                distraction.innerHTML = `
                    <div class="${iconClass}">
                        ${distractionData.icon}
                        <div class="priority-ring ${urgencyLevel}"></div>
                    </div>
                `;
            }
        }

         
              // Enhanced positioning with better collision detection
              const safeMargin = gameState.isMobile ? 12 : 8;
              const safeWidth = 100 - (safeMargin * 2);
              const safeHeight = gameState.isMobile ? 50 : 65; // Reduced height on mobile

              let x, y;
              let attempts = 0;
              let validPosition = false;

            do {
            x = safeMargin + Math.random() * safeWidth;
            y = (gameState.isMobile ? 30 : 25) + Math.random() * safeHeight;
            attempts++;
    
          // Check if position conflicts with visible messages
             validPosition = !isPositionOccupiedByMessage(x, y);
    
            } while (!validPosition && attempts < 15);

         // If still no valid position, force to bottom area
            if (!validPosition) {
               x = 20 + Math.random() * 60; // Center area
               y = gameState.isMobile ? 75 : 70; // Bottom area
            }

distraction.style.left = x + '%';
distraction.style.top = y + '%';

        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen) {
            gameScreen.appendChild(distraction);
        }
        const timeoutId = setTimeout(() => {
            playPriorityRingCue(urgencyLevel);
        }, 200);
        cleanupTracker.addTimeout(timeoutId);

        if (gameState.totalEliminations === 0 && !gameState.priorityTutorialShown) {
        const timeoutId = setTimeout(() => {
            messageQueue.add("🔴 Thick rings = URGENT! 🟠 Medium = Soon! 🟢 Thin = Safe!", 'hint', 3000);
            gameState.priorityTutorialShown = true;
        }, 1000);
        cleanupTracker.addTimeout(timeoutId);
        }

        playSound(distractionData.sound || 'pop', 0.3);
        gameState.distractions.push(distraction);

        // TIMER LOGIC - proper timer with safety checks
        let timeLeft = reactionTime;
        const timerInterval = setInterval(() => {
            timeLeft -= 100;
            const timerEl = distraction.querySelector('.distraction-timer');
            if (timerEl) {
                timerEl.textContent = (timeLeft / 1000).toFixed(1);
            }
            
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                cleanupTracker.intervals.delete(timerInterval);
                // Safety check: only fail if distraction still exists and is in the game
                if (distraction.parentNode && gameState.distractions.includes(distraction)) {
                    failDistraction(distraction);
                }
            }
        }, 100);

        distraction.timerInterval = timerInterval;
        cleanupTracker.addInterval(timerInterval);

    } catch (error) {
        console.error('Distraction creation failed:', error);
    }
}

// Enhanced silhouette animations
function animateSilhouetteOnSuccess() {
    try {
        const silhouette = document.getElementById('coupleSilhouette');
        if (silhouette) {
            // Brief success pulse
            silhouette.style.filter = 'drop-shadow(0 0 40px rgba(255, 215, 0, 0.8))';
            silhouette.classList.add('silhouette-grow-scale');
            
            const timeoutId = setTimeout(() => {
                silhouette.style.filter = 'drop-shadow(0 0 20px rgba(213, 54, 90, 0.5))';
                silhouette.classList.remove('silhouette-grow-scale');
                silhouette.classList.add('silhouette-normal-scale');
            }, 200);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Silhouette success animation failed:', error);
    }
}

function animateSilhouetteOnMiss(urgency = 'safe') {
    try {
        const silhouette = document.getElementById('coupleSilhouette');
        if (!silhouette) return;
        
        let shakeAnimation = 'shake 0.5s ease-out';
        let filterEffect = 'drop-shadow(0 0 20px rgba(255, 0, 0, 0.6))';
        let duration = 500;
        
        switch (urgency) {
            case 'critical':
                shakeAnimation = 'shake 0.8s ease-out';
                filterEffect = 'drop-shadow(0 0 30px rgba(255, 0, 0, 1)) brightness(0.7)';
                duration = 800;
                break;
            case 'warning':
                shakeAnimation = 'shake 0.6s ease-out';
                filterEffect = 'drop-shadow(0 0 25px rgba(255, 165, 0, 0.8)) brightness(0.85)';
                duration = 600;
                break;
            case 'safe':
                shakeAnimation = 'shake 0.4s ease-out';
                filterEffect = 'drop-shadow(0 0 20px rgba(255, 0, 0, 0.4))';
                duration = 400;
                break;
        }
        
        silhouette.style.animation = shakeAnimation;
        silhouette.style.filter = filterEffect;

        const timeoutId = setTimeout(() => {
            const originalClass = getSilhouetteAnimationClass(gameState.currentRound);
            silhouette.className = `couple-silhouette ${originalClass} silhouette-normal-scale`;
            silhouette.style.filter = 'drop-shadow(0 0 20px rgba(213, 54, 90, 0.5))';
            silhouette.style.animation = '';
        }, duration);
        cleanupTracker.addTimeout(timeoutId);
    } catch (error) {
        console.error('Enhanced silhouette miss animation failed:', error);
    }
}

// COMBO SYSTEM 
function eliminateDistraction(distraction) {
    if (!distraction.parentNode) return;
    
    try {
        if (distraction.timerInterval) {
            clearInterval(distraction.timerInterval);
            cleanupTracker.intervals.delete(distraction.timerInterval);
        }
        
        const reactionTime = Date.now() - parseInt(distraction.dataset.spawnTime);
        const isBooster = distraction.dataset.booster === 'true';
        const isTrophy = distraction.dataset.trophy === 'true';
        const urgency = distraction.dataset.urgency || 'safe';

        // Track performance for difficulty adaptation
              difficultyState.updateSkill(reactionTime, true, urgency);

        let basePoints;
        if (isTrophy) {
            basePoints = 100;
            gameState.totalTrophiesCollected++;
            
            if (!gameState.trophyBonusShown) {
                messageQueue.add("TROPHY BONUS! +100 points! 🏆", 'hint', 1500);
                gameState.trophyBonusShown = true;
            }
        } else if (isBooster) {
            basePoints = 20;
        } else {
            basePoints = 10;
        }
        
        // BALANCED COMBO SYSTEM - Not too strict, not too generous
        const now = Date.now();
        const timeSinceLastElimination = now - gameState.lastEliminationTime;

        // BALANCED COMBO WINDOW - reasonable for average players
        const comboTimeWindow = 1300; // 1.3 seconds - achievable but requires skill
        
        // Check if within combo time window
        if (timeSinceLastElimination <= comboTimeWindow && gameState.lastEliminationTime > 0) {
            gameState.comboCount++;
        } else {
            gameState.comboCount = 1; // Reset combo
        }

        gameState.lastEliminationTime = now;

        // BALANCED COMBO MULTIPLIER REQUIREMENTS
        let comboMultiplier = 1;
        let showCombo = false;
        
        if (gameState.comboCount >= 7) {
            // 3X multiplier for 7+ consecutive hits (rare but achievable)
            comboMultiplier = 3;
            showCombo = true;
        } else if (gameState.comboCount >= 4) {
            // 2X multiplier for 4-6 consecutive hits (uncommon)
            comboMultiplier = 2;
            showCombo = true;
        } else if (gameState.comboCount >= 3) {
            // 1.5X multiplier for 3 consecutive hits (achievable)
            comboMultiplier = 1.5;
            showCombo = true;
        }
        // No multiplier for 1-2 hits

        // Apply multiplier to points
        const finalPoints = Math.floor(basePoints * comboMultiplier);
        gameState.score += finalPoints;
        gameState.roundScore += finalPoints;
        
        // Show combo effect only for significant combos
        if (showCombo && comboMultiplier > 1) {
            showCenteredComboEffect(comboMultiplier, gameState.comboCount, finalPoints);
            
            // Tutorial only for 2X+ combos
            if (!gameState.comboTutorialShown && comboMultiplier >= 2) {
                messageQueue.add("COMBO! Keep tapping quickly for bonus points! 🔥", 'combo', 2500);
                gameState.comboTutorialShown = true;
            }
        }
        
        // Enhanced screen shake based on combo level
        if (comboMultiplier >= 3) {
            enhancedScreenShake(3, 400);
        } else if (comboMultiplier >= 2) {
            enhancedScreenShake(2, 300);
        } else if (comboMultiplier >= 1.5) {
            enhancedScreenShake(1, 200);
        }
        
        // Rest of elimination logic...
        gameState.totalEliminations++;
        gameState.streak++;
        
        gameState.multiKillCount++;
        if (gameState.multiKillTimer) {
            clearTimeout(gameState.multiKillTimer);
        }
        gameState.multiKillTimer = setTimeout(() => {
            gameState.multiKillCount = 0;
        }, 2000);
        cleanupTracker.addTimeout(gameState.multiKillTimer);
        
        if (gameState.streak > gameState.bestStreak) {
            gameState.bestStreak = gameState.streak;
        }
        
        gameState.consecutiveMisses = 0;
        
        if (gameState.streak >= 5 && gameState.streak % 5 === 0) {
            gainHeart('perfectCombo');
        }
        
        checkAchievements(reactionTime);
        createEnhancedParticleEffect(distraction);
        // Enhanced sound feedback with spatial audio
        const rect = distraction.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        if (isTrophy) {
            playTrophySound();
        } else if (isBooster) {
            playBoosterSound();
        } else {
            playSpatialSound(getEliminationSoundName(urgency), x, y, 0.5);
        }
        
        // Play combo sound if applicable
        if (showCombo && comboMultiplier > 1) {
            playComboSound(comboMultiplier, 0.6);
        }
        
        // Update dynamic music
        updateDynamicMusic();

        vibrate([30]);
        if (mobileState.isMobile) {
           touchFeedback.distractionHit(distraction, urgency);
        }
        animateSilhouetteOnSuccess();
        
        if (gameState.totalEliminations === 1) {
            messageQueue.add("Great job! Keep tapping!", 'hint', 1500);
        }
        
        distraction.remove();
        const index = gameState.distractions.indexOf(distraction);
        if (index > -1) {
            gameState.distractions.splice(index, 1);
        }
        
        updateHUD(false, true);
        checkRoundCompletion();
        
    } catch (error) {
        console.error('Distraction elimination failed:', error);
    }
}

// COMBO EFFECT WITH MOBILE-OPTIMIZED SIZING
function showCenteredComboEffect(multiplier, comboCount, actualPoints) {
    try {
        const comboPopup = document.createElement('div');
        
        // Mobile-responsive sizing
        const isMobile = window.innerWidth <= 768;
        const fontSize = isMobile ? '1.2rem' : '1.5rem';
        
        comboPopup.style.cssText = `
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: ${fontSize};
            font-weight: bold;
            color: ${getComboColor(multiplier)};
            text-shadow: 0 0 10px ${getComboColor(multiplier)};
            pointer-events: none;
            z-index: 2500;
            animation: centeredComboFloat 2s ease-out forwards;
            text-align: center;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid ${getComboColor(multiplier)};
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        `;
        
        // Enhanced combo text with rarity indicators
        let comboText;
        if (multiplier >= 3) {
            comboText = `🔥 LEGENDARY ${multiplier}X COMBO! +${actualPoints} pts`;
        } else if (multiplier >= 2) {
            comboText = `⚡ EPIC ${multiplier}X COMBO! +${actualPoints} pts`;
        } else {
            comboText = `✨ COMBO ${multiplier}X! +${actualPoints} pts`;
        }
        
        comboPopup.textContent = comboText;
        
        // Add directly to body to ensure it's always centered
        document.body.appendChild(comboPopup);
        
        const timeoutId = setTimeout(() => {
            if (comboPopup.parentNode) {
                comboPopup.remove();
            }
        }, 2000);
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.error('Centered combo effect failed:', error);
    }
}

// COMBO ANIMATION - ALWAYS CENTERED
const centeredComboFloatCSS = `
@keyframes centeredComboFloat {
    0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
    }
    15% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
    }
    30% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
    70% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0;
    }
}
`;

// CSS animation 
if (!document.getElementById('centeredComboCSS')) {
    const style = document.createElement('style');
    style.id = 'centeredComboCSS';
    style.textContent = centeredComboFloatCSS;
    document.head.appendChild(style);
}

function showCenteredComboEffect(multiplier, comboCount, actualPoints) {
    try {
        const comboPopup = document.createElement('div');
        
        // Mobile-optimized sizing
        const isMobile = window.innerWidth <= 768;
        const fontSize = isMobile ? '1rem' : '1.2rem'; // Smaller font size
        
        comboPopup.style.cssText = `
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: ${fontSize};
            font-weight: bold;
            color: ${getComboColor(multiplier)};
            text-shadow: 0 0 8px ${getComboColor(multiplier)};
            pointer-events: none;
            z-index: 2500;
            animation: centeredComboFloat 1.8s ease-out forwards;
            text-align: center;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px;
            border-radius: 10px;
            border: 2px solid ${getComboColor(multiplier)};
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            max-width: ${isMobile ? '200px' : '250px'};
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        `;
        
        // Shorter, cleaner combo text
        let comboText;
        if (multiplier >= 3) {
            comboText = `🔥 ${multiplier}X COMBO! +${actualPoints}`;
        } else if (multiplier >= 2) {
            comboText = `⚡ ${multiplier}X COMBO! +${actualPoints}`;
        } else {
            comboText = `✨ ${multiplier}X! +${actualPoints}`;
        }
        
        comboPopup.textContent = comboText;
        
        // Add to body for proper centering
        document.body.appendChild(comboPopup);
        
        const timeoutId = setTimeout(() => {
            if (comboPopup.parentNode) {
                comboPopup.remove();
            }
        }, 1800);
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.error('Centered combo effect failed:', error);
    }
}

function failDistraction(distraction) {
    console.log('💥 DISTRACTION FAILED:', distraction.dataset.type, 'Hearts before:', gameState.intimacyHearts);
    try {
        
        if (distraction.timerInterval) {
            clearInterval(distraction.timerInterval);
            cleanupTracker.intervals.delete(distraction.timerInterval);
        }
        
        // Get urgency level for enhanced feedback
        const urgency = distraction.dataset.urgency || 'safe';
        // Track miss for difficulty adaptation
        const reactionTime = Date.now() - parseInt(distraction.dataset.spawnTime);
              difficultyState.updateSkill(reactionTime, false, urgency);
        const currentTime = Date.now();
        
        if (currentTime - gameState.lastMissTime < 10000) {
            gameState.consecutiveMisses++;
        } else {
            gameState.consecutiveMisses = 1;
        }
        gameState.lastMissTime = currentTime;
        
        let lossReason = 'missed';
        if (gameState.consecutiveMisses >= 2) {
            lossReason = 'consecutive';
        }
        
        const isCritical = (gameState.currentRound >= 7) && 
                         (distraction.dataset.type === 'phone' || 
                          distraction.dataset.type === 'thoughts' || 
                          distraction.dataset.type === 'latework');
        
        if (isCritical) {
            lossReason = 'critical';
        }
        
        // URGENCY-BASED SCREEN SHAKE AND VISUAL FEEDBACK
        applyUrgencyMissEffects(urgency, lossReason);
        
        loseHeart(lossReason);
        gameState.streak = 0;
        gameState.roundMissed++;

        // Enhanced miss sound with spatial audio
        const rect = distraction.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        playSpatialSound(getMissSoundName(urgency), x, y, 0.4);
        
        // Update dynamic music
        updateDynamicMusic();

        // Enhanced silhouette miss animation based on urgency
        animateSilhouetteOnMiss(urgency);
        
        if (gameState.roundMissed >= 2) {
            messageQueue.add("Focus! Don't lose the connection!", 'hint', 2000);
        }
        
        distraction.remove();
        const index = gameState.distractions.indexOf(distraction);
        if (index > -1) {
            gameState.distractions.splice(index, 1);
        }
        
        if (gameState.intimacyHearts <= 0) {
            if (gameState.spawnTimeout) {
                clearTimeout(gameState.spawnTimeout);
                gameState.spawnTimeout = null;
            }
            gameState.roundInProgress = false;
        
            const timeoutId = setTimeout(() => {
                endGame();
            }, 1000);
            cleanupTracker.addTimeout(timeoutId);
        } else {
            checkRoundCompletion();
        }

    } catch (error) {
        console.error('Distraction failure handling failed:', error);
    }
}


// Round completion check with safety guards
function checkRoundCompletion() {
    try {
        console.log('🔍 Checking round completion:', {
            spawned: gameState.distractionsSpawned,
            required: gameState.distractionsRequired,
            remaining: gameState.distractions.length,
            roundInProgress: gameState.roundInProgress,
            totalEliminations: gameState.totalEliminations
        });
        
        // Enhanced safety checks
        if (gameState.distractionsSpawned >= gameState.distractionsRequired && 
            gameState.distractions.length === 0 && 
            gameState.roundInProgress &&
            (gameState.totalEliminations > 0 || gameState.roundMissed > 0)) { // Allow completion with some activity
            console.log('✅ Round completion criteria met!');
            completeRound();
        }
    } catch (error) {
        console.error('Round completion check failed:', error);
    }
}

// ============================================================================
// VISUAL EFFECTS AND UI 
// ============================================================================

function createEnhancedParticleEffect(element) {
    try {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        // Get distraction properties
        const urgency = element.dataset.urgency || 'safe';
        const isBooster = element.dataset.booster === 'true';
        const isTrophy = element.dataset.trophy === 'true';
        
        // Determine particle properties based on urgency and type
        const particleConfig = getParticleConfig(urgency, isBooster, isTrophy);
        
        const particleCount = gameState.isMobile ? particleConfig.count / 2 : particleConfig.count;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'urgency-particle';
            
            // Random trajectory
            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
            const distance = 50 + Math.random() * particleConfig.spread;
            const tx = Math.cos(angle) * distance;
            const ty = Math.sin(angle) * distance;
            
            particle.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                width: ${particleConfig.size}px;
                height: ${particleConfig.size}px;
                background: ${particleConfig.colors[i % particleConfig.colors.length]};
                border-radius: 50%;
                pointer-events: none;
                z-index: 2000;
                box-shadow: 0 0 ${particleConfig.glow}px ${particleConfig.colors[i % particleConfig.colors.length]};
                animation: urgencyParticleFly ${particleConfig.duration}s ease-out forwards;
                --tx: ${tx}px;
                --ty: ${ty}px;
                --fade-delay: ${particleConfig.fadeDelay}s;
            `;
            
            document.body.appendChild(particle);
            
            const timeoutId = setTimeout(() => {
                if (particle.parentNode) {
                    particle.remove();
                }
            }, particleConfig.duration * 1000);
            cleanupTracker.addTimeout(timeoutId);
        }
        
        // Add special effects for certain types
        if (isTrophy) {
            createTrophySparkleEffect(x, y);
        } else if (isBooster) {
            createBoosterRingEffect(x, y);
        }
        
    } catch (error) {
        console.error('Enhanced particle effect creation failed:', error);
    }
}

// PARTICLE CONFIGURATION SYSTEM
function getParticleConfig(urgency, isBooster, isTrophy) {
    if (isTrophy) {
        return {
            count: 12,
            size: 6,
            colors: ['#FFD700', '#FFA500', '#FFFF00', '#FF8C00'],
            spread: 80,
            duration: 1.2,
            glow: 8,
            fadeDelay: 0.3
        };
    }
    
    if (isBooster) {
        return {
            count: 10,
            size: 5,
            colors: ['#FFD700', '#FFA500', '#FFAA00'],
            spread: 70,
            duration: 1.0,
            glow: 6,
            fadeDelay: 0.2
        };
    }
    
    // Regular distractions - urgency-based
    switch (urgency) {
        case 'critical':
            return {
                count: 8,
                size: 4,
                colors: ['#FF4444', '#FF6666', '#FF8888', '#FFAAAA'],
                spread: 60,
                duration: 0.8,
                glow: 5,
                fadeDelay: 0.1
            };
        case 'warning':
            return {
                count: 6,
                size: 4,
                colors: ['#FFA500', '#FFB84D', '#FFCC66'],
                spread: 50,
                duration: 0.9,
                glow: 4,
                fadeDelay: 0.15
            };
        case 'safe':
        default:
            return {
                count: 5,
                size: 3,
                colors: ['#32CD32', '#66FF66', '#90EE90'],
                spread: 40,
                duration: 1.0,
                glow: 3,
                fadeDelay: 0.2
            };
    }
}

// SPECIAL TROPHY SPARKLE EFFECT
function createTrophySparkleEffect(x, y) {
    try {
        for (let i = 0; i < 5; i++) {
            const sparkle = document.createElement('div');
            sparkle.innerHTML = '✨';
            sparkle.style.cssText = `
                position: fixed;
                left: ${x + (Math.random() - 0.5) * 60}px;
                top: ${y + (Math.random() - 0.5) * 60}px;
                font-size: ${12 + Math.random() * 8}px;
                color: #FFD700;
                pointer-events: none;
                z-index: 2100;
                animation: trophySparkle 1.5s ease-out forwards;
                text-shadow: 0 0 10px #FFD700;
            `;
            
            document.body.appendChild(sparkle);
            
            const timeoutId = setTimeout(() => {
                if (sparkle.parentNode) {
                    sparkle.remove();
                }
            }, 1500);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Trophy sparkle effect failed:', error);
    }
}

// SPECIAL BOOSTER RING EFFECT
function createBoosterRingEffect(x, y) {
    try {
        const ring = document.createElement('div');
        ring.style.cssText = `
            position: fixed;
            left: ${x - 30}px;
            top: ${y - 30}px;
            width: 60px;
            height: 60px;
            border: 3px solid #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2050;
            animation: boosterRingExpand 0.8s ease-out forwards;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        `;
        
        document.body.appendChild(ring);
        
        const timeoutId = setTimeout(() => {
            if (ring.parentNode) {
                ring.remove();
            }
        }, 800);
        cleanupTracker.addTimeout(timeoutId);
    } catch (error) {
        console.error('Booster ring effect failed:', error);
    }
}

function enhancedShakeScreen() {
    try {
        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen) {
            gameScreen.style.animation = 'none';
            const timeoutId = setTimeout(() => {
                gameScreen.style.animation = 'shake 0.5s ease-out';
                
                const resetTimeoutId = setTimeout(() => {
                    gameScreen.style.animation = '';
                }, 500);
                cleanupTracker.addTimeout(resetTimeoutId);
            }, 10);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Screen shake failed:', error);
    }
}

function enhancedScreenShake(intensity = 1, duration = 500) {
    try {
        const gameScreen = document.getElementById('gameScreen');
        if (!gameScreen) return;
        
        // Prevent shake spam
        const now = Date.now();
        if (now - gameState.lastShakeTime < 100) return;
        gameState.lastShakeTime = now;
        
        // Calculate shake parameters based on intensity
        const shakeDistance = Math.min(intensity * 3, 15); // Max 15px shake
        const shakeSpeed = Math.max(50, 100 - (intensity * 10)); // Faster for higher intensity
        
        let shakeCount = 0;
        const maxShakes = Math.min(intensity * 2, 8); // Max 8 shakes
        
        const shakeInterval = setInterval(() => {
            if (shakeCount >= maxShakes) {
                clearInterval(shakeInterval);
                gameScreen.style.transform = ''; // Reset position
                cleanupTracker.intervals.delete(shakeInterval);
                return;
            }
            
            const randomX = (Math.random() - 0.5) * shakeDistance;
            const randomY = (Math.random() - 0.5) * shakeDistance;
            
            gameScreen.style.transform = `translate(${randomX}px, ${randomY}px)`;
            shakeCount++;
        }, shakeSpeed);
        
        cleanupTracker.addInterval(shakeInterval);
        
    } catch (error) {
        console.error('Enhanced screen shake failed:', error);
    }
}

// URGENCY-BASED MISS EFFECTS
function applyUrgencyMissEffects(urgency, lossReason) {
    try {
        // Screen shake intensity based on urgency
        let shakeIntensity = 1;
        let shakeDuration = 300;
        let vibratePattern = [100];
        
        switch (urgency) {
            case 'critical':
                shakeIntensity = 4;
                shakeDuration = 600;
                vibratePattern = [150, 50, 150, 50, 150];
                // Red screen flash
                createScreenFlash('#FF4444', 0.3);
                break;
            case 'warning':
                shakeIntensity = 2;
                shakeDuration = 400;
                vibratePattern = [100, 30, 100];
                // Orange screen flash
                createScreenFlash('#FFA500', 0.2);
                break;
            case 'safe':
                shakeIntensity = 1;
                shakeDuration = 200;
                vibratePattern = [80];
                // Green screen flash (subtle)
                createScreenFlash('#32CD32', 0.1);
                break;
        }
        
        // Apply enhanced screen shake
        enhancedScreenShake(shakeIntensity, shakeDuration);
        
        // Apply vibration
        if (mobileState.isMobile) {
    touchFeedback.haptic('error');
        } else {
             vibrate(vibratePattern);
        }
        
        // Play urgency-appropriate sound
        playUrgencyMissSound(urgency);
        
    } catch (error) {
        console.error('Urgency miss effects failed:', error);
    }
}

// SCREEN FLASH EFFECT
function createScreenFlash(color, opacity) {
    try {
        const flash = document.createElement('div');
        flash.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: ${color};
            opacity: ${opacity};
            pointer-events: none;
            z-index: 3000;
            animation: screenFlash 0.4s ease-out forwards;
        `;
        
        document.body.appendChild(flash);
        
        const timeoutId = setTimeout(() => {
            if (flash.parentNode) {
                flash.remove();
            }
        }, 400);
        cleanupTracker.addTimeout(timeoutId);
    } catch (error) {
        console.error('Screen flash effect failed:', error);
    }
}

// PLAY URGENCY-BASED MISS SOUND
function playUrgencyMissSound(urgency) {
    try {
        // Use enhanced miss sounds 
        const rect = { left: window.innerWidth / 2, top: window.innerHeight / 2, width: 0, height: 0 };
        const x = rect.left;
        const y = rect.top;
        
        playSpatialSound(getMissSoundName(urgency), x, y, 0.4);
    } catch (error) {
        console.error('Urgency miss sound failed:', error);
    }
}

function updateHUD(animateLoss = false, animateScore = false) {
    try {
        const scoreEl = document.getElementById('score');
        if (scoreEl) {
            scoreEl.textContent = gameState.score;
            if (animateScore) {
                scoreEl.style.transform = 'scale(1.2)';
                scoreEl.style.color = '#FFD700';
                const timeoutId = setTimeout(() => {
                    scoreEl.style.transform = 'scale(1)';
                    scoreEl.style.color = '';
                }, 200);
                cleanupTracker.addTimeout(timeoutId);
            }
        }
        
        // Update FPS display if exists
        const fpsEl = document.getElementById('fps');
        if (fpsEl) {
            fpsEl.textContent = `FPS: ${performanceMonitor.fps}`;
            fpsEl.style.color = performanceMonitor.fps < 30 ? '#ff4444' : '#44ff44';
        }
        
        updateHeartMeter();
    } catch (error) {
        console.error('HUD update failed:', error);
    }
}

// ShowHint messages
function showHint(message, duration = 2000) {
    // Simply delegate to the message queue system
    messageQueue.add(message, 'hint', duration);
}

// ============================================================================
// ROUND COMPLETION AND PROGRESSION
// ============================================================================

function completeRound() {
    try {
        console.log('🎉 Completing round', gameState.currentRound);
        
        gameState.gameRunning = false;
        gameState.roundInProgress = false;
        
        if (gameState.spawnTimeout) {
            clearTimeout(gameState.spawnTimeout);
        }
        
        // Clean up remaining distractions
        gameState.distractions.forEach(d => {
            if (d.timerInterval) {
                clearInterval(d.timerInterval);
                cleanupTracker.intervals.delete(d.timerInterval);
            }
            if (d.parentNode) d.remove();
        });
        gameState.distractions = [];
        
        const roundTime = (Date.now() - gameState.roundStartTime) / 1000;
        console.log(`⏱️ Round ${gameState.currentRound} completed in ${roundTime.toFixed(1)}s`);
        
        // Speed Demon achievement check (Round 1 < 30s)
        if (gameState.currentRound === 1 && roundTime < 30 && !gameState.achievements.has('speedDemon')) {
            gameState.achievements.add('speedDemon');
            showAchievement(achievements.speedDemon);
        }
        
        // Perfect round bonus
        if (gameState.roundMissed === 0) {
            gameState.perfectRounds++;
            gainHeart('roundCompletion');
            
            if (!gameState.achievements.has('penetratingFocus')) {
                gameState.achievements.add('penetratingFocus');
                const timeoutId = setTimeout(() => {
                    showAchievement(achievements.penetratingFocus);
                }, 50); // Faster achievement display
                cleanupTracker.addTimeout(timeoutId);
            }
        }
        
        // MUCH FASTER ROUND TRANSITION - Show popup briefly and move on quickly
        const timeoutId = setTimeout(() => {
            const roundPopup = document.getElementById('roundCompletePopup');
            const roundNumber = document.getElementById('roundNumber');
            
            if (roundPopup && roundNumber) {
                roundNumber.textContent = gameState.currentRound;
                roundPopup.style.position = 'fixed';
                roundPopup.style.top = '55%';
                roundPopup.classList.add('show');
                
                // FASTER POPUP DISMISSAL - Only 800ms instead of 2000ms
                const innerTimeoutId = setTimeout(() => {
                    roundPopup.classList.remove('show');
                    
                    // Immediate round progression - no extra delay
                    gameState.currentRound++;
                    console.log('🚀 Moving to round', gameState.currentRound);
                    
                    if (gameState.currentRound > rounds.length) {
                        console.log('🏁 All rounds completed!');
                        endGame();
                    } else {
                        gameState.gameRunning = true;
                        startRound(gameState.currentRound);
                    }
                }, 800); // Reduced from 2000ms to 800ms
                cleanupTracker.addTimeout(innerTimeoutId);
            }
        }, gameState.roundMissed === 0 ? 300 : 50); // Much faster initial delay
        cleanupTracker.addTimeout(timeoutId);
        
    } catch (error) {
        console.error('Round completion failed:', error);
        gracefulRecover();
    }
}

// COMBO COLOR SYSTEM (unchanged but included for completeness)
function getComboColor(multiplier) {
    if (multiplier >= 3) return '#FF4444'; // Red for 3X
    if (multiplier >= 2) return '#FF8800'; // Orange for 2X  
    if (multiplier >= 1.5) return '#FFD700'; // Gold for 1.5X
    return '#FFFFFF'; // White fallback
}

// ============================================================================
// ENHANCED ACHIEVEMENT SYSTEM WITH SPAM PREVENTION
// ============================================================================

function checkAchievements(reactionTime) {
    try {
        if (reactionTime < 800 && !gameState.achievements.has('quickDraw')) {
            gameState.achievements.add('quickDraw');
            showAchievement(achievements.quickDraw);
        }
        
        if (gameState.multiKillCount >= 3 && !gameState.achievements.has('multiPosition')) {
            gameState.achievements.add('multiPosition');
            showAchievement(achievements.multiPosition);
        }
        
        if (gameState.streak >= 7 && !gameState.achievements.has('heatWave')) {
            gameState.achievements.add('heatWave');
            showAchievement(achievements.heatWave);
        }
        
        if (gameState.perfectRounds >= 2 && !gameState.achievements.has('staminaSupreme')) {
            gameState.achievements.add('staminaSupreme');
            showAchievement(achievements.staminaSupreme);
        }
        
        if (gameState.score >= 150 && !gameState.achievements.has('warrior3x')) {
            gameState.achievements.add('warrior3x');
            showAchievement(achievements.warrior3x);
        }
    } catch (error) {
        console.error('Achievement check failed:', error);
    }
}

function showAchievement(achievement) {
    try {
        // Prevent achievement spam
        if (gameState.achievementShown.has(achievement.id)) {
            return;
        }
        gameState.achievementShown.add(achievement.id);
        
        const popup = document.getElementById('achievementPopup');
        const icon = document.getElementById('achievementIcon');
        const title = document.getElementById('achievementTitle');
        const desc = document.getElementById('achievementDesc');
        
        if (popup && icon && title && desc) {
            icon.textContent = achievement.icon;
            title.textContent = achievement.name;
            desc.textContent = achievement.desc;
            
            popup.classList.add('show');
            playSound('achievement', 0.7);
            
            // Enhanced vibration for achievements
            vibrate([200, 100, 200]);
            
            // Update the achievement board with animation
            updateAchievementBoard(achievement.id);
            
            // Mobile achievement notification
            showMobileAchievementNotification(achievement);
            
            const timeoutId = setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Achievement display failed:', error);
    }
}

// Enhanced Achievement Board Update Function
function updateAchievementBoard(achievementId) {
    try {
        console.log('🏆 Updating achievement board for:', achievementId);
        
        // Achievement mapping to board items
        const achievementMap = {
            'quickDraw': 'Quick Draw',
            'penetratingFocus': 'Perfect Round',
            'multiPosition': 'Multi-Position',
            'heatWave': 'Heat Wave',
            'warrior3x': '3X Warrior',
            'speedDemon': 'Speed Demon',
            'staminaSupreme': 'Stamina Supreme',
            'climaxControl': 'Climax Control'
        };
        
        const achievementItems = document.querySelectorAll('.achievement-board li');
        const targetText = achievementMap[achievementId];
        
        if (!targetText) {
            console.log('⚠️ No mapping found for achievement:', achievementId);
            return;
        }
        
        achievementItems.forEach(item => {
            const text = item.textContent;
            
            // Check if this item matches the unlocked achievement
            if (text.includes(targetText)) {
                console.log('✅ Found matching achievement item:', text);
                
                // Mark as unlocked with animation
                item.classList.add('unlocked', 'just-unlocked');
                
                // Add a sparkle effect
                createSparkleEffect(item);
                
                // Remove the unlock animation after it completes, keep unlocked state
                const timeoutId = setTimeout(() => {
                    item.classList.remove('just-unlocked');
                }, 1500);
                cleanupTracker.addTimeout(timeoutId);
            }
        });
    } catch (error) {
        console.error('Achievement board update failed:', error);
    }
}

// Sparkle effect for achievements
function createSparkleEffect(element) {
    try {
        for (let i = 0; i < 3; i++) {
            const timeoutId = setTimeout(() => {
                const sparkle = document.createElement('div');
                sparkle.innerHTML = '✨';
                sparkle.style.cssText = `
                    position: absolute;
                    font-size: 12px;
                    color: #FFD700;
                    pointer-events: none;
                    animation: sparkleFloat 1s ease-out forwards;
                    left: ${Math.random() * 100}%;
                    top: 50%;
                    z-index: 1000;
                `;
                
                element.style.position = 'relative';
                element.appendChild(sparkle);
                
                const cleanupTimeoutId = setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.remove();
                    }
                }, 1000);
                cleanupTracker.addTimeout(cleanupTimeoutId);
            }, i * 200);
            cleanupTracker.addTimeout(timeoutId);
        }
    } catch (error) {
        console.error('Sparkle effect failed:', error);
    }
}

function showMobileAchievementNotification(achievement) {
    // Only show on mobile
    if (window.innerWidth > 768) return;
    
    try {
        const notification = document.createElement('div');
        notification.className = 'mobile-achievement-notification';
        
        // Enhanced content with icon and name
        notification.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                <span style="font-size: 1.2rem;">${achievement.icon}</span>
                <span style="font-weight: bold;">${achievement.name}</span>
            </div>
            <div style="font-size: 0.65rem; margin-top: 2px; opacity: 0.9;">
                ${achievement.desc}
            </div>
        `;
        
        document.body.appendChild(notification);
        
        const timeoutId = setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutLeft 0.5s ease-out forwards';
                const innerTimeoutId = setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 500);
                cleanupTracker.addTimeout(innerTimeoutId);
            }
        }, 4000); // Show longer for better readability
        cleanupTracker.addTimeout(timeoutId);
    } catch (error) {
        console.error('Mobile achievement notification failed:', error);
    }
}

// ============================================================================
// ENHANCED GAME END AND RESULTS
// ============================================================================

function endGame() {
    if (gameState.gameEnding) return;
    gameState.gameEnding = true;

    try {
        console.log('🏁 Game ending...');

        gameState.cleanup();
        stopBackgroundMusic();
        stopAmbientAudio();
        const achievementBoard = document.getElementById('achievementBoard');
        if (achievementBoard) {
            achievementBoard.style.display = 'none';
        }
        
        gameState.lastScore = gameState.score;
        try {
            localStorage.setItem('lastScore', gameState.score);
            localStorage.setItem('audioEnabled', gameState.audioEnabled);
            
            // Update best scores
            const currentBest = localStorage.getItem('bestScore') || 0;
            if (gameState.score > currentBest) {
                localStorage.setItem('bestScore', gameState.score);
            }
            
            const currentBestStreak = localStorage.getItem('bestStreak') || 0;
            if (gameState.bestStreak > currentBestStreak) {
                localStorage.setItem('bestStreak', gameState.bestStreak);
            }
        } catch (error) {
            console.error('Storage save failed:', error);
        }
        
        const silhouetteDiv = document.getElementById('coupleSilhouette');
        if (silhouetteDiv) {
            silhouetteDiv.style.display = 'none';
        }
        
        const playTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
        
        let message = `Your embrace lasted ${playTime} seconds!`;
        const gameCompleted = gameState.currentRound > rounds.length;
        const heartsRemaining = gameState.intimacyHearts;
        const totalRoundsCompleted = gameCompleted ? rounds.length : gameState.currentRound - 1;
        const averageScorePerRound = gameState.score / Math.max(totalRoundsCompleted, 1);

        if (gameCompleted && heartsRemaining === 5) {
           message += " PERFECT MASTERY! Ultimate intimacy achieved! 🔥👑";
        } else if (gameCompleted && heartsRemaining >= 3) {
           message += " LEGENDARY PERFORMANCE! You conquered all distractions! 🏆";
        } else if (gameCompleted && heartsRemaining >= 1) {
           message += " INCREDIBLE ENDURANCE! You completed the journey! 💪";
        } else if (gameState.score >= 1500) {
           message += " MASTER-LEVEL focus! Outstanding performance! ⚡";
        } else if (gameState.score >= 1000) {
          message += " EXPERT-LEVEL stamina! Impressive dedication! 🎯";
       } else if (gameState.score >= 500) {
          message += " ADVANCED performance! You're getting stronger! 💎";
       } else if (gameState.score >= 200) {
         message += " GOOD focus! Keep practicing for mastery! 📈";
       } else {
        message += " Every master started as a beginner! Keep going! 🌟";
       }
        
        const finalScore = document.getElementById('finalScore');
        const performanceMessage = document.getElementById('performanceMessage');
        
        if (finalScore) finalScore.textContent = gameState.score;
        if (performanceMessage) performanceMessage.textContent = message;
        
        generateQRCode();
        generateChallengeCode();
        
        // Check climax control achievement once at the end
        if (gameState.intimacyHearts === 5 && !gameState.achievements.has('climaxControl')) {
            gameState.achievements.add('climaxControl');
            showAchievement(achievements.climaxControl);
        }
        
        const timeoutId = setTimeout(() => {
            showScreen('resultsScreen');
        }, 1000);
        cleanupTracker.addTimeout(timeoutId);
        
        console.log('🏁 Game ended successfully');
    } catch (error) {
        console.error('Game end failed:', error);
        gracefulRecover();
    }
}

// ============================================================================
// ENHANCED QR CODE AND CHALLENGE SYSTEM
// ============================================================================

function generateQRCode() {
    try {
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv || typeof QRious === 'undefined') return;
        
        qrDiv.innerHTML = '';
        
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        new QRious({
            element: canvas,
            value: 'https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756?ref=endless-embrace-qr&score=' + gameState.score + '&challenge=' + gameState.challengeCode,
            size: 130,
            foreground: '#000000',
            background: '#ffffff',
            level: 'H'
        });
    } catch (error) {
        console.error('QR Code generation failed:', error);
    }
}

function saveQRCode() {
    try {
        const canvas = document.querySelector('#qrCode canvas');
        if (canvas) {
            const link = document.createElement('a');
            link.download = `ks-endless-embrace-score-${gameState.score}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
    } catch (error) {
        console.error('QR Code save failed:', error);
    }
}

function generateChallengeCode() {
    try {
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        gameState.challengeCode = code;
        
        const challengeCodeEl = document.getElementById('challengeCode');
        if (challengeCodeEl) {
            challengeCodeEl.textContent = code;
        }
        
        const challengeData = {
            code: code,
            score: gameState.score,
            time: Math.floor((Date.now() - gameState.gameStartTime) / 1000),
            achievements: Array.from(gameState.achievements),
            lives: gameState.lives,
            perfectRounds: gameState.perfectRounds,
            timestamp: Date.now()
        };
        
        localStorage.setItem('challenge_' + code, JSON.stringify(challengeData));
        
        const coupleStatus = document.getElementById('coupleStatus');
        const challengeStatusText = document.getElementById('challengeStatusText');
        
        if (coupleStatus && challengeStatusText) {
            coupleStatus.style.display = 'block';
            challengeStatusText.textContent = 'Challenge created! Share this code with your partner.';
        }
    } catch (error) {
        console.error('Challenge code generation failed:', error);
    }
}

function showEnterCode() {
    const code = prompt('Enter your partner\'s challenge code:');
    if (code && code.length === 6) {
        enterChallengeCode(code);
    }
}

function enterChallengeCode(code) {
    try {
        const partnerData = localStorage.getItem('challenge_' + code);
        if (partnerData) {
            const partner = JSON.parse(partnerData);
            
            // Check if challenge is not too old (24 hours)
            const timeSince = Date.now() - partner.timestamp;
            if (timeSince > 86400000) {
                alert('This challenge code has expired. Please get a new one from your partner.');
                return;
            }
            
            const yourData = {
                score: gameState.score,
                time: Math.floor((Date.now() - gameState.gameStartTime) / 1000),
                achievements: Array.from(gameState.achievements)
            };
            
            displayCoupleResults(yourData, partner);
        } else {
            alert('Invalid challenge code. Please check and try again.');
        }
    } catch (error) {
        console.error('Challenge code processing failed:', error);
        alert('Error processing challenge code.');
    }
}

// ============================================================================
// ENHANCED COUPLE CHALLENGE SYSTEM
// ============================================================================

function displayCoupleResults(player1, player2) {
    try {
        const metrics = calculateCoupleMetrics(player1, player2);
        
        const elements = {
            yourScore: document.getElementById('yourScore'),
            partnerScore: document.getElementById('partnerScore'),
            totalScore: document.getElementById('totalScore'),
            harmonyLevel: document.getElementById('harmonyLevel'),
            combinedTime: document.getElementById('combinedTime'),
            coupleResults: document.getElementById('coupleResults')
        };
        
        if (elements.yourScore) elements.yourScore.textContent = player1.score;
        if (elements.partnerScore) elements.partnerScore.textContent = player2.score;
        if (elements.totalScore) elements.totalScore.textContent = metrics.totalScore;
        if (elements.harmonyLevel) elements.harmonyLevel.textContent = metrics.harmonyLevel;
        if (elements.combinedTime) elements.combinedTime.textContent = metrics.combinedTime + 's';
        if (elements.coupleResults) elements.coupleResults.style.display = 'block';
        
        checkCoupleAchievements(metrics, player1, player2);
    } catch (error) {
        console.error('Couple results display failed:', error);
    }
}

function calculateCoupleMetrics(player1Data, player2Data) {
    const totalScore = player1Data.score + player2Data.score;
    const averageScore = (player1Data.score + player2Data.score) / 2;
    const combinedTime = player1Data.time + player2Data.time;
    const scoreDifference = Math.abs(player1Data.score - player2Data.score);
    const harmonyLevel = calculateHarmony(player1Data.score, player2Data.score);
    const sharedAchievements = player1Data.achievements.filter(a => 
        player2Data.achievements.includes(a));
    
    return {
        totalScore,
        averageScore,
        combinedTime,
        scoreDifference,
        harmonyLevel,
        sharedAchievements,
        leader: player1Data.score > player2Data.score ? 'You' : 'Partner',
        winMargin: Math.abs(player1Data.score - player2Data.score)
    };
}

function calculateHarmony(score1, score2) {
    const difference = Math.abs(score1 - score2);
    const average = (score1 + score2) / 2;
    const harmonyPercentage = Math.max(0, 100 - (difference / average * 100));
    
    if (harmonyPercentage >= 90) return "Perfect Harmony ❤️";
    if (harmonyPercentage >= 75) return "Great Sync 💕";
    if (harmonyPercentage >= 60) return "Good Connection 😊";
    if (harmonyPercentage >= 40) return "Room to Improve 🤔";
    return "Opposites Attract? 😅";
}

function checkCoupleAchievements(metrics, player1, player2) {
    try {
        const unlockedAchievements = [];
        
        if (metrics.scoreDifference <= metrics.averageScore * 0.1) {
            unlockedAchievements.push(coupleAchievements.perfectHarmony);
        }
        
        if (metrics.totalScore > 300) {
            unlockedAchievements.push(coupleAchievements.powerCouple);
        }
        
        if (metrics.combinedTime > 180) {
            unlockedAchievements.push(coupleAchievements.marathonLovers);
        }
        
        if (metrics.sharedAchievements.length >= 3) {
            unlockedAchievements.push(coupleAchievements.synchronizedSouls);
        }
        
        if (metrics.scoreDifference > 100) {
            unlockedAchievements.push(coupleAchievements.competitiveSpirits);
        }
        
        if (player1.score === player2.score) {
            unlockedAchievements.push(coupleAchievements.twinFlames);
        }
        
        if (unlockedAchievements.length > 0) {
            const timeoutId = setTimeout(() => {
                unlockedAchievements.forEach((achievement, index) => {
                    const innerTimeoutId = setTimeout(() => {
                        showAchievement(achievement);
                    }, index * 1500);
                    cleanupTracker.addTimeout(innerTimeoutId);
                });
            }, 500);
            cleanupTracker.addTimeout(timeoutId);
        }
        
        return unlockedAchievements;
    } catch (error) {
        console.error('Couple achievements check failed:', error);
        return [];
    }
}

// ============================================================================
// ENHANCED UTILITY FUNCTIONS
// ============================================================================

function restartGame() {
    try {
        cleanupTracker.cleanup();
        showScreen('gameScreen');
    } catch (error) {
        console.error('Game restart failed:', error);
        gracefulRecover();
    }
}

function shareWhatsApp() {
    try {
        let message;
        
        const coupleResults = document.getElementById('coupleResults');
        if (coupleResults && coupleResults.style.display !== 'none') {
            const template = coupleSharingTemplates[Math.floor(Math.random() * coupleSharingTemplates.length)];
            const totalScore = document.getElementById('totalScore')?.textContent || '0';
            const harmonyLevel = document.getElementById('harmonyLevel')?.textContent || 'Unknown';
            const combinedTime = document.getElementById('combinedTime')?.textContent.replace('s', '') || '0';
            
            message = template
                .replace('{totalScore}', totalScore)
                .replace('{harmonyLevel}', harmonyLevel)
                .replace('{combinedTime}', combinedTime)
                .replace('{challengeCode}', gameState.challengeCode || '');
        } else {
            const template = hinglishTemplates[Math.floor(Math.random() * hinglishTemplates.length)];
            message = template
                .replace('{score}', gameState.score)
                .replace('{time}', Math.floor((Date.now() - gameState.gameStartTime) / 1000))
                .replace('{streak}', gameState.bestStreak);
        }
        
        const url = `https://wa.me/?text=${encodeURIComponent(message + '\n\nPlay here: ' + window.location.href + '?challenge=' + (gameState.challengeCode || ''))}`;
        window.open(url, '_blank');
        
    } catch (error) {
        console.error('WhatsApp sharing failed:', error);
    }
}

function toggleAudio() {
    try {
        gameState.audioEnabled = !gameState.audioEnabled;
        const icon = document.getElementById('audioIcon');
        const toggle = document.getElementById('audioToggle');
        
        if (icon && toggle) {
            if (gameState.audioEnabled) {
                icon.textContent = '🔊';
                toggle.classList.remove('muted');
                if (gameState.gameRunning && gameState.currentRound <= rounds.length) {
                    const round = rounds[gameState.currentRound - 1];
                    playBackgroundMusic(round.bgMusic);
                }
            } else {
                icon.textContent = '🔇';
                toggle.classList.add('muted');
                stopBackgroundMusic();
            }
        }
        
        // Save preference
        try {
            localStorage.setItem('audioEnabled', gameState.audioEnabled);
        } catch (error) {
            console.error('Audio preference save failed:', error);
        }
        
    } catch (error) {
        console.error('Audio toggle failed:', error);
    }
}

// ============================================================================
// ENHANCED VIBRATION SYSTEM WITH FALLBACKS
// ============================================================================

function vibrate(pattern = [50]) {
    if (!gameState.audioEnabled) return; // Respect audio preference for haptics too
    
    try {
        if ('vibrate' in navigator) {
            navigator.vibrate(pattern);
        } else if ('webkitVibrate' in navigator) {
            navigator.webkitVibrate(pattern);
        }
    } catch (error) {
        console.log('Vibration failed:', error);
    }
}

// Enhanced touch feedback with vibration
document.addEventListener('touchstart', (e) => {
    if (e.target.classList.contains('btn') || e.target.closest('.distraction')) {
        vibrate([20]);
    }
});

// ============================================================================
// ENHANCED ANIMATION LOOP WITH PERFORMANCE MONITORING
// ============================================================================

function animate() {
    try {
        requestAnimationFrame(animate);
        
        // Update performance monitor
        performanceMonitor.update();
        
        if (particleSystem) {
            particleSystem.rotation.y += 0.003;
            particleSystem.rotation.x += 0.0015;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const time = Date.now() * 0.002;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += Math.sin(time + i) * 0.003;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        if (renderer && scene && camera) {
            renderer.render(scene, camera);
        }
    } catch (error) {
        console.error('Animation loop error:', error);
        // Don't break the animation loop, just log the error
    }
}

// ============================================================================
// ENHANCED EVENT HANDLERS AND STORAGE
// ============================================================================

window.addEventListener('beforeunload', () => {
    try {
        emergencySave();
        cleanupTracker.cleanup();
        
        const currentBest = localStorage.getItem('bestScore') || 0;
        if (gameState.score > currentBest) {
            localStorage.setItem('bestScore', gameState.score);
        }
        
        const currentBestStreak = localStorage.getItem('bestStreak') || 0;
        if (gameState.bestStreak > currentBestStreak) {
            localStorage.setItem('bestStreak', gameState.bestStreak);
        }
        
        // Update total games counter
        const totalGames = parseInt(localStorage.getItem('totalGames') || '0') + 1;
        localStorage.setItem('totalGames', totalGames);
        
    } catch (error) {
        console.error('Storage save failed:', error);
    }
});

// ============================================================================
// GLOBAL FUNCTION DECLARATIONS - For HTML onclick handlers
// ============================================================================

// Make functions globally accessible for HTML onclick handlers
window.restartGame = restartGame;
window.saveQRCode = saveQRCode;
window.generateChallengeCode = generateChallengeCode;
window.showEnterCode = showEnterCode;
window.shareWhatsApp = shareWhatsApp;
window.toggleAudio = toggleAudio;

// Debug mode 
const DEBUG_MODE = false;

if (DEBUG_MODE) {
    console.log('🎮 KamaSutra Endless Embrace Game - Debug Mode Active');
    
    // Additional debug logging
    window.addEventListener('load', () => {
        console.log('🔍 Debug Info:', {
            screenWidth: window.innerWidth,
            screenHeight: window.innerHeight,
            isMobile: window.innerWidth <= 768,
            audioContext: !!window.AudioContext,
            localStorage: !!window.localStorage,
            threeJS: !!window.THREE
        });
    });
}

</script>
</body>
</html>